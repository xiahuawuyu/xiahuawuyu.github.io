<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[亚里士朱德的博客]]></title>
    <link>http://yalishizhude.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[阅读，实践，学习，积累，分享]]></description>
    <pubDate>Thu, 14 Jul 2016 15:03:36 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[尝试通过AngularJS模块按需加载搭建大型应用（下）]]></title>
      <link>http://yalishizhude.github.io/2016/07/14/angular-large-2/</link>
      <guid>http://yalishizhude.github.io/2016/07/14/angular-large-2/</guid>
      <pubDate>Thu, 14 Jul 2016 09:27:53 GMT</pubDate>
      <description>
      <![CDATA[<p><em><a href="http://yalishizhude.github.io/2016/07/07/angular-large-1/">《尝试通过AngularJS模块按需加载搭建大型应用（上）》</a> 说到目前angular应用的通用构建方式，一种是全量预加载，将所有可能用到的模块在用户首次访问时加载；第二种是按需加载业务逻辑，根据路由加载对应的controller和view，两种处理方式互换优缺点。对比后得出最理想的方式应该是“模块按需加载”，即按需预加载业务功模块代码。本文具体聊聊如何实现。</em></p>]]>
      
      </description>
      <content:encoded><![CDATA[<p><em><a href="http://yalishizhude.github.io/2016/07/07/angular-large-1/">《尝试通过AngularJS模块按需加载搭建大型应用（上）》</a> 说到目前angular应用的通用构建方式，一种是全量预加载，将所有可能用到的模块在用户首次访问时加载；第二种是按需加载业务逻辑，根据路由加载对应的controller和view，两种处理方式互换优缺点。对比后得出最理想的方式应该是“模块按需加载”，即按需预加载业务功模块代码。本文具体聊聊如何实现。</em></p>
<a id="more"></a>
<h1 id="模块划分">模块划分</h1><p>上文说过了模块的加载方式，再来看看常见的模块划分依据，基本可以分为两类。</p>
<h2 id="按组件划分">按组件划分</h2><p>angular中有很多组件（service、controller、filter等等。angular组件可以理解是一段js代码，一段带有样式的html，或者两者兼而有之），其中一种划分就是把不同类别的组件划分到一个模块。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主模块</span></span><br><span class="line">angular.<span class="keyword">module</span>(<span class="string">'app'</span>, []);</span><br><span class="line"><span class="comment">//模块下所有的service</span></span><br><span class="line">angular.<span class="keyword">module</span>(<span class="string">'app.service'</span>, []);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//模块下所有的controller</span></span><br><span class="line">angular.<span class="keyword">module</span>(<span class="string">'app.controller'</span>, []);</span><br></pre></td></tr></table></figure>
<p>当然也有更简单更粗暴的划分方式，因为controller包含了业务逻辑，基本无复用可能性，而其他angular组件基本上可以被复用，统统放到一个模块，即变成：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主模块</span></span><br><span class="line">angular.<span class="keyword">module</span>(<span class="string">'app'</span>, []);</span><br><span class="line"><span class="comment">//service、filter、directive等</span></span><br><span class="line">angular.<span class="keyword">module</span>(<span class="string">'app.library'</span>, []);</span><br><span class="line"><span class="comment">//controller</span></span><br><span class="line">angular.<span class="keyword">module</span>(<span class="string">'app.controller'</span>, []);</span><br></pre></td></tr></table></figure>
<p>本质上都一样，都是按照组件划分。这种划分其实实际意义并不大，只是看起来显得解构略微清晰一点，可移植性略微提升了一丢丢，因为把包含业务逻辑的controller分离了出来。</p>
<h2 id="按业务划分">按业务划分</h2><p>这是比较推荐的一种划分方法。示例如下：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主模块</span></span><br><span class="line">angular.<span class="keyword">module</span>(<span class="string">'app'</span>, []);</span><br><span class="line"><span class="comment">//登陆注册</span></span><br><span class="line">angular.<span class="keyword">module</span>(<span class="string">'login'</span>, []);</span><br><span class="line"><span class="comment">//首页</span></span><br><span class="line">angular.<span class="keyword">module</span>(<span class="string">'home'</span>, []);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>好处就是A模块的需要引用B模块组件的时候，只需要引入B模块即可，可移植性高。<br>同时从理论上来说各业务模块的耦合性可以大大降低。本文所提的就是这种划分模式。<br>那是不是我们把不同模块放到不同的js文件，然后按需引用就可以了呢？<br>是也不是，目标是要达到这个效果，但是有个棘手的问题——路由。<br>上文提到的两种方式都有一个前提，就是 <strong>加载其它模块之前路由已经配置完成</strong>。<br>就以示例来说，如果我们在app模块配置login模块的路由，就会报错找不到controller。原因很简单，controller都在login模块下。那么是不是先把login模块引入就行了呢？恭喜你，进入了上文说的第一种全量预加载方式。<br>所以最佳的方式是 <strong>每个模块单独管理自己模块的路由，而不是由一个模块管理。</strong><br>如果路由跟着业务模块进行配置，那么问题来了：</p>
<ol>
<li>app模块没有了路由怎么加载视图?</li>
<li>各个模块之间怎么实现“页面跳转”？</li>
</ol>
<p>带着问题接着往下看~</p>
<h1 id="按需加载">按需加载</h1><p>先简单介绍一下懒加载文件的依赖模块。上文说过第三方插件和框架的兼容性，依赖加载还是考虑比较成熟的第三方angular模块<a href="https://github.com/ocombe/ocLazyLoad" target="_blank" rel="external">oc.lazyLoad</a>。主要作用就是按照模块名懒加载该模块依赖的文件，包括js和其它文件。<br>可以首先在主模块app中配置模块信息。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'app'</span>, [<span class="string">'oc.lazyLoad'</span>]).config(<span class="keyword">function</span>(<span class="string">'$ocLazyLoadProvider'</span>)&#123;</span><br><span class="line">  //配置了两个模块</span><br><span class="line">  // ngAnimate是第三方模块，依赖angular-animate.min.js</span><br><span class="line">  // home是业务模块， 依赖home.js、home.css、home-html.js文件</span><br><span class="line">  <span class="variable">$ocLazyLoadProvider</span>.config(&#123;</span><br><span class="line">    modules: [&#123;</span><br><span class="line">      name: <span class="string">'ngAnimate'</span>,</span><br><span class="line">      files: [<span class="string">'lib/angular-animate/angular-animate.min.js'</span>]</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      name: <span class="string">'home'</span>,</span><br><span class="line">      files: [<span class="string">'home/script/home.js'</span>, <span class="string">'home/style/home.css'</span>， <span class="string">'home/view/home-html.js'</span>]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当然这只是为了举例，真正写代码的时候不会这么写，配置数据肯定要分离出来，不要和业务逻辑混在一起。<br>要加载模块的时候也非常简单，利用<code>$ocLazyLoad</code>服务的<code>load</code>函数。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//返回一个promise对象</span><br><span class="line"><span class="variable">$ocLazyLoad</span>.load(moduleName).<span class="keyword">then</span>(<span class="keyword">function</span>() &#123;</span><br><span class="line">  //加载完成之后</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="路由管理">路由管理</h1><p>因为我们将路由都封装在各个业务模块之中，但是页面首次加载的时候只有app模块，所以这里我们需要引用ui.router处理一下。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 在<span class="variable">$rootScope</span>上监听<span class="string">'$locationChangeSuccess'</span>事件</span><br><span class="line">// 当用户在浏览器中输入URL地址时触发</span><br><span class="line"><span class="variable">$rootScope</span>.<span class="variable">$on</span>(<span class="string">'$locationChangeSuccess'</span>, <span class="keyword">function</span> () &#123;</span><br><span class="line">  if(!<span class="variable">$location</span>.path()) <span class="variable">$location</span>.path(<span class="string">'/'</span>);</span><br><span class="line">  var mod = <span class="variable">$location</span>.path().split(<span class="string">'/'</span>)[<span class="number">1</span>]||<span class="string">'home'</span>;</span><br><span class="line">  // 路由路径按照 <span class="string">"模块/页面"</span> 的方式配置，有两个好处：</span><br><span class="line">  // <span class="number">1</span>. 避免不同模块的路径冲突</span><br><span class="line">  // <span class="number">2</span>. 可以通过路径判断模块</span><br><span class="line">  <span class="variable">$ocLazyLoad</span>.load(mod).then(function () &#123;</span><br><span class="line">    <span class="variable">$urlRouter</span>.sync();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable">$urlRouter</span>.listen();</span><br></pre></td></tr></table></figure>
<p>当然，直接这么写不会生效，我们需要阻塞ui.router默认的监听事件，在app模块的config中调用一个函数</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$urlRouterProvider</span>.deferIntercept();</span><br></pre></td></tr></table></figure>
<p>这么一来当用户直接输入地址或者从收藏夹访问页面的时候可以先加载业务模块，然后由业务模块的路由来处理页面加载。这样第一个问题就解决了。还有内部跳转的情况。</p>
<p>通常ui.router用得最多的跳转方式有两种，一种是指令<code>ui-sref</code>，另一种是函数<code>$state.go</code>。虽然前者写在视图上后者写在controller中，但研究源码后发现都是调用了<code>$state.transitionTo</code>。</p>
<p>现在想要从home模块直接跳到login模块是会报错的，因为login模块没有加载找不到对应的路由。那么需要做的就是在路由跳转之前加载对应的模块，这里需要对<code>$state.transitionTo</code>稍微改造一下。</p>
<p>不得不用到angular中的黑科技<code>decorator</code>。<code>decorator</code>在常用开发中用得很少，它最大的作用就是修改第三方模块的服务，而且是在 <strong>不修改源码</strong> 的情况下。直接看代码和注释：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//处理模块间跳转</span><br><span class="line"><span class="variable">$provide</span>.decorator(<span class="string">'$state'</span>, <span class="keyword">function</span>(<span class="variable">$delegate</span>, <span class="variable">$ocLazyLoad</span>) &#123;</span><br><span class="line">  var state = &#123;&#125;;</span><br><span class="line">  // angular对象还是有些实用的方法的，深拷贝对象算是一个</span><br><span class="line">  // 这里做深拷贝不做浅拷贝是避免循环嵌套调用内存溢出</span><br><span class="line">  angular.copy(<span class="variable">$delegate</span>, state);</span><br><span class="line">  <span class="variable">$delegate</span>.transitionTo = function (to) &#123;</span><br><span class="line">    // 跳转的时候有两种情况，一种是传入self对象，另一种是直接把state的id传进来</span><br><span class="line">    if (to.self) &#123;</span><br><span class="line">      // 当to为对象时，读取self.url属性获取路径，因为路径命名遵循<span class="string">"模块/页面"</span>的方式，所以可以轻松判读取模块名</span><br><span class="line">      var mod = to.self.url.replace(<span class="string">'main.'</span>, <span class="string">''</span>).replace(/\/(.*)\/.*/, <span class="string">'$1'</span>);</span><br><span class="line">      if (!mod || <span class="string">'/'</span> === mod) &#123;</span><br><span class="line">        mod = <span class="string">'home'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      //模块加载完成后再调用默认的路由跳转函数</span><br><span class="line">      <span class="variable">$ocLazyLoad</span>.load(mod).then(function ()&#123;</span><br><span class="line">        state.transitionTo.apply(null, arguments);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      var id = to.replace(<span class="string">'main.'</span>, <span class="string">''</span>).replace(/(([a-z]*)[A-Z]&#123;<span class="number">1</span>&#125;)?.*/, <span class="string">'$2'</span>);</span><br><span class="line">      <span class="variable">$ocLazyLoad</span>.load(mnModule[id].name).then(function() &#123;state.transitionTo.apply(null, arguments);&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return <span class="variable">$delegate</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1><p>按照上述方式组织代码之后，业务模块一般会包含3个合并后的文件，一个js业务逻辑，一个css样式，一个模板文件。模块间相互引用，路由跳转传参，嵌套路由，多重路由等常用功能都可以正常使用。<br>框架代码只是一部分，还需要构建工具配合~</p>
<p>源码目录结构大致如下：</p>
<img src="/2016/07/14/angular-large-2/dev.png" alt="dev.png" title="">
<p>编译后的代码：</p>
<img src="/2016/07/14/angular-large-2/dist.png" alt="dist.png" title="">
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2016/07/14/angular-large-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[尝试通过AngularJS模块按需加载搭建大型应用（上）]]></title>
      <link>http://yalishizhude.github.io/2016/07/07/angular-large-1/</link>
      <guid>http://yalishizhude.github.io/2016/07/07/angular-large-1/</guid>
      <pubDate>Thu, 07 Jul 2016 15:00:44 GMT</pubDate>
      <description>
      <![CDATA[<p><em>没有合适的轮子，只好自己造( ╯□╰ )</em></p>]]>
      
      </description>
      <content:encoded><![CDATA[<p><em>没有合适的轮子，只好自己造( ╯□╰ )</em></p>
<a id="more"></a>
<h1 id="模块化">模块化</h1><p>模块化在当前大中型web项目开发中已经成为共识，从浏览器端AMD的requirejs到node.js遵循的commonjs规范，再到ES6开放了import关键字来管理模块都是最好的说明。其优势就是方便多人协作开发，代码可移植性可测试性高。<br>angular本身自带模块定义和依赖管理功能，这个模块管理一般是怎么使用的？<br>我们找个网站分析一波~<br>作为爱智求真的小伙伴，我们就来看看 <strong>知乎</strong> 旗下的 <strong><a href="https://zhuanlan.zhihu.com/" target="_blank" rel="external">知乎专栏</a></strong> 。<br>先打开调试工具，截个图慢慢看~<br><img src="/2016/07/07/angular-large-1/zhihu.png" alt="zhihu.png" title=""><br>点开这个带有hash戳被压缩的js文件，可以看到如下几个模块：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">(function<span class="params">()</span> &#123;</span><br><span class="line">  angular.module<span class="params">(<span class="string">"auth"</span>, [<span class="string">"auth.interceptor"</span>])</span></span><br><span class="line">&#125;</span><br><span class="line">)</span>.call<span class="params">(this)</span>,</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">function</span><span class="params">()</span> &#123;</span></span><br><span class="line"> angular.<span class="keyword">module</span><span class="params">(<span class="string">"auth.interceptor"</span>, [])</span>.</span><br><span class="line">&#125;.call<span class="params">(this)</span></span><br><span class="line">...</span><br><span class="line">var app = angular.<span class="keyword">module</span><span class="params">(<span class="string">"columnWebApp"</span>, [<span class="string">"auth"</span>, <span class="string">"blueimp.fileupload"</span>, <span class="string">"placeholderShim"</span>, <span class="string">"angularytics"</span>, <span class="string">"ngAnimate"</span>, <span class="string">"ngRoute"</span>, <span class="string">"ngTouch"</span>, <span class="string">"ngResource"</span>, <span class="string">"ngSanitize"</span>])</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这里声明了3个模块：</p>
<ul>
<li><code>auth</code>模块依赖了<code>auth.interceptor</code>模块。</li>
<li><code>auth.interceptor</code>模块无依赖。</li>
<li><code>columnWebApp</code>模块是个花心大萝卜，和一堆的模块有依赖关系。</li>
</ul>
<hr>
<p><em>弱弱地吐槽一波：用匿名函数做闭包来避免全局污染的是常见的传统做法，这里初步判断应该是由多个js文件合并而成，这里起码有两点是可以改进的。 一是<code>window</code>、<code>angular</code>这种全局变量完全可以传参到闭包内部便于代码压缩，例如：</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//压缩前</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, angular</span>)</span>&#123;</span><br><span class="line">  angular.module(<span class="string">'auth'</span>, []);</span><br><span class="line">&#125;(<span class="built_in">window</span>, angular));</span><br><span class="line"><span class="comment">//压缩后可能是</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, a</span>)</span>&#123;</span><br><span class="line">  a.module(<span class="string">'auth'</span>, []);</span><br><span class="line">&#125;(<span class="built_in">window</span>, angular));</span><br></pre></td></tr></table></figure>
<p><em>二是这种压缩打包的方式还是比较粗糙的，建议开发人员有时间还是可以将多余的模块引用去掉，变成链式调用，例如：</em></p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 合并前</span><br><span class="line">angular.module(<span class="string">'auth'</span>).service(<span class="string">'xxx'</span>, <span class="keyword">function</span>()&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br><span class="line">angular.module(<span class="string">'auth'</span>).controller(<span class="string">'xxCtrl'</span>, [<span class="string">'$scope'</span>, <span class="keyword">function</span>(<span class="variable">$scope</span>)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;]);</span><br><span class="line">// 合并后</span><br><span class="line">angular.module(<span class="string">'auth'</span>).service(<span class="string">'xxx'</span>, <span class="keyword">function</span>()&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;).controller(<span class="string">'xxCtrl'</span>, [<span class="string">'$scope'</span>, <span class="keyword">function</span>(<span class="variable">$scope</span>)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p><em>另外严格模式也建议开启。</em><br><em>吐槽 end~</em></p>
<hr>
<p>从上面的例子可以看出，Angular项目通用的做法是：开发的时候按照业务逻辑写成不同的js文件，然后把这些js文件压缩合并成一个或多个，在用户第一次访问的时候全部返回给浏览器做预加载。</p>
<p>这种处理方式在小型网站还好，性能要求不高的中型网站也勉强可用，但是对于对于大型网站影响，随着js文件变多用户首次访问的加载时间会跟着增加，看看那些PV上千万、上亿的网站为了首页优化各种技术层出不穷。而且这种处理方式也是很不合理的，用户可能只想看看首页或者只使用某个功能模块，为毛要把所有的代码都家再过来浪费用户时间？</p>
<p>张鑫旭写过一篇 <a href="http://www.zhangxinxu.com/wordpress/2016/06/image-preload-based-on-user-behavior/" target="_blank" rel="external">《基于用户行为的图片等资源预加载》</a> 说的也是类似问题。这个解决思路很有意思，分析用户的操作行为，按需进行预加载。有兴趣大家可以看一看。<br>既然有了这个需求，我们看看目前有什么现成的解决方案~</p>
<h1 id="按需加载">按需加载</h1><p>目前angular项目普遍使用<a href="https://github.com/angular-ui/ui-router" target="_blank" rel="external">ui.router</a>模块已经成了不争的事实了，用它来管理每个“页面（视图）”和“页面对应的业务逻辑（控制器）”，依照大多数人的直觉思维。将按需加载理解为按页面加载，于是便出现了一些解决方案，基本思路都是一致的：</p>
<p>在“页面（视图）跳转”的时候，按需加载业务逻辑（控制器）。而恰好ui.router模块在配置路由的时候提供了一个resovle属性，可以在页面逻辑（控制器）加载之前进行一些操作。略有不同的便是有的使用了<a href="https://github.com/ocombe/ocLazyLoad" target="_blank" rel="external">oclazyload</a>，这个还比较好，起码是遵循angular框架的第三方模块，有的使用了requirejs，这种感觉就像是阿玛尼西装配阿迪达斯球鞋，虽然都是“阿”字系的，但想去甚远，做angular开发的时候还是尽量不要应用不按照angular规范开发的第三方插件，毕竟angular这种强框架不像requirejs有shim，所以还是避免给自己挖坑。</p>
<p>可这真的就是完美的解决方案吗？起码有以下几个问题：</p>
<ol>
<li>每次“页面跳转”都要额外请求js并加载，浪费带宽增加页面加载时间，基本抛弃了预加载。</li>
<li>每一个路由都需要配置resolve属性，太low。</li>
<li>模块化程度太低，不利于以后代码移植和维护。</li>
</ol>
<h1 id="模块按需加载">模块按需加载</h1><p>将前面提到的模块化和按需加载结合起来看，比较好的解决方案应该是：按照业务功能划分模块，当用户点击某个功能模块的时候，按需加载该功能所需的文件。</p>
<p>举个不太恰当但容易理解的例子，当用户点击百度音乐的时候，从用户行为角度分析，这个用户很有可能会进行一些相关操作：比如搜歌、听歌等等。同时很有可能用户当前并不会访问贴吧或者新闻。所以此时按需加载音乐模块的代码逻辑，对于后续的搜歌、听歌操作实现了预加载。</p>
<p>这样的实现方式还会带来其它好处，下回详述~</p>
<p>同时也欢迎读者提供好的想法或者其它解决方案~ (●’◡’●)</p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2016/07/07/angular-large-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Angular说：这个锅我不背~]]></title>
      <link>http://yalishizhude.github.io/2016/05/30/4angular/</link>
      <guid>http://yalishizhude.github.io/2016/05/30/4angular/</guid>
      <pubDate>Sun, 29 May 2016 16:59:30 GMT</pubDate>
      <description>
      <![CDATA[<h1 id="楔子">楔子</h1><p>最近月影大神翻译的一篇文章很火——<a href="http://web.jobbole.com/86284/">《别责怪框架：我使用 AngularJS 和 ReactJS 的经验》</a>，标题看似客观，不过先扬后抑，借黑Angular之际狠赞了一下react。<br>看完之后也让我有感而发。写这篇文章的目的，并不是想反作者之道，褒Angular贬React，只是希望读者抛开个人情绪，对两者（或者Angular？）有一个更客观地认识。</p>]]>
      
      </description>
      <content:encoded><![CDATA[<h1 id="楔子">楔子</h1><p>最近月影大神翻译的一篇文章很火——<a href="http://web.jobbole.com/86284/" target="_blank" rel="external">《别责怪框架：我使用 AngularJS 和 ReactJS 的经验》</a>，标题看似客观，不过先扬后抑，借黑Angular之际狠赞了一下react。<br>看完之后也让我有感而发。写这篇文章的目的，并不是想反作者之道，褒Angular贬React，只是希望读者抛开个人情绪，对两者（或者Angular？）有一个更客观地认识。</p>
<a id="more"></a>
<h1 id="ReactJS与Angular">ReactJS与Angular</h1><p>还记得一年前刚接触Angular的时候感觉既惊喜又恐惧。惊喜的是双向绑定、指令…这些功能太炫酷了，恐惧的是感觉是在重新学习一门新的语言，如果说小米重新定义了手机的话，那么Angular应该是重新定义了javascript。</p>
<p><strong>它的模块功能以及依赖注入很像AMD规范的requirejs，它的视图数据绑定更像是DOM操作升级版，它的路由功能又与backbone有异曲同工之妙，内置的<code>$q</code>和<code>$http</code>服务很好的解决了异步通信问题，不和jquery冲突的同时内置了类似jquery风格的原生DOM操作方式…最难能可贵的是，它还提供了单元测试和端到端的解决方案。</strong></p>
<p>而对ReactJS我还只停留在hello world的层次，曾经在知乎上看到有人评价react的时候说是因为Angular的指令系统太难学，所以搞了一套这个玩意，不知真假。参考官网宣传及各种文章对react的吹捧，觉得优点应该有3个吧：</p>
<h2 id="组件化">组件化</h2><p>Angular的指令完全能实现组件化，支持嵌套和数据绑定，它的依赖注入使得引用也非常方便。</p>
<h2 id="虚拟DOM提升性能">虚拟DOM提升性能</h2><p>PC端上就现代浏览器内核的渲染性能而言，用Angular没出现过什么性能问题。<br>移动端在操作比较多的DOM时，低端机上会出现卡顿。不过还是有优化方案的，而且Angular本身也是不提倡频繁、大量的操作DOM，比如HTML游戏。</p>
<h2 id="React_Native">React Native</h2><p>我看好React的原因很大程度在于它，这种跨平台能力还是很有价值的。这一点也是可以秒杀Angular的，不过目前还不了解是否有成熟的大型应用~</p>
<h1 id="解决方案">解决方案</h1><p>对于文中所提问题，我以自己对Angular的粗浅了解，花了几分钟，试着解答了一下~</p>
<p>1.改变 URL 的时候不重新加载 controller 或者渲染基础模板。</p>
<p>如果认真看了官方文档关于<a href="https://docs.angularjs.org/api/ng/service/$location" target="_blank" rel="external">$location</a>服务的介绍之后，要解决这个问题并不难。通过<code>$location</code>服务在hash值中添加url参数，这个参数不在路由中配置就不会刷新controller和视图，同时，又可以通过<code>$location</code>服务来获取它。具体方法我已写在了<a href="https://github.com/angular/angular.js/issues/1699#issuecomment-222364152" target="_blank" rel="external">issue</a>上。</p>
<p>2.想要从一个准备发送给服务器的 JSON 中移除一些空白字段时，发现 UI 中对应的数据也被一并移除了 —— 丫的双向绑定 ╮(╯▽╰)╭。</p>
<p>双向绑定应该是利大于弊的（虽然脏检测机制经常遭人诟病），基本上不再需要手动操作DOM。简化了逻辑，少了很多重复代码，同时也减少了视图与数据层忘记同步带来的错误。<br>这个问题当然也非常好解决，前提是如果你读过官方文档关于<a href="https://code.angularjs.org/1.5.6/docs/guide/expression" target="_blank" rel="external">表达式</a>的表述。那就是用用双冒号<code>::</code>可以实现单次绑定，之后操作数据就不会再与视图同步了，或者直接创建一个只含需要属性的新对象更简单，方法很多~</p>
<p>3.当想要使用 ngShow 和 ngHide 来显示一个 HTML 块同时隐藏另一个 HTML 块时，在一瞬间，两者同时显示了。</p>
<p>ng-cloak和loading页，随便选一个即可。</p>
<h1 id="写在最后">写在最后</h1><p><strong>很多人都有一种畏难的心理，放弃学习Angular，或者向之前文章作者那样赶鸭子上架地被迫学习，从而变得痛恨，（就像你没有使用过VIM就无法理解为什么它被称作编辑器之神，不知道它是如何依靠“模式”来实现无鼠标操作光标，不知道它的宏之强大…）这其实是一种损失。因为Angular确实是一个优秀的框架，它的优秀不仅仅在于前面我说的那些优点。它不单单是强大的开发框架，更像是饱含了作者设计思想和理念的艺术品（当你阅读完官网开篇介绍的最后一部分：<a href="https://code.angularjs.org/1.5.6/docs/guide/introduction" target="_blank" rel="external">Angular的禅道</a>之时愈发会有此感）。</strong></p>
<p>最后引用<a href="http://baike.baidu.com/item/%E7%BD%97%E6%8C%AF%E5%AE%87/1982837" target="_blank" rel="external">罗胖</a>说过的一句话做为文章的结尾。</p>
<p>“我创业之后越来越少负面地区评价一个人和一件事，是因为我清楚地知道，一旦我做出这样一个结论，以我的知识和逻辑能力，我马上会编造一套理由，在自己内心里来论证自己这个判断。而因此的结果就是我从此丧失了对这个人这个事代表的所有现象的好奇心和求知欲，也就是说，我认知的大门就关上了。”</p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2016/05/30/4angular/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[利用handlebars实现后端组件化]]></title>
      <link>http://yalishizhude.github.io/2016/04/26/back-componentization/</link>
      <guid>http://yalishizhude.github.io/2016/04/26/back-componentization/</guid>
      <pubDate>Mon, 25 Apr 2016 16:19:57 GMT</pubDate>
      <description>
      <![CDATA[<p><em>似乎掌握了后端组件化的奥义^_^</em></p>]]>
      
      </description>
      <content:encoded><![CDATA[<p><em>似乎掌握了后端组件化的奥义^_^</em></p>
<a id="more"></a>
<blockquote>
<p>基本说明（使用过exress和handlebars的可以略过）：express中的handlebars引擎是这么生成页面的：<br><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">/* layout.hbs</span><br><span class="line"> * 主模板，所有的的页面都将替换"</span><span class="expression">&#123;&#123;&#123;<span class="variable">body</span>&#125;&#125;</span><span class="xml">&#125;"，"</span><span class="expression">&#123;&#123;&#125;&#125;</span><span class="xml">"相当于占位符，由数据进行替换</span><br><span class="line"> */</span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span></span><span class="expression">&#123;&#123;<span class="variable">title</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    </span><span class="expression">&#123;&#123;&#123;<span class="variable">body</span>&#125;&#125;</span><span class="xml">&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">/* index.hbs</span><br><span class="line"> * 单个页面模板，这里以首页为例。"</span><span class="expression">&#123;&#123;&gt;&#125;&#125;</span><span class="xml">"表示引用其他模板来替换，这里引用名为"partial"的模板</span><br><span class="line"> */</span><br><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span>index<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span><span class="expression">&#123;&#123;&gt;<span class="variable">partial</span>&#125;&#125;</span><span class="xml"></span><br><span class="line"></span><br><span class="line">/* partial.hbs</span><br><span class="line"> * 一个分页文件，被其他模板引用，分页之间也可以互相引用。</span><br><span class="line"> */</span><br><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span>123<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">/* index.html</span><br><span class="line"> * 当浏览器请求index.html时，经过handlebars模板引擎处理后生成的页面</span><br><span class="line"> */</span><br><span class="line"> <span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">title</span>&gt;</span><span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">div</span>&gt;</span>index<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">div</span>&gt;</span>123<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="title">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="实现步骤1：模板">实现步骤1：模板</h1><p>react的火热让“组件化”的概念持续升温，不过组件化确实在开发中提供了高可复用的代码，大大减少了工作量和bug，确实值得提倡。举个例子。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul <span class="keyword">class</span>=<span class="string">"titles border"</span> id=<span class="string">"navigator"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"title"</span>&gt;标题1&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"title"</span>&gt;标题2&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"title"</span>&gt;标题3&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p>这一段html代码，会在几个页面用到，如果按照一般的做法把这段代码ctrl-c、ctrl-v到要用的页面。就会出现两个问题：1.重复代码增多（ctrl-c、ctrl-v应该是程序员的大忌），当然这不是最重要的，最重要的是第2点——维护性差。如果现在我要把“标题1”改成“标题0”，那么只能进行全量搜索然后替换，不仅操作麻烦而且容易出错。<br>如果用到了模板技术的话这个问题就很好解决，把上面那一段代码写成一个模板，在handlebars中我们成为分页，然后需要这段的代码的页面引用这个分页，如果要修改的话直接修改分页了。以handlebars为例：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//navigator.hbs</span></span><br><span class="line">&lt;ul <span class="keyword">class</span>=<span class="string">"titles border"</span> id=<span class="string">"navigator"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"title"</span>&gt;标题1&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"title"</span>&gt;标题2&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"title"</span>&gt;标题3&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在index.hbs中引用</span></span><br><span class="line">&#123;&#123;&gt;navigator&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>为什么handlebars？本文所用的后端模板引擎都以handlebars为例，原因是上次听去哪儿前端团队做的关于node.js的技术分享，炫耀了一个自己基于handlebars实现的小功能：分页中引用的css文件可以全部放到head中。心中一直觊觎这个小功能，直到最近和“组件化”的概念结合在一起考虑，发现这个功能对于实现后端的组件化很有帮助。自己对handlebars也略有研究，所以试着用handlebars来实现一下“组件化”。</p>
</blockquote>
<h1 id="实现步骤2：打包">实现步骤2：打包</h1><p>这样就完美了么？no~no~no~<br>上面的这一段html代码中可是有样式的，按照w3c的规范，样式应该写在css文件中，怎么实现？自然而然想到两种解决办法：</p>
<ol>
<li>在分页中加入link标签来引入所需的样式，想一想html代码中到处穿插link标签是什么感觉~且不说生成页面难以维护，浏览器渲染速度也会受影响。</li>
<li>把分页所需的样式放在公共的样式文件中，这是目前我们项目的通用做法，纯粹的懒人策略，缺点很明显，很多页面引用了一些无用的样式，浪费网络带宽，尤其当项目变大时这个缺点将更加明显。<br>所以最好的解决方法是按需加载，只加载引用组件所需的样式，当然样式文件按分页拆分得这么细的话会增加请求数，影响不会太大，如果想优化的话也可以压缩合并成一个请求，这个后面再说。<br>handlerbas中常见的扩展方式就是编写helper，我们可以编写一个helper，</li>
</ol>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line">hbs.registerHelper(<span class="string">'css'</span>, <span class="function"><span class="keyword">function</span><span class="params">(str, option)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//在上下文中创建一个数组用来保存该页面需要用到的css文件</span></span><br><span class="line">  <span class="keyword">this</span>.cssList = <span class="keyword">this</span>.cssList || [];  </span><br><span class="line">  <span class="keyword">this</span>.cssList.push(str);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个helper的作用就是注册一个名为”css”的helper，帮我们保存分页中用到的css文件地址。然后我们在主模板layout的head标签部分遍历cssList数组循环加载出来。</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">//layout.hbs</span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">title</span>&gt;</span></span><span class="expression">&#123;&#123;<span class="variable">title</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  </span><span class="expression">&#123;&#123;<span class="begin-block">#<span class="keyword">each</span> cssList</span>&#125;&#125;</span><span class="xml"></span><br><span class="line">  <span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"</span></span></span><span class="expression">&#123;&#123;<span class="variable">this</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="value">"</span> <span class="attribute">media</span>=<span class="value">"screen"</span> <span class="attribute">title</span>=<span class="value">"no title"</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">  </span><span class="expression">&#123;&#123;<span class="end-block">/<span class="keyword">each</span></span>&#125;&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">...</span></span><br></pre></td></tr></table></figure>
<p>同时原来的分页改成<br><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">//navigator.hbs</span><br><span class="line"></span><span class="expression">&#123;&#123;<span class="variable">css</span> '<span class="end-block">/stylesheets</span><span class="end-block">/components</span><span class="end-block">/navigator.css</span>'&#125;&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"titles border"</span> <span class="attribute">id</span>=<span class="value">"navigator"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"title"</span>&gt;</span>标题1<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"title"</span>&gt;</span>标题2<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"title"</span>&gt;</span>标题3<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面写的只是一个简单的无逻辑的静态组件，有些组件可能会有交互效果，比如处理一些点击事件或者对外暴露可操作的接口等，那么就需要js逻辑来实现了。</p>
<h1 id="实现步骤3：逻辑">实现步骤3：逻辑</h1><p>其实实现原理也大同小异，也是先注册一个helper，然后在主模板layout中添加，这里我们在原来的分页中引入一个js文件。具体代码如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line">hbs.registerHelper(<span class="string">'js'</span>, <span class="function"><span class="keyword">function</span><span class="params">(str, option)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.jsList = <span class="keyword">this</span>.jsList || [];</span><br><span class="line">  <span class="keyword">this</span>.jsList.push(str);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">//layout.hbs</span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">  </span><span class="expression">&#123;&#123;&#123;<span class="variable">body</span>&#125;&#125;</span><span class="xml">&#125;</span><br><span class="line">  </span><span class="expression">&#123;&#123;<span class="begin-block">#<span class="keyword">each</span> jsList</span>&#125;&#125;</span><span class="xml"></span><br><span class="line">  <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"</span></span></span><span class="expression">&#123;&#123;<span class="variable">this</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="value">"</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  </span><span class="expression">&#123;&#123;<span class="end-block">/<span class="keyword">each</span></span>&#125;&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">//navigator.hbs</span><br><span class="line"></span><span class="expression">&#123;&#123;<span class="variable">css</span> '<span class="end-block">/stylesheets</span><span class="end-block">/components</span><span class="end-block">/navigator.css</span>'&#125;&#125;</span><span class="xml"></span><br><span class="line"></span><span class="expression">&#123;&#123;<span class="variable">js</span> '<span class="end-block">/javascripts</span><span class="end-block">/components</span><span class="end-block">/navigator.js</span>'&#125;&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"titles border"</span> <span class="attribute">id</span>=<span class="value">"navigator"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"title"</span>&gt;</span>标题1<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"title"</span>&gt;</span>标题2<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"title"</span>&gt;</span>标题3<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>现在已经实现将css、js、html封装成独立的组件了，不过这样还是有个问题。如果a组件引用了public.css和a.css文件，而b组件引用了public.css和b.css文件，那么按照上面的做法，会在head写两个同样的link标签，组件共同依赖的文件越多，重复的标签就越多。这当然不是我们所想看到的。</p>
<h1 id="实现步骤4：依赖">实现步骤4：依赖</h1><p>为了解决这个问题我们还需要去重复，对刚才的两个helper改造一下即可。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line">hbs.registerHelper(<span class="string">'css'</span>, <span class="function"><span class="keyword">function</span><span class="params">(str, option)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cssList = <span class="keyword">this</span>.cssList || [];</span><br><span class="line">  <span class="keyword">if</span>(cssList.indexOf(str)&lt;<span class="number">0</span>) &#123;</span><br><span class="line">    cssList.push(str);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.cssList = cssList.concat();</span><br><span class="line">&#125;);</span><br><span class="line">hbs.registerHelper(<span class="string">'js'</span>, <span class="function"><span class="keyword">function</span><span class="params">(str, option)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> jsList = <span class="keyword">this</span>.jsList || [];</span><br><span class="line">  <span class="keyword">if</span>(jsList.indexOf(str)&lt;<span class="number">0</span>) &#123;</span><br><span class="line">    jsList.push(str);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.jsList = jsList.concat();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>最终生成的页面截图：<br><img src="/2016/04/26/back-componentization/html.jpg" alt="html.jpg" title=""></p>
<h1 id="实现步骤5：合并">实现步骤5：合并</h1><p>最后一步优化。为了减少请求，可以将不同组件所需的资源文件进行合并。这里推荐一个插件<a href="https://github.com/JacksonTian/loader" target="_blank" rel="external">loader</a>。</p>
<p><a href="https://github.com/yalishizhude/back-componentization-example" target="_blank" rel="external">示例代码下载地址</a></p>
<p><em>以上就是关于后端利用模板实现组件化的探索，实现上虽无问题，但是由于目前没有新的项目，无法在实际项目中使用，所以不知道会不会带来其它的“坑”。欢迎有兴趣的朋友使用后与我交流~</em></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2016/04/26/back-componentization/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[图解基于node.js实现前后端分离]]></title>
      <link>http://yalishizhude.github.io/2016/04/19/front-back-separation/</link>
      <guid>http://yalishizhude.github.io/2016/04/19/front-back-separation/</guid>
      <pubDate>Tue, 19 Apr 2016 14:02:51 GMT</pubDate>
      <description>
      <![CDATA[<p>首先庆祝 <a href="http://www.w3ctech.com/event/56">w3ctech长沙站第12期技术分享会</a> 圆满成功，感谢组织方邀请~<br><img src="/2016/04/19/front-back-separation/w3c.jpg" alt="w3c.jpg" title=""></p>
<p>因为会上出了个意外，ppt图片全部丢失，只好对着白板跟大家交流了半个多小时。由于我做演讲不喜欢写太多的文字，没有图片的情况下讲漏了一些内容。这篇文章是我在会上分享内容对照ppt进行地整理。</p>]]>
      
      </description>
      <content:encoded><![CDATA[<p>首先庆祝 <a href="http://www.w3ctech.com/event/56" target="_blank" rel="external">w3ctech长沙站第12期技术分享会</a> 圆满成功，感谢组织方邀请~<br><img src="/2016/04/19/front-back-separation/w3c.jpg" alt="w3c.jpg" title=""></p>
<p>因为会上出了个意外，ppt图片全部丢失，只好对着白板跟大家交流了半个多小时。由于我做演讲不喜欢写太多的文字，没有图片的情况下讲漏了一些内容。这篇文章是我在会上分享内容对照ppt进行地整理。</p>
<a id="more"></a>
<h1 id="基本介绍">基本介绍</h1><img src="/2016/04/19/front-back-separation/3.jpg" alt="3.jpg" title="">
<p>首先从一个重要的概念“模板”说起。<br>广义上来说，web中的模板就是填充数据后可以生成文件的页面。<br>严格意义上来说，应该是模板引擎利用特定格式的文件和所提供的数据编译生成页面。模板大致分为前端模板（如ejs）和后端模板（如freemarker）分别在浏览器端和服务器端编译。</p>
<img src="/2016/04/19/front-back-separation/4.jpg" alt="4.jpg" title="">
<p>由于当场有一部分同学对node.js并不是很了解，这里补充一下node.js的相关知识。官网上的给他的定义事件驱动、异步什么的就不说了。这里借用朴灵书上的一张图来解释一下node.js这个玩意的结构。如果懂java的同学可以将其理解为js版本的jvm。<br>浏览器一般包括渲染器和js脚本引擎，以chrome浏览器为例，用的webkit内核的渲染器，V8的脚本引擎，而node.js用到了v8引擎。总而言之它就是一个js的运行环境，就好比浏览器的F12调试工具，只不过node.js没有DOM和BOM。</p>
<img src="/2016/04/19/front-back-separation/7.jpg" alt="7.jpg" title="">
<p>这张图描述的是node.js周边的一些信息，比如npm这个出色的包管理器和cnode社区以及github，都在一定程度上促进了node.js的繁荣，提供了技术保障。</p>
<img src="/2016/04/19/front-back-separation/6.jpg" alt="6.jpg" title="">
<p>大公司通常都是技术的风向标，例如google的angular、facebook的react现在都很火。这里只列了3个大公司当作例子。淘宝的中途岛架构就不用说了，国内node.js的先行者朴灵就来自淘宝。去哪儿也出了个应该叫做“QTX”的技术框架。360月影带领的75团队出了个基于ES6/ES7的web服务器框架——thinkjs，当时我们技术总监很看好，但是由于鄙人没有时间学习ES6再加上插件不够丰富，所以还是选用了较为成熟的Express。</p>
<img src="/2016/04/19/front-back-separation/5.jpg" alt="5.jpg" title="">
<p>言归正传，这个表格列出了我所接触过的3种前后端分离的开发方式。<br>第一种是最常见的使用java之类的后端语言模板，SEO友好，缓存利用率和减轻浏览器渲染负担方面都比较好，最大的问题就是模板文件的耦合度太高，出了问题谁都不想来解决，前端人员看不到数据，后端人员不懂页面，模板文件就像是一个烫手的山芋。<br>第二种是目前我们项目移动端的实现方案，利用angular这种框架（angular的指令可以看成是前端模板）和nginx这种反向代理服务器，让前后端彻底解耦，只通过ajax交互数据。这种方案和前一种的优缺点刚好相反。前端模板的性能始终是个问题，尤其是在移动端，更尤其是在低端的移动设备上。<br>最后一种是新项目使用的用node.js做前端服务器，将前端的职责从浏览器划分到了模板这一层，解决了以上所有的问题，不过确实也有新的问题，这种问题稍后再分析。</p>
<img src="/2016/04/19/front-back-separation/9.jpg" alt="9.jpg" title="">
<p>当然全栈开发在小型项目中也是非常适合的。对于传统的jsp/php开发来说，全栈开发的沟通成本更低，开发人员能更容易理解整个功能模块，从而更好的还原产品的设计。尤其现在出现的以js语言为基础的全栈开发：meteor和MEAN技术，更是使得前后端开发用一种语言直接搞定，再配上Mongodb，数据从浏览器到数据库都无需转义直接使用，还不用写sql，开发成本又大大降低。</p>
<img src="/2016/04/19/front-back-separation/10.jpg" alt="10.jpg" title="">
<p>这次搭建node.js服务器用到的一些插件。<br>鼎鼎大名的express不用多介绍了，轻量级web服务器框架。<br>用handlebars模板引擎也属巧合，因为express4默认就是它，handlebars不愧为“弱逻辑”的模板引擎，主张的是减少模板逻辑，尽量只用变量和分页，基于它的设计理念，我只扩充了两个helper。具体文章：<a href="https://yalishizhude.github.io/2016/01/22/handlebars/">https://yalishizhude.github.io/2016/01/22/handlebars/</a><br>superagent的使用还是因为express4，因为它的测试代码用的是supertest，supertest是基于superagent，所以用了superagent来转发和发起请求。superagent还是太弱了，长连接都无法建立，还是推荐request插件。<br>restfuleAPI就没什么好介绍了，前端服务器与浏览器，前端服务器与后端服务器都是用的这一套规范，基本上就是url指向资源，增删改查又具体的请求方法表示，状态码表示结果等~<br>gulp打包工具，webpack研究了很久，发现每增加一个页面都要修改配置文件，这个太蛋疼，遂放弃。</p>
<h1 id="开发流程">开发流程</h1><img src="/2016/04/19/front-back-separation/12.jpg" alt="12.jpg" title="">
<p>如果这次分享主要是讲怎样将node.js做为前端服务器来实现前后端分离的话那也没什么好讲的，看看淘宝UED的文章就好了。<strong>前后端分离其实最大的问题是带来沟通成本的上升，具体来说就是接口的定义和调试。</strong>在上图的传统开发流程中，接口的定义会放在接口服务器中，然后前后端各自根据接口文档造假数据进行本地调试，之后进行联调。这个环节就是前后端开始撕逼的时候了，这个参数不对，那个返回值不对，总之很浪费时间。接下来看这个问题在我们项目中是怎么解决的~</p>
<img src="/2016/04/19/front-back-separation/13.jpg" alt="13.jpg" title="">
<p>前后端因为接口撕逼的问题一直存在，作为保守主义的我相信迭代开发，所以第一步做的只是增加了一个mock服务器。这个服务器的神奇之处就是根据接口文档自动生成假数据，实现了<strong>接口即API</strong>，前端同学再也不用把数据写死进行测试了。没办法，谁叫我是前端开发，首先想到自己人，嘿嘿~当然这个只在一定程度上有利于前端开发，后端的接口和文档不一致联调时也会出现问题。怎么办？</p>
<img src="/2016/04/19/front-back-separation/14.jpg" alt="14.jpg" title="">
<p>偶然在破浪大神的博客上看到老马的一篇专门讲前后端分离的文章，其中一个重要的概念就是契约测试也叫双边测试吧。核心概念就是为了解决远程联调的问题。对前后端的参数都进行校验，要求大家按照接口文档进行开发。受其启发，加入json-schema规则，实现了对http请求的参数校验，谁不按规矩来谁改。</p>
<img src="/2016/04/19/front-back-separation/15.jpg" alt="15.jpg" title="">
<p>这个redmine是我们最早的接口文档管理器，除了记录和查看功能再无其他作用。</p>
<img src="/2016/04/19/front-back-separation/16.jpg" alt="16.jpg" title="">
<p>swagger号称世界最流行的接口文档服务器，界面美观，插件也还比较多，可以针对后端语言直接生成测试代码。不过部署的时候始终没玩懂，而且yaml格式不如json习惯，放弃了它。</p>
<img src="/2016/04/19/front-back-separation/17.jpg" alt="17.jpg" title="">
<p>这就是现在我们项目上用的文档服务器和mock服务器，基于MEAN技术实现的服务器，基本功能：</p>
<ul>
<li>利用mockjs插件，可以动态生成随机数据</li>
<li>基于json-schema对接口参数实行校验和接口测试，并保存测试状态和接口响应时间。</li>
<li>简单的json编辑器</li>
<li>带有登陆校验功能，可登陆后进行接口调试</li>
<li>mock服务器按照api服务器来响应请求，接口更新时自动更新</li>
</ul>
<h1 id="一些问题">一些问题</h1><img src="/2016/04/19/front-back-separation/19.jpg" alt="19.jpg" title="">
<p>node.js是前端工程师的翅膀，而插上翅膀是变成天使还是变成恶魔？这个要看能不能解决的使用它时带来的问题了。</p>
<ul>
<li>首先前端的工作量毫无疑问地会增加，但沟通成本会降低。</li>
<li>node.js单线程的服务器稳定性确实不够好，不过代码的健壮性和完善的日志可以有效的规避。</li>
<li>回调。这个问题解决方法就太多了，node.js的q/async模块以及ES6/ES7。</li>
<li>node.js调试。虽然我一直排斥IDE，但不得不承认webstorm在调试上确实很方便。我用的node-inspector也还凑合，界面类似chrome开发者工具，看上去挺熟悉的。</li>
</ul>
<img src="/2016/04/19/front-back-separation/20.jpg" alt="20.jpg" title="">
<p>如果对于后端程序员，更加应该拥簇node.js了。接口整合的工作交给了前端服务器进行处理，同时和前端耦合度大大降低，工作量和工作效率都减少了。</p>
<img src="/2016/04/19/front-back-separation/21.jpg" alt="21.jpg" title="">
<p>心得体会有两点</p>
<ul>
<li>node.js的使用虽然有一定的学习成本，但对于前端开发人员还是很友好的。而且前端使用node.js的话，无论是技术含量还是工作量都会有所提升，从而提升了岗位的重要性。当前端开发人员能创造更多价值的时候才有资格要求更高的薪水~</li>
<li>工作中建议少提建议多给可行性方案，同时进行技术预研而不是写个简单的helloworld。</li>
</ul>
<h1 id="总结">总结</h1><p><strong>可能有人说你介绍的这一套东西这么复杂，用起来太麻烦了，还不如面对面沟通。</strong><br>对于这样的质疑我只能用腾讯高级UI工程师余果在《web全栈工程师的自我修养》中讲到的一个例子。有一次他电面一家小公司的前端负责人问他怎么管理代码时，对方说直接用ftp上传，同时抱怨手下人老是更新错代码，又问他为什么不用svn或git，他说还不如手动更新方便。<br>这个故事的道理就是我面对质疑的回答~</p>
<p><a href="https://github.com/yalishizhude/front-back-separation.git" target="_blank" rel="external">ppt下载地址</a></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2016/04/19/front-back-separation/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[一起来啃犀牛书：你懂LOL，也可以懂函数]]></title>
      <link>http://yalishizhude.github.io/2016/04/11/rhinoceros-function/</link>
      <guid>http://yalishizhude.github.io/2016/04/11/rhinoceros-function/</guid>
      <pubDate>Sun, 10 Apr 2016 17:53:36 GMT</pubDate>
      <description>
      <![CDATA[<blockquote>
<p>《javascript权威指南》这本书就像是js界的圣经，对于大神和新手都应该是必读书。但是这本近千页的书已经厚到让人望而生畏，要通读它不仅要时间也需要毅力。为了提升自己在js语言上的深度，所以抱着工匠精神开始研读，此文包含书中实用性较强的一些知识点和代码，算做读书笔记吧~</p>
</blockquote>
<img src="/2016/04/11/rhinoceros-function/fun.png" alt="fun.png" title="">]]>
      
      </description>
      <content:encoded><![CDATA[<blockquote>
<p>《javascript权威指南》这本书就像是js界的圣经，对于大神和新手都应该是必读书。但是这本近千页的书已经厚到让人望而生畏，要通读它不仅要时间也需要毅力。为了提升自己在js语言上的深度，所以抱着工匠精神开始研读，此文包含书中实用性较强的一些知识点和代码，算做读书笔记吧~</p>
</blockquote>
<img src="/2016/04/11/rhinoceros-function/fun.png" alt="fun.png" title="">
<a id="more"></a>
<h1 id="英雄请留步">英雄请留步</h1><p>其实我不会打LOL（作者是不是要标题党了？囧~）,不过我打过DOTA和DOTA2啊~游戏大同小异。今天索性把js中的函数当成游戏中的英雄来学习，说不定更容易理解~好吧，那就让我们先来了解一下这个叫“函数”的英雄。</p>
<h1 id="技能介绍">技能介绍</h1><p>先说说普通攻击，也就是函数最常见的调用方式，声明之后直接调用。不过要注意的是 <strong>非严格模式this指向window，严格模式为undefined</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function <span class="function"><span class="title">fun</span><span class="params">()</span>&#123;<span class="comment">//...&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">()</span>;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>增益技能——方法。<code>obj.fun = function(){//技能效果...}</code>，瞬间给<code>obj</code>加了一个<code>fun</code>的buff。不过这里已经将<code>this</code>改为了<code>obj</code>，同时这个buff可以叠加，叠加的方式很简单：函数执行后返回<code>this</code>实现链式调用。</li>
<li><p>召唤技能——构造函数。这个技能就牛X了，召唤很多个小弟，小弟还带有英雄的技能。召唤方法也很简单</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Fun();</span><br><span class="line"><span class="comment">//或 var f = new Fun;</span></span><br><span class="line"><span class="comment">//this 将指向f</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>位移技能——apply()/call()。将英雄瞬间移动到其他位置。也就是改变作用域，让一些不具备该属性的对象也能调用该方法。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  id:<span class="number">1</span>,</span><br><span class="line">  show: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> zdl = &#123;</span><br><span class="line">  id:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.show.call(zdl);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>终极技能——函数式编程。首先这个技能是可以叠加的，伤害值无上限。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现勾股定理</span></span><br><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span><span class="params">(x)</span></span>&#123;<span class="keyword">return</span> x*x;&#125;;</span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span><span class="params">(x,y)</span></span>&#123;<span class="keyword">return</span> x+y;&#125;;</span><br><span class="line"><span class="comment">//将函数作为参数传入</span></span><br><span class="line"><span class="keyword">var</span> pyth = add(square(<span class="number">3</span>),square(<span class="number">4</span>));<span class="comment">//25</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>还可以从不同的方向施放。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从右到左绑定参数，与bind正好相反</span></span><br><span class="line">function partialRight(<span class="function"><span class="keyword">fun</span>)&#123;</span></span><br><span class="line">  <span class="variable"><span class="keyword">var</span> args</span> = arguments;</span><br><span class="line">  <span class="keyword">return</span> function()&#123;</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> a</span> = array(arguments);</span><br><span class="line">    a = a.concat(arguments);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">fun</span>.<span class="title">apply</span><span class="params">(this,a)</span>;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对目标单位造成冰冻效果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个记忆函数，可以缓存函数的执行结果，对于递归函数比较好用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> functin()&#123;</span><br><span class="line">    <span class="comment">//根据参数和参数长度来缓存。</span></span><br><span class="line">    <span class="comment">//为什么不直接用参数缓存？答案很简单，参数有可能为空~</span></span><br><span class="line">    <span class="keyword">var</span> key = <span class="built_in">arguments</span>.length + <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">","</span>);</span><br><span class="line">    <span class="keyword">if</span> (key <span class="keyword">in</span> cache) <span class="keyword">return</span> cache[key];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> cache[key] = f.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="英雄天赋">英雄天赋</h1><ul>
<li><p>显示隐形单位——length。显示函数形参个数</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">zdl</span><span class="params">(a,b)</span>&#123;&#125;;</span></span><br><span class="line"><span class="transposed_variable">zdl.</span><span class="built_in">length</span>;<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>增加三维——prototype。有了这个天赋，新创建的对象将会继承这个属性。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">Fun.prototype.id = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Fun();</span><br><span class="line">f.id;<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分身——bind()。创建一个带有装备的分身。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加法函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(x,y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自增函数</span></span><br><span class="line"><span class="keyword">var</span> inc = add.bind(<span class="keyword">this</span>, <span class="number">1</span>);</span><br><span class="line">inc(<span class="number">2</span>);<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>镜像——Function()，伪函数。为什么叫它们为镜像呢？因为它们和真正的函数有区别。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Function的区别</span><br><span class="line">* 每次执行都将创建新的函数对象，在循环中使用会出现性能问题</span><br><span class="line">* 不使用词法作用域，没有闭包特性，作用域为全局对象</span><br><span class="line">*/</span></span><br><span class="line"><span class="comment">//用于动态创建函数</span></span><br><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">Function</span><span class="params">(<span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"return x+y;"</span>)</span></span>;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span><span class="params">(x,y)</span></span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">eval</span>(<span class="string">"function(x,y)&#123;return x+y;&#125;"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 伪函数的区别</span><br><span class="line">* 能被调用但不属于函数，如IE8这些浏览器不属于函数，如：</span><br><span class="line">* window.alert()</span><br><span class="line">* RegExp()</span><br><span class="line">* 判断真伪函数的方法如下</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(x) === <span class="string">'[object Function]'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="团队定位">团队定位</h1><ul>
<li><p>肉——命名空间。当用作命名空间的时候就相当于是肉，抗住所有伤害</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">function</span><span class="list">()</span><span class="collection">&#123;</span><br><span class="line">  //...  </span><br><span class="line">&#125;</span><span class="list">()</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ganker——闭包。ganker最喜欢的是什么？钻树林钻草丛。闭包也喜欢隐蔽，自带隐身技能，可以把变量隐藏起来私有化。闭包是指函数对象可以通过作用域链互相关联起来，函数体内部的变量都可以保存在函数作用域内。其原理就是当嵌套函数存储在对象或属性时，由于有外部引用指向它，所以不会被垃圾回收。</p>
</li>
<li>DPS——嵌套。如<code>fun1(fun2())</code>。值得注意的是函数和其它对象一样可以添加属性.<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uniqueInteger.counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueInteger</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> uniqueInteger.counter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="推荐装备">推荐装备</h1><ul>
<li><p>第一件装备叫形参。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function <span class="function"><span class="title">fun</span><span class="params">(a,b,c)</span>&#123;</span></span><br><span class="line">  <span class="comment">//a,b,c都是形参，c未传入为undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(1,2)</span>;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>第二件是实参。arguments对象，伪数组，指向实参列表，通常用<code>Array.prototype.slice(arguments)</code>让其具有数组属性和方法。</p>
</li>
</ul>
<p>两件装备？坑爹么？！淡定，这些只是出门装~</p>
<h1 id="进阶攻略">进阶攻略</h1><p>可能有也可能没有，等我看完下一章“类与模块”再做定夺。</p>
<h1 id="打怪升级">打怪升级</h1><ul>
<li>写出函数执行结果</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">'global scope'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">'local scope'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">'global scope'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">'local scope'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">zdl</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> funcs = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    funcs[i]  = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> funcs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> funcs = zdl();</span><br><span class="line">funcs[<span class="number">5</span>]();</span><br></pre></td></tr></table></figure>
<ul>
<li>利用闭包实现私有属性存取的方法</li>
</ul>
<p>答案及百度脑图下载地址：<a href="http://yalishizhude.github.io/subscribe/">http://yalishizhude.github.io/subscribe/</a></p>
<h1 id="彩蛋">彩蛋</h1><h2 id="活动宣传（这个是免费的，当然想交费也可以）">活动宣传（这个是免费的，当然想交费也可以）</h2><p>由w3ctech组织发起的前端技术分享会将于4月16日在长沙卡瑞尔大厦1806举行，到时候我将抛砖引玉扒一扒关于用node.js实现前后端分离的那些事，同时还有移动端混合应用专家和某知名传媒公司技术大牛分享移动端开发的经验。欢迎有时间有兴趣的同学报名参加~<br><img src="/2016/04/11/rhinoceros-function/w3c.jpg" alt="w3c.jpg" title=""></p>
<h2 id="玩个游戏（这个是收费的，当然不想交费也可以）">玩个游戏（这个是收费的，当然不想交费也可以）</h2><h3 id="游戏介绍">游戏介绍</h3><p>最近一边忙着申请慕课网讲师，一边准备长沙地区的前端技术分享会，又一边看犀牛书做总结，时间精力不够用但又想写一些干货分享给大家。为了满足自己的愿望，决定玩一个游戏。</p>
<h3 id="游戏规则">游戏规则</h3><p>下面有两篇文章的选题，同时有对应投票的链接（说白了就是一个微信付款方式，第一个是1元，第二个是2元）。一周后统计投票人数，支持人数多的文章在两周后发表。</p>
<h3 id="游戏目的">游戏目的</h3><ol>
<li>了解大家究竟喜欢阅读哪方面的内容，做个调查，用钱投票应该算是最真实的反应吧。</li>
<li>督促自己，怕自己拖延症发作~因为如果付了钱文章又没写，信誉没了，还会被人指责骗子，担心自律不够的时候靠“他律”~哈哈~</li>
</ol>
<h3 id="游戏内容">游戏内容</h3><ol>
<li>一篇读书分享。最近朋友给我分享了一本很有意义的书，这本书网上也可以看到，关于人生观的，很有启发。内容比较杂，其中有一点提到用软件开发的思维来看待个人价值，让生为开发者都没想到的我十分惊叹和羞愧。人生本来是无意义的，而你自己却可以让其变得有意义。所以这篇读书分享写给那些想让自己人生变得有意义的、追求自我成长的读者。</li>
<li>讲一段关于我的故事。工作的第5个年头接近尾声了，环境上从几千号人的大企业到几十号人的小公司，知识上从一无所知到写文章录视频分享经验，过程中有积累经验和教训，也有对世事的感慨和唏嘘。所以这篇文章就是关于我个人成长经历、工作心得的一些分享（包括工作方面但可能不限于工作）。</li>
</ol>
<h3 id="投票链接">投票链接</h3><img src="/2016/04/11/rhinoceros-function/vote1.jpg" alt="vote1.jpg" title="">
<img src="/2016/04/11/rhinoceros-function/vote2.jpg" alt="vote2.jpg" title="">
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2016/04/11/rhinoceros-function/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[一起来啃犀牛书：正则表达式]]></title>
      <link>http://yalishizhude.github.io/2016/03/31/rhinoceros-reg/</link>
      <guid>http://yalishizhude.github.io/2016/03/31/rhinoceros-reg/</guid>
      <pubDate>Wed, 30 Mar 2016 16:02:46 GMT</pubDate>
      <description>
      <![CDATA[<blockquote>
<p>《javascript权威指南》这本书就像是js界的圣经，对于大神和新手都应该是必读书。但是这本近千页的书已经厚到让人望而生畏，要通读它不仅要时间也需要毅力。为了提升自己在js语言上的深度，所以抱着工匠精神开始研读，此文包含书中实用性较强的一些知识点和代码，算做读书笔记吧~</p>
</blockquote>
<img src="/2016/03/31/rhinoceros-reg/reg.png" alt="reg.png" title="">]]>
      
      </description>
      <content:encoded><![CDATA[<blockquote>
<p>《javascript权威指南》这本书就像是js界的圣经，对于大神和新手都应该是必读书。但是这本近千页的书已经厚到让人望而生畏，要通读它不仅要时间也需要毅力。为了提升自己在js语言上的深度，所以抱着工匠精神开始研读，此文包含书中实用性较强的一些知识点和代码，算做读书笔记吧~</p>
</blockquote>
<img src="/2016/03/31/rhinoceros-reg/reg.png" alt="reg.png" title="">
<a id="more"></a>
<p>正则表达式这一章一直是我最困惑的，因为每次看完都会忘。。。所以这次我首先对知识点进行了梳理，然后配上习题练习，以此巩固。<br>从js正则表达式示意图可以看出，正则表达式分两块，一是声明定义二是函数调用。声明定义又可以分3块一是直接字符和字符类，然后是对字符（类）的描述，如重复、分组等，最后是修饰符，如大小写、全局匹配等。函数调用分为字符串用到正则表达式的函数和RegExp对象的原型函数。</p>
<h1 id="正则表达式定义">正则表达式定义</h1><p>js中可以使用构造函数来创建也可以使用斜杠。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/s$/</span>;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'s$'</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>但是注意，在ES5规范中正则表达式和字符串常量不一样，每次声明都会重新创建变量，所以<code>/s$/!==new RegExp(&#39;s$&#39;)</code>。</strong></p>
<h2 id="转义字符">转义字符</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">\0</span>    NUL字符（<span class="string">\u0000）</span></span><br><span class="line"><span class="string">\t</span>    制表符（<span class="string">\0009）</span></span><br><span class="line"><span class="string">\n</span>    换行符（<span class="string">\000A）</span></span><br><span class="line"><span class="string">\v</span>    垂直制表符（<span class="string">\u000B）</span></span><br><span class="line"><span class="string">\f</span>    换页符（<span class="string">\000C）</span></span><br><span class="line"><span class="string">\r</span>    回车符（<span class="string">\000D）</span></span><br><span class="line"><span class="string">\xnn</span>  十六进制拉丁字符</span><br><span class="line"><span class="string">\uxxxx十六进制unicode字符</span></span><br><span class="line"><span class="string">\cX</span>	  控制字符</span><br></pre></td></tr></table></figure>
<p>这些转义字符中比较常用的就是换行符了，其他记不住可以上网查。还有一些字符具有特殊含义，如果需要匹配这些字符的时候需要在前面加上反斜杠进行转义。<br><code>^ $ . * + | \ / ( ) [ ] { }</code><br>其中”/“只在”/\//“这种方式声明的时候需要转义，而在”new RegExp(‘/‘)”时不需要</p>
<h2 id="字符类">字符类</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[...]</span>   方括号内任意字符</span><br><span class="line"><span class="attr_selector">[^...]</span>  不在方括号内任意字符</span><br><span class="line">.       除换行符和其他<span class="tag">unicode</span>行终止符之外的任意字符</span><br><span class="line">\<span class="tag">w</span>      等价于<span class="attr_selector">[a-zA-Z0-9]</span></span><br><span class="line">\<span class="tag">W</span>      等价于<span class="attr_selector">[^a-zA-Z0-9]</span></span><br><span class="line">\<span class="tag">s</span>      任何<span class="tag">unicode</span>空白符</span><br><span class="line">\<span class="tag">S</span>      任何非<span class="tag">unicode</span>空白符</span><br><span class="line">\<span class="tag">d</span>      等价于<span class="attr_selector">[0-9]</span></span><br><span class="line">\<span class="tag">D</span>      等价于<span class="attr_selector">[^0-9]</span></span><br><span class="line"><span class="attr_selector">[\b]</span>    退格</span><br></pre></td></tr></table></figure>
<p>这个字符类很重要，需要记忆。</p>
<h2 id="描述方式：重复">描述方式：重复</h2><h3 id="知识点">知识点</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="keyword">n</span>,<span class="keyword">m</span>&#125;   匹配前一项至少<span class="keyword">n</span>次，不超过<span class="keyword">m</span>次</span><br><span class="line">&#123;<span class="keyword">n</span>,&#125;    匹配前一项至少<span class="keyword">n</span>次</span><br><span class="line">&#123;<span class="keyword">n</span>&#125;     匹配前一项<span class="keyword">n</span>次</span><br><span class="line">?       等价于&#123;0,1&#125;</span><br><span class="line">+       等价于&#123;1,&#125;</span><br><span class="line"><span class="comment">*       等价于&#123;0,&#125;</span></span><br><span class="line">x?      描述符后跟随一个<span class="string">"?"</span>表示非贪婪匹配：从字符串中第一个可能匹配的位置，尽量少的匹配。如“??”、“&#123;1,5&#125;?”等。</span><br></pre></td></tr></table></figure>
<h3 id="习题">习题</h3><ul>
<li><p>匹配2~4个数字</p>
</li>
<li><p>精确匹配3个单词和一个可选数字</p>
</li>
<li><p>匹配前后带有一个或多个空格的字符串”java”</p>
</li>
<li><p>匹配一个或多个非左括号的字符</p>
</li>
</ul>
<h2 id="描述方式：选择、分组和引用">描述方式：选择、分组和引用</h2><p>“|”与逻辑表达式中的或类似，前后两者任意一个匹配，很好理解。而圆括号用来分组和引用，功能就比较复杂了。</p>
<ul>
<li>把单独的项组合成子表达式，以便重复、选择等操作。</li>
<li>完整的模式中定义子模式，从而在匹配成功后从目标串中抽出和圆括号中的子模式匹配的部分。</li>
<li>同一个正则表达式中后部引用前部的正则表达式，注意因为子表达式可以嵌套，所以它的位置是参与计数的左括号的位置。如果不创建带数字编码的引用，可以用”(?:”和”)”表示。</li>
</ul>
<p>举个简单的例子，如果要匹配单引号或双引号中的字符，可能会写成下面这样：<br><code>/[&#39;&quot;][^&#39;&quot;]*[&#39;&quot;]/</code><br>但是如果我们是想成对的匹配’abc’而不是匹配’abc”的话需要这么改写：<br><code>/([&#39;&quot;])[^&#39;&quot;]*\1/</code></p>
<h3 id="习题-1">习题</h3><p>匹配浮点数</p>
<h2 id="锚">锚</h2><p>指定匹配位置的元素称为锚。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">^     匹配字符串开头，多行匹配一行的开头</span><br><span class="line"><span class="formula">$     匹配字符串结尾，多行匹配一行的结尾</span><br><span class="line"><span class="command">\b</span>    匹配一个单词的边界，位于<span class="command">\w</span>和<span class="command">\W</span>之间的位置</span><br><span class="line"><span class="command">\B</span>    匹配非单词边界</span><br><span class="line">(?=p) 要求接下来的字符都与p匹配，但不能包括匹配p的那些字符</span><br><span class="line">(?!p) 要求接下来的字符不与p匹配</span></span><br></pre></td></tr></table></figure>
<p>这个”^”似曾相识？嗯，它在”[]”内的时候表示逻辑非，而在其它地方就成了锚字符了。<br>“\b”在”[]”中表示退格符，其它地方单词边界。怎么理解呢？比如我们想匹配”java”这个单词，那么我们如果只写/java/肯定是不行的，因为会匹配上javascript这类单词。那么加上空格符/\sjava\s/匹配呢？这样做也是有问题的，一个是多行情况下行首尾没有空格就匹配不了，二是实际上我们想得到的匹配字符串是”java”而不是带空格的” java “。所以这个时候就需要单词边界来表示/\bjava\b/。而\B正好相反。<br>而之后的断言不知道有什么妙用，看起来<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(?=p)</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">p</span><br><span class="line"></span><br><span class="line"><span class="comment">(?!p)</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">[^p]</span><br></pre></td></tr></table></figure></p>
<h2 id="修饰符">修饰符</h2><ul>
<li>i。忽略大小写</li>
<li>m。多行匹配模式</li>
<li>g。全局匹配</li>
</ul>
<h1 id="字符串中的模式匹配">字符串中的模式匹配</h1><h2 id="search">search</h2><p>查找匹配的字符串，不支持全局匹配，返回第一个子串的起始位置。</p>
<p><code>&quot;JavaScript&quot;.search(/script/i) //4</code></p>
<h2 id="match">match</h2><p>返回由匹配结果组成的数组，默认返回第一个匹配的字符串，如果全局匹配则返回所有匹配字符串。当使用括号分组的时候第一个元素为匹配的字符串，其后为圆括号中各个匹配的子字符串。</p>
<p><code>&quot;1 add 2 add 3&quot;.match(/\d/) //[&quot;1&quot;]</code><br><code>&quot;1 add 2 add 3&quot;.match(/\d/g) //[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</code><br><code>&quot;https://yalishizhude.github.io/index.html&quot;.match(/(\w+)\:\/\/([\w.]+)\/(\S*)/); //[&quot;https://yalishizhude.github.io/index.html&quot;, &quot;https&quot;, &quot;yalishizhude.github.io&quot;, &quot;index.html&quot;]</code></p>
<h2 id="split">split</h2><p>这是将字符串转化为数组的方法。一般用字符串做分隔符匹配，如果使用正则表达式，则在匹配字符串的前后方断开。同时注意以下几点：</p>
<ul>
<li>匹配到开头内容，返回数组第一个元素为空字符串。</li>
<li>匹配到结尾内容，返回数组最后一个元素为空字符串。</li>
<li>未匹配，返回数组只包含未切分的字符串。</li>
</ul>
<h2 id="replace">replace</h2><ul>
<li>$n 匹配第n个匹配正则表达式中的圆括号子表达式文本</li>
<li>$&amp; 匹配正则表达式的子串</li>
<li>$` 匹配子串左边的文本</li>
<li>$’ 匹配子串右边的文本</li>
<li>$$ 匹配美元符号</li>
</ul>
<p><code>&quot;z d l&quot;.replace(/(\w)\s(\w)\s(\w)/, &#39;$3 $2 $1&#39;) // &quot;l d z&quot;</code></p>
<h3 id="习题-2">习题</h3><p>中文双引号替换英文双引号</p>
<h1 id="RegExp对象">RegExp对象</h1><h2 id="属性">属性</h2><ul>
<li>source 正则表达式文本</li>
<li>global 只读布尔值，是否有修饰符g</li>
<li>ignoreCase 只读布尔值，是否有修饰符i</li>
<li>multiline 只读布尔值，是否有修饰符m</li>
<li>lastIndex 下一次检索开始的位置，用于exec()和test()<h2 id="方法">方法</h2><h3 id="exec()">exec()</h3>类似String.match，不过不能使用全局匹配。匹配同时修改lastIndex值为紧挨着匹配子串的字符位置，如果未匹配则为0。<h3 id="test()">test()</h3>返回布尔值，可以修改lastIndex从指定位置开始匹配。</li>
</ul>
<h1 id="总结">总结</h1><p>正则表达式学习起来就4个字：死去活来~原理并不复杂，概念理解清楚了，基础知识记清楚了，一般的表达式应该都能写了~</p>
<p>习题答案和百度脑图下载地址：<a href="http://yalishizhude.github.io/subscribe/">http://yalishizhude.github.io/subscribe/</a></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2016/03/31/rhinoceros-reg/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[一起来啃犀牛书：BOM]]></title>
      <link>http://yalishizhude.github.io/2016/03/21/rhinoceros-bom/</link>
      <guid>http://yalishizhude.github.io/2016/03/21/rhinoceros-bom/</guid>
      <pubDate>Mon, 21 Mar 2016 15:38:40 GMT</pubDate>
      <description>
      <![CDATA[<blockquote>
<p>《javascript权威指南》这本书就像是js界的圣经，对于大神和新手都应该是必读书。但是这本近千页的书已经厚到让人望而生畏，要通读它不仅要时间也需要毅力。为了提升自己在js语言上的深度，所以抱着工匠精神开始研读，此文包含书中实用性较强的一些知识点和代码，算做读书笔记吧~</p>
</blockquote>
<img src="/2016/03/21/rhinoceros-bom/bom.png" alt="bom.png" title="">
<p>BOM全称为Browser Object Model浏览器对象模型，也就是浏览器端的window对象及其默认属性和函数。</p>]]>
      
      </description>
      <content:encoded><![CDATA[<blockquote>
<p>《javascript权威指南》这本书就像是js界的圣经，对于大神和新手都应该是必读书。但是这本近千页的书已经厚到让人望而生畏，要通读它不仅要时间也需要毅力。为了提升自己在js语言上的深度，所以抱着工匠精神开始研读，此文包含书中实用性较强的一些知识点和代码，算做读书笔记吧~</p>
</blockquote>
<img src="/2016/03/21/rhinoceros-bom/bom.png" alt="bom.png" title="">
<p>BOM全称为Browser Object Model浏览器对象模型，也就是浏览器端的window对象及其默认属性和函数。</p>
<a id="more"></a>
<h1 id="计时器">计时器</h1><h2 id="知识点">知识点</h2><p>也就4个函数</p>
<ul>
<li>setInterval</li>
<li>clearInterval</li>
<li>setTimeout</li>
<li>clearTimeout<br>这里要注意的是setInterval/setTimeout第一个参数可为函数或字符串，传入字符串时相当于调用eval来执行。同时调用指定函数时都是可以传入参数的。而setTimeout第二个参数如果传入0，那么传入的函数不会立即执行，而是等到前面处于等待状态的时间处理程序全部执行完成后。</li>
</ul>
<h2 id="例题">例题</h2><p>定义一个定时器函数invoke，可定时执行或延迟执行指定函数。</p>
<h2 id="代码">代码</h2><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invoke</span><span class="params">(f, start, interval, end)</span> &#123;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="params">(!start)</span> start = <span class="number">0</span>;          </span><br><span class="line">    <span class="keyword">if</span> <span class="params">(arguments.length &lt;= <span class="number">2</span>)</span>      <span class="comment">// 延迟执行</span></span><br><span class="line">        setTimeout<span class="params">(f, start)</span>;       </span><br><span class="line">    <span class="keyword">else</span> &#123;                          <span class="comment">// 延迟一段时间后重复执行</span></span><br><span class="line">        setTimeout<span class="params">(repeat, start)</span>;  </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">repeat</span><span class="params">()</span> &#123;</span>         </span><br><span class="line">            var h = setInterval<span class="params">(f, interval)</span>;</span><br><span class="line">            <span class="comment">// 在end毫秒时停止重复</span></span><br><span class="line">            <span class="keyword">if</span> <span class="params">(end)</span> setTimeout<span class="params">(function<span class="params">()</span> &#123; clearInterval<span class="params">(h)</span>; &#125;, end)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="浏览器定位和导航">浏览器定位和导航</h1><h2 id="知识点-1">知识点</h2><ul>
<li>hash属性。一般用来滚动到定位元素，移动端多用于SAP，通过它在浏览器端实现路由逻辑的加载。</li>
<li>search属性。URL中的参数，常用于跨页面传参和向服务端传参。</li>
<li>跳转属性/函数。<code>location.href = url;</code>相当于<code>location.assign(url);</code>这两种方法跳转都会留下历史纪录，而<code>location.replace(url)</code>则不会。</li>
</ul>
<h2 id="例题-1">例题</h2><p>提取URL的搜索字符串中的参数。</p>
<h2 id="代码-1">代码</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function urlArgs() &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">args</span> = &#123;&#125;;                             </span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">query</span> = location.<span class="keyword">search</span>.substring(1);  <span class="comment">// 过滤掉'?'</span></span><br><span class="line">    <span class="keyword">var</span> pairs = <span class="keyword">query</span>.<span class="keyword">split</span>(<span class="string">"&amp;"</span>);              </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = 0; i &lt; pairs.length; i++) &#123;    </span><br><span class="line">        <span class="keyword">var</span> pos = pairs[i].indexOf('=');       </span><br><span class="line">        <span class="keyword">if</span> (pos == -1) <span class="keyword">continue</span>;               </span><br><span class="line">        <span class="keyword">var</span> name = pairs[i].substring(0,pos);  </span><br><span class="line">        <span class="keyword">var</span> value = pairs[i].substring(pos+1);</span><br><span class="line">        value = decodeURIComponent(value);     </span><br><span class="line">        <span class="keyword">args</span>[name] = value;                    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">args</span>;                              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数很常用~</p>
<h1 id="history">history</h1><h2 id="知识点-2">知识点</h2><p>主要掌握3个函数：</p>
<ul>
<li>back。相当于浏览器后退按钮</li>
<li>forward。相当于浏览器前进按钮</li>
<li>go。正数参数n：相当于浏览器前进按钮点击n次。负整数参数n：想当于浏览器后退按钮点击n次。</li>
</ul>
<h1 id="浏览器信息">浏览器信息</h1><h2 id="知识点-3">知识点</h2><p>navigator属性用来获取浏览器信息，重要的属性有4个：</p>
<ul>
<li>appName。IE:”Microsoft Internet Explorer”，其它：”Netscape”</li>
<li>appVersion。浏览器厂商和详细信息。</li>
<li>platform。操作系统信息。</li>
<li>userAgent。包含appVersion所有信息和其他细节信息，格式不定，比较常用。适用于解决特定浏览器下的bug。</li>
</ul>
<h2 id="例题-2">例题</h2><p>使用userAgent来识别浏览器。</p>
<h2 id="代码-2">代码</h2><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//"webkit": Safari或Chrome版本号</span></span><br><span class="line"><span class="comment">//"opera": 版本号就是软件的版本号</span></span><br><span class="line"><span class="comment">//"mozilla"： 版本号是Gecko</span></span><br><span class="line"><span class="comment">//"msie" 版本号就是软件版本</span></span><br><span class="line">var browser = <span class="params">(function<span class="params">()</span> &#123;</span><br><span class="line">     var s = navigator.userAgent.toLowerCase<span class="params">()</span>;</span><br><span class="line">     var match = /<span class="params">(webkit)</span>[ \/]<span class="params">([\w.]+)</span>/.exec<span class="params">(s)</span> ||</span><br><span class="line">	 /<span class="params">(opera)</span><span class="params">(?:.*version)</span>?[ \/]<span class="params">([\w.]+)</span>/.exec<span class="params">(s)</span> ||</span><br><span class="line">	 /<span class="params">(msie)</span> <span class="params">([\w.]+)</span>/.exec<span class="params">(s)</span> ||</span><br><span class="line">	 !/compatible/.test<span class="params">(s)</span> &amp;&amp; /<span class="params">(mozilla)</span><span class="params">(?:.*? rv:<span class="params">([\w.]+)</span>)</span>?/.exec<span class="params">(s)</span> ||</span><br><span class="line">	 [];</span><br><span class="line">     return &#123; name: match[<span class="number">1</span>] || <span class="string">""</span>, version: match[<span class="number">2</span>] || <span class="string">"0"</span> &#125;;</span><br><span class="line">&#125;<span class="params">()</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>这里用了jquery1.4的代码。</p>
<h1 id="对话框">对话框</h1><h2 id="知识点-4">知识点</h2><ul>
<li>confirm/prompt/alert。会产生阻塞的原生弹出框。</li>
<li>showModalDialog。包含HTML格式的模态对话框。</li>
</ul>
<p>在正式生产环境中不建议使用以上对话框，还是自定义吧~</p>
<h1 id="错误处理">错误处理</h1><h2 id="知识点-5">知识点</h2><p><code>window.onerror = function(msg, url, line)</code></p>
<p>msg:错误描述。<br>url:报错的js的url。<br>line:发生错误的行数。</p>
<p>firefox中必须返回true值。</p>
<p>这个函数用来收集异常信息，然后回传服务器记录日志，供前端开发者调试修复bug还是很不错的~</p>
<h1 id="文档元素">文档元素</h1><h2 id="知识点-6">知识点</h2><p><code>document.getElementById(&quot;you&quot;);</code><br>相当于<br><code>window.you</code><br>注意如果和已有对象冲突则以默认对象为主，这是遗留方式，不推荐。应该算一个冷知识吧。</p>
<h1 id="窗体和窗口">窗体和窗口</h1><h2 id="知识点-7">知识点</h2><p>*open/close。open创建窗口后返回新窗口句柄，而新窗口可通过opener来调用父窗口的对象。需要注意的是：不过大部分浏览器增加了弹出窗口过滤功能，通常只有用户手动点击才会执行（广告商就是利用它来做弹出广告的）。大多数浏览器只允许关闭由自己的js代码创建的窗口。</p>
<ul>
<li>parent/frames。父窗体通过frames属性获取iframe对象，子窗体通过parent获取父对象。</li>
</ul>
<p>百度脑图下载地址：<a href="http://yalishizhude.github.io/subscribe/">http://yalishizhude.github.io/subscribe/</a></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2016/03/21/rhinoceros-bom/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[一起来啃犀牛书：事件处理]]></title>
      <link>http://yalishizhude.github.io/2016/03/14/rhinoceros-event/</link>
      <guid>http://yalishizhude.github.io/2016/03/14/rhinoceros-event/</guid>
      <pubDate>Sun, 13 Mar 2016 18:30:07 GMT</pubDate>
      <description>
      <![CDATA[<blockquote>
<p>《javascript权威指南》这本书就像是js界的圣经，对于大神和新手都应该是必读书。但是这本近千页的书已经厚到让人望而生畏，要通读它不仅要时间也需要毅力。为了提升自己在js语言上的深度，所以抱着工匠精神开始研读，此文包含书中实用性较强的一些知识点和代码，算做读书笔记吧~</p>
</blockquote>
<img src="/2016/03/14/rhinoceros-event/event.png" alt="event.png" title="">]]>
      
      </description>
      <content:encoded><![CDATA[<blockquote>
<p>《javascript权威指南》这本书就像是js界的圣经，对于大神和新手都应该是必读书。但是这本近千页的书已经厚到让人望而生畏，要通读它不仅要时间也需要毅力。为了提升自己在js语言上的深度，所以抱着工匠精神开始研读，此文包含书中实用性较强的一些知识点和代码，算做读书笔记吧~</p>
</blockquote>
<img src="/2016/03/14/rhinoceros-event/event.png" alt="event.png" title="">
<a id="more"></a>
<p>这一章参照的是W3C定义的3级DOM事件，现在更名为<a href="https://www.w3.org/TR/2015/WD-uievents-20150319/" target="_blank" rel="external">UI事件</a>了。</p>
<h1 id="文档加载事件">文档加载事件</h1><h2 id="知识点">知识点</h2><ul>
<li>load。直到文档和所有图片加载完毕时才发生</li>
<li>DOMContentLoaded。当文档加载解析完毕且所有延迟脚本都执行完毕时会出发。优先使用</li>
<li>readystatechange。HTML5标准化的事件，在load事件之前触发。</li>
</ul>
<h2 id="例题">例题</h2><p>定义whenReady函数，类似onLoad函数。当文档就绪时，传递给whenReady的函数就会作为Document对象的方法调用。优先使用DOMContentLoaded和readystatechange事件。</p>
<h2 id="代码">代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> whenReady = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> funcs = [], <span class="comment">//需要运行的函数</span></span><br><span class="line">  ready = <span class="literal">false</span>, <span class="comment">//为避免重复执行</span></span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!ready) &#123;</span><br><span class="line">      <span class="comment">//如果发生readystatechange事件，但状态不是complete则文档未准备好</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="string">'readystatechange'</span>===e.type &amp;&amp; <span class="string">'complete'</span>!==<span class="built_in">document</span>.readyState) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;funcs.length; i++) &#123;</span><br><span class="line">        funcs[i].call(<span class="built_in">document</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      ready = <span class="literal">true</span>;</span><br><span class="line">      funcs = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">document</span>.addEventListener) &#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, handler);</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'readystatechange'</span>, handler);</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, handler);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">document</span>.attachEvent) &#123;</span><br><span class="line">    <span class="built_in">document</span>.attachEvent(<span class="string">'onreadystatechange'</span>, handler);</span><br><span class="line">    <span class="built_in">window</span>.attachEvent(<span class="string">'load'</span>, handler);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ready) f.call(<span class="built_in">document</span>); <span class="comment">//若准备完毕则运行</span></span><br><span class="line">    <span class="keyword">else</span> funcs.push(f);  <span class="comment">//否则加入队列</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<h1 id="鼠标事件">鼠标事件</h1><h2 id="知识点-1">知识点</h2><h3 id="事件属性">事件属性</h3><ul>
<li>clientX和clientY表示鼠标坐标</li>
<li>altKey、metaKey、ctrlKey、shiftKey</li>
<li>HTML5中元素添加draggable属性之后就可以实现dragstart和dragend事件。</li>
</ul>
<h2 id="例题-1">例题</h2><p>定义drag函数实现文档元素拖动操作。</p>
<h2 id="代码-1">代码</h2><p>drag函数绑定到mousedown事件，整个逻辑也是比较简单在mousedown事件开始时记录坐标点，然后在mousemove事件时改变css样式来实现dom元素移动，同时结束时注销事件。不过需要注意的就是dom元素必须是非静态定位。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drag</span><span class="params">()</span>&#123;</span></span><br><span class="line">  <span class="comment">//获取坐标</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getScrollOffsets</span><span class="params">(w)</span> &#123;</span></span><br><span class="line">    var d = &#123;&#125;;</span><br><span class="line">    <span class="comment">//使用指定窗口或者当前窗口</span></span><br><span class="line">    w = w || window;</span><br><span class="line">    <span class="comment">//现代浏览器</span></span><br><span class="line">    <span class="keyword">if</span> <span class="params">(w.pageXOffest != null)</span> &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        x: w.pageXOffest,</span><br><span class="line">        y: w.pageYOffset</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//标准模式下的IE</span></span><br><span class="line">    d = w.document;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(document.compatMode === 'CSS1Compat')</span> &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        x: d.documentElement.scrollLeft,</span><br><span class="line">        y: d.documentElement.scrollTop</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//怪医模式下的浏览器</span></span><br><span class="line">    return &#123;</span><br><span class="line">      x: d.body.scrollLeft,</span><br><span class="line">      y: d.body.scrollTop</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  var scroll = getScrollOffsets<span class="params">()</span>;</span><br><span class="line">	var startX = event.clientX + scroll.x;</span><br><span class="line">	var startY = event.clientY + scroll.y;</span><br><span class="line">	var origX = elementToDrag.offsetLeft;</span><br><span class="line">	var origY = elementToDrag.offsetTop;</span><br><span class="line">	var deltaX = startX - origX;</span><br><span class="line">	var deltaY = startY - origY;</span><br><span class="line">  <span class="comment">//注册鼠标移动和鼠标释放事件</span></span><br><span class="line">	<span class="keyword">if</span> <span class="params">(document.addEventListener)</span> &#123;</span><br><span class="line">		document.addEventListener<span class="params">(<span class="string">"mousemove"</span>, moveHandler, <span class="literal">true</span>)</span>;</span><br><span class="line">		document.addEventListener<span class="params">(<span class="string">"mouseup"</span>, upHandler, <span class="literal">true</span>)</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(document.attachEvent)</span> &#123;</span><br><span class="line">		elementToDrag.setCapture<span class="params">()</span>;</span><br><span class="line">		elementToDrag.attachEvent<span class="params">(<span class="string">"onmousemove"</span>, moveHandler)</span>;</span><br><span class="line">		elementToDrag.attachEvent<span class="params">(<span class="string">"onmouseup"</span>, upHandler)</span>;</span><br><span class="line">		elementToDrag.attachEvent<span class="params">(<span class="string">"onlosecapture"</span>, upHandler)</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="params">(event.stopPropagation)</span> event.stopPropagation<span class="params">()</span>;</span><br><span class="line">	<span class="keyword">else</span> event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> <span class="params">(event.preventDefault)</span> event.preventDefault<span class="params">()</span>;</span><br><span class="line">	<span class="keyword">else</span> event.returnValue = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//移动鼠标时移动元素</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">moveHandler</span><span class="params">(e)</span> &#123;</span></span><br><span class="line">		<span class="keyword">if</span> <span class="params">(!e)</span> e = window.event;</span><br><span class="line">		var scroll = getScrollOffsets<span class="params">()</span>;</span><br><span class="line">		elementToDrag.style.left = <span class="params">(e.clientX + scroll.x - deltaX)</span> + <span class="string">"px"</span>;</span><br><span class="line">		elementToDrag.style.top = <span class="params">(e.clientY + scroll.y - deltaY)</span> + <span class="string">"px"</span>;</span><br><span class="line">		<span class="keyword">if</span> <span class="params">(e.stopPropagation)</span> e.stopPropagation<span class="params">()</span>;</span><br><span class="line">		<span class="keyword">else</span> e.cancelBubble = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//拖拽结束，注销事件</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">upHandler</span><span class="params">(e)</span> &#123;</span></span><br><span class="line">		<span class="keyword">if</span> <span class="params">(!e)</span> e = window.event;</span><br><span class="line">		<span class="keyword">if</span> <span class="params">(document.removeEventListener)</span> &#123;</span><br><span class="line">			document.removeEventListener<span class="params">(<span class="string">"mouseup"</span>, upHandler, <span class="literal">true</span>)</span>;</span><br><span class="line">			document.removeEventListener<span class="params">(<span class="string">"mousemove"</span>, moveHandler, <span class="literal">true</span>)</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(document.detachEvent)</span> &#123;</span><br><span class="line">			elementToDrag.detachEvent<span class="params">(<span class="string">"onlosecapture"</span>, upHandler)</span>;</span><br><span class="line">			elementToDrag.detachEvent<span class="params">(<span class="string">"onmouseup"</span>, upHandler)</span>;</span><br><span class="line">			elementToDrag.detachEvent<span class="params">(<span class="string">"onmousemove"</span>, moveHandler)</span>;</span><br><span class="line">			elementToDrag.releaseCapture<span class="params">()</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="params">(e.stopPropagation)</span> e.stopPropagation<span class="params">()</span>;</span><br><span class="line">		<span class="keyword">else</span> e.cancelBubble = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="文本/键盘事件">文本/键盘事件</h1><h2 id="知识点-2">知识点</h2><ul>
<li>keypress。常用的高级键盘事件。</li>
<li>textinput。时3级DOM事件规范定义的通用事件（来源包括键盘/粘贴/拖放/声音/手写）</li>
<li>textInput。webkit浏览器支持类似textinput的事件。</li>
</ul>
<h2 id="例题1">例题1</h2><p>写一个过滤键盘输入的函数,当用户输入了不允许字符时显示消息元素，否则隐藏它。</p>
<h2 id="代码1">代码1</h2><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">function</span><span class="list">()</span> <span class="collection">&#123;</span><br><span class="line">	var inputelts = document.getElementsByTagName<span class="list">(<span class="string">"input"</span>)</span><span class="comment">;</span></span><br><span class="line">	for <span class="list">(<span class="keyword"><span class="built_in">var</span></span> i = <span class="number">0</span><span class="comment">; i &lt; inputelts.length; i++) &#123;</span></span><br><span class="line">		var elt = inputelts<span class="collection">[i]</span><span class="comment">;</span></span><br><span class="line">		if <span class="list">(<span class="keyword">elt.type</span> != <span class="string">"text"</span> || !elt.getAttribute<span class="list">(<span class="string">"data-allowed-chars"</span>)</span>)</span> continue;</span><br><span class="line">		if <span class="list">(<span class="keyword">elt.addEventListener</span>)</span> <span class="collection">&#123;</span><br><span class="line">			elt.addEventListener<span class="list">(<span class="string">"keypress"</span>, filter, <span class="literal">false</span>)</span><span class="comment">;</span></span><br><span class="line">			elt.addEventListener<span class="list">(<span class="string">"textInput"</span>, filter, <span class="literal">false</span>)</span><span class="comment">;</span></span><br><span class="line">			elt.addEventListener<span class="list">(<span class="string">"textinput"</span>, filter, <span class="literal">false</span>)</span></span><br><span class="line">		&#125;</span> else <span class="collection">&#123;</span><br><span class="line">			elt.attachEvent<span class="list">(<span class="string">"onkeypress"</span>, filter)</span></span><br><span class="line">		&#125;</span></span><br><span class="line">	&#125;</span><br><span class="line">	function filter<span class="list">(<span class="keyword">event</span>)</span> <span class="collection">&#123;</span><br><span class="line">		var e = event || window.event;</span><br><span class="line">		var target = e.target || e.srcElement;</span><br><span class="line">		var text = null;</span><br><span class="line">		if <span class="list">(<span class="keyword">e.type</span> === <span class="string">"textinput"</span> || e.type === <span class="string">"textInput"</span>)</span> text = e.data;</span><br><span class="line">		else <span class="collection">&#123;</span><br><span class="line">			var code = e.charCode || e.keyCode;</span><br><span class="line">			if <span class="list">(<span class="keyword">code</span> &lt; <span class="number">32</span> || e.charCode == <span class="number">0</span> || e.ctrlKey || e.altKey)</span> return;</span><br><span class="line">			var text = String.fromCharCode<span class="list">(<span class="keyword">code</span>)</span></span><br><span class="line">		&#125;</span></span><br><span class="line">		var allowed = target.getAttribute<span class="list">(<span class="string">"data-allowed-chars"</span>)</span><span class="comment">;</span></span><br><span class="line">		var messageid = target.getAttribute<span class="list">(<span class="string">"data-messageid"</span>)</span><span class="comment">;</span></span><br><span class="line">		if <span class="list">(<span class="keyword">messageid</span>)</span> var messageElement = document.getElementById<span class="list">(<span class="keyword">messageid</span>)</span><span class="comment">;</span></span><br><span class="line">		for <span class="list">(<span class="keyword"><span class="built_in">var</span></span> i = <span class="number">0</span><span class="comment">; i &lt; text.length; i++) &#123;</span></span><br><span class="line">			var c = text.charAt<span class="list">(<span class="keyword">i</span>)</span><span class="comment">;</span></span><br><span class="line">			if <span class="list">(<span class="keyword">allowed.indexOf</span><span class="list">(<span class="keyword">c</span>)</span> == <span class="number">-1</span>)</span> <span class="collection">&#123;</span><br><span class="line">				if <span class="list">(<span class="keyword">messageElement</span>)</span> messageElement.style.visibility = <span class="string">"visible"</span><span class="comment">;</span></span><br><span class="line">				if <span class="list">(<span class="keyword">e.preventDefault</span>)</span> e.preventDefault<span class="list">()</span><span class="comment">;</span></span><br><span class="line">				if <span class="list">(<span class="keyword">e.returnValue</span>)</span> e.returnValue = <span class="literal">false</span><span class="comment">;</span></span><br><span class="line">				return <span class="literal">false</span></span><br><span class="line">			&#125;</span></span><br><span class="line">		&#125;</span><br><span class="line">		if <span class="list">(<span class="keyword">messageElement</span>)</span> messageElement.style.visibility = <span class="string">"hidden"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="list">()</span>)</span><span class="comment">;</span></span></span></span></span></span><br></pre></td></tr></table></figure>
<h2 id="例题2">例题2</h2><p>将输入的字符自动转换为大写</p>
<h2 id="代码2">代码2</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">forceToUpperCase</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> element === <span class="string">"string"</span>) element = document.getElementById(element);</span><br><span class="line">	element.oninput = upcase;</span><br><span class="line">	element.onpropertychange = upcaseOnPropertyChange;</span><br><span class="line"></span><br><span class="line">	<span class="function">function <span class="title">upcase</span>(<span class="params"><span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">this</span>.<span class="keyword">value</span>.toUpperCase()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">function <span class="title">upcaseOnPropertyChange</span>(<span class="params"><span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> e = <span class="keyword">event</span> || window.<span class="keyword">event</span>;</span><br><span class="line">		<span class="keyword">if</span> (e.propertyName === <span class="string">"value"</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.onpropertychange = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">this</span>.<span class="keyword">value</span>.toUpperCase();</span><br><span class="line">			<span class="keyword">this</span>.onpropertychange = upcaseOnPropertyChange</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="事件处理">事件处理</h1><h2 id="事件代理">事件代理</h2><p>节省内存，适用于表格/列表等重复性dom元素。基本原理就是将事件绑定到祖先元素上，然后判断事件对象target，如果为对应的子元素则执行对应的逻辑。</p>
<h2 id="事件创建/分发">事件创建/分发</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">event</span> = document.createEvent(<span class="string">'Event'</span>);</span><br><span class="line"><span class="keyword">event</span>.initEvent(<span class="string">'click'</span>);</span><br><span class="line"><span class="keyword">var</span> element = document.getElementById(<span class="string">'zdl'</span>);</span><br><span class="line">element.dispatchEvent(<span class="keyword">event</span>);</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1><p>这本书真是内容翔实，枯燥难读。这一章的内容看了几遍才决定以百度脑图和代码实例相结合的方式算是比较合理吧~</p>
<p>百度脑图下载地址：<a href="http://yalishizhude.github.io/subscribe/">http://yalishizhude.github.io/subscribe/</a></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2016/03/14/rhinoceros-event/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Angular中用代理服务实现控制器与指令之间的通信]]></title>
      <link>http://yalishizhude.github.io/2016/02/28/angular-directive-delegate/</link>
      <guid>http://yalishizhude.github.io/2016/02/28/angular-directive-delegate/</guid>
      <pubDate>Sun, 28 Feb 2016 10:14:10 GMT</pubDate>
      <description>
      <![CDATA[<h1 id="场景">场景</h1><p>一般来说，angular中，控制器与指令之间的通信可以通过共享作用域的方式来实现。这种处理方式可以满足大部分需求，但是比如说指令如果是独立作用域的话这种情况就玩不转了~在开发中就碰到这样一种尴尬的情况：控制器想要操作某个dom元素（滚动或者获取元素坐标），angular中是不提倡在控制器中直接操作dom而是在指令中。这个时候就可以通过一个代理服务来实现。</p>]]>
      
      </description>
      <content:encoded><![CDATA[<h1 id="场景">场景</h1><p>一般来说，angular中，控制器与指令之间的通信可以通过共享作用域的方式来实现。这种处理方式可以满足大部分需求，但是比如说指令如果是独立作用域的话这种情况就玩不转了~在开发中就碰到这样一种尴尬的情况：控制器想要操作某个dom元素（滚动或者获取元素坐标），angular中是不提倡在控制器中直接操作dom而是在指令中。这个时候就可以通过一个代理服务来实现。</p>
<a id="more"></a>
<h1 id="代理服务">代理服务</h1><p>这一段代理服务的代码短小精悍，从著名的<a href="http://ionicframework.com/" target="_blank" rel="external">ionic</a>中拷贝出来。<br>大致思路是通过<code>angular.DelegateService</code>来返回一个代理服务，指令将接口注册到代理服务，控制器调用代理服务中的接口即可操作指令从而操作dom元素。</p>
<h2 id="扩展Angular属性">扩展Angular属性</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">angular.DelegateService = <span class="function"><span class="keyword">function</span> <span class="params">(methodNames)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> [<span class="string">'$log'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(<span class="variable">$log</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DelegateService();</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>angular中最全局的全局变量当然就是<code>angular</code>了，在此之上添加函数，就可以在模块定义的时候使用。这个函数返回的是标准的声明service的数组，前面一个<code>$log</code>服务，后面一个实现函数。而这个服务本身就是新创建的<code>DelegateService</code>实例。<br>先来看看这个<code>methodNames</code>参数有什么用处。<code>methodNames</code>看名字就可以知道这是一个数组，包含了一些函数的名称（字符串）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (methodNames.indexOf(<span class="string">'$getByHandle'</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Method '$getByHandle' is implicitly added to each delegate service. Do not list it as a method."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>避免内置函数<code>$getByHandle</code>和自定义的函数冲突。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">methodNames.<span class="keyword">forEach</span>(<span class="function"><span class="keyword">function</span> <span class="params">(methodName)</span> </span>&#123;</span><br><span class="line">  DelegateInstance.prototype[methodName] = instanceMethodCaller(methodName);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>将所数组中的函数一个个复制到代理服务的原型<code>prototype</code>上。<br>再来看看如何调用实例函数。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> instanceMethodCaller(methodName) &#123;</span><br><span class="line">  return function caller() &#123;</span><br><span class="line">    var handle = this.handle,</span><br><span class="line">      args = arguments,</span><br><span class="line">      foundInstancesCount = <span class="number">0</span>,</span><br><span class="line">      returnValue;</span><br><span class="line">    this._instances.forEach(function (instance) &#123;</span><br><span class="line">      if ((!handle || handle === instance.$<span class="variable">$delegateHandle</span>) &amp;&amp; instance.$<span class="variable">$filterFn</span>(instance)) &#123;</span><br><span class="line">        foundInstancesCount++;</span><br><span class="line">        var ret = instance[methodName].apply(instance, args);</span><br><span class="line">        if (foundInstancesCount === <span class="number">1</span>) &#123;</span><br><span class="line">          returnValue = ret;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    if (!foundInstancesCount &amp;&amp; handle) &#123;</span><br><span class="line">      return <span class="variable">$log</span>.warn(<span class="string">'Delegate for handle "'</span> + handle + <span class="string">'" could not find a '</span> + <span class="string">'corresponding element with id/delegate="'</span> + handle + <span class="string">'"! '</span> + methodName + <span class="string">'() was not called!\n'</span> + <span class="string">'Possible cause: If you are calling '</span> + methodName + <span class="string">'() immediately, and '</span> + <span class="string">'your element with delegate-handle="'</span> + handle + <span class="string">'" is a child of your '</span> + <span class="string">'controller, then your element may not be compiled yet. Put a $timeout '</span> + <span class="string">'around your call to '</span> + methodName + <span class="string">'() and try again.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    return returnValue;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实很简单，这里返回了一个<code>caller</code>函数，这个函数就是遍历_instances中的实例，然后匹配函数名称，调用并返回结果。默认返回第一个实例或者指定的实例。</p>
<p>下面来看看这个实例。</p>
<h2 id="代理服务实例">代理服务实例</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DelegateInstance</span><span class="params">(instances, handle)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._instances = instances;</span><br><span class="line">  <span class="keyword">this</span>.handle = handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个代理服务，自然会有很多实例，这里用<code>_instances</code>这个数组来保存实例。至于<code>handle</code>可以理解为实例id。<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DelegateService.<span class="keyword">prototype</span> = DelegateInstance.<span class="keyword">prototype</span>;</span><br></pre></td></tr></table></figure></p>
<p>这里首先将<code>DelegateInstance</code>的原型复制到<code>DelegateService</code>上。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trueFn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">DelegateService.prototype._registerInstance = <span class="function"><span class="keyword">function</span> <span class="params">(instance, handle, filterFn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instances = this._instances;</span><br><span class="line">  instance.<span class="variable">$$delegateHandle</span> = handle;</span><br><span class="line">  instance.<span class="variable">$$filterFn</span> = filterFn || trueFn;</span><br><span class="line">  instances.push(instance);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">deregister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index = instances.indexOf(instance);</span><br><span class="line">    <span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">      instances.splice(index, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里在代理服务<code>DelegateService</code>的原型上声明了一个函数<code>_registerInstance</code>用来注册服务。该函数将服务保存在代理服务中，同时返回一个注销服务的函数。<code>filterFn</code>实际上就是一个过滤函数，如果实例中拥有私有函数，可以通过自定义过滤函数，只暴露公有函数。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DelegateService.prototype.<span class="variable">$getByHandle</span> = <span class="keyword">function</span> (handle) &#123;</span><br><span class="line">  return new DelegateInstance(this._instances, handle);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>私有函数，通过<code>handle</code>这个id来获取实例。</p>
<h1 id="使用实例">使用实例</h1><p>这里的例子是控制器通过代理服务来操作指令的例子</p>
<h2 id="编写指令，注册服务">编写指令，注册服务</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'directive'</span>, []).directive(<span class="string">'keyboard'</span>, [<span class="string">'keyboardService'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">keyboardService</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    replace: <span class="literal">true</span>,</span><br><span class="line">    templateUrl: <span class="string">'template/keyboard.html'</span>,</span><br><span class="line">    link: <span class="function"><span class="keyword">function</span> (<span class="params">scope, elm, attrs</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> instance = &#123;</span><br><span class="line">        toggle: <span class="function"><span class="keyword">function</span> (<span class="params">flag</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">window</span>.console.log(flag);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      keyboardService._registerInstance(instance);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;]).service(<span class="string">'keyboardService'</span>, angular.DelegateService([<span class="string">'toggle'</span>]));</span><br></pre></td></tr></table></figure>
<h2 id="控制器中通过服务调用指令">控制器中通过服务调用指令</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'app'</span>, [<span class="string">'directive'</span>]).controller(<span class="string">'ctrl'</span>, [<span class="string">'$scope'</span>, <span class="string">'keyboardService'</span>, <span class="keyword">function</span>(<span class="variable">$scope</span>, keyboardService)&#123;</span><br><span class="line">  keyboardService.toggle(true);</span><br><span class="line">  &#125;]);</span><br></pre></td></tr></table></figure>
<h1 id="代理服务源码">代理服务源码</h1><p><a href="https://github.com/driftyco/ionic/blob/master/js/utils/delegateService.js" target="_blank" rel="external">https://github.com/driftyco/ionic/blob/master/js/utils/delegateService.js</a></p>
<p><em>如果觉得阅读这篇文章有收获，不妨点个赞吧^_^</em></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2016/02/28/angular-directive-delegate/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[《意志力-关于专注、自控与效率的心理学》读书笔记]]></title>
      <link>http://yalishizhude.github.io/2016/02/05/willpower/</link>
      <guid>http://yalishizhude.github.io/2016/02/05/willpower/</guid>
      <pubDate>Fri, 05 Feb 2016 15:25:32 GMT</pubDate>
      <description>
      <![CDATA[<p>看这本书是因为我听到罗辑思维的罗胖宣称自己要将跨年演讲做20年。很多时候人能成功靠的可能就是这样在正确道路上的一份执着，而这份执着用书面语言表达就叫做意志力。看到这本书评分还不低，索性在天天加班的情况下坚持把它读完了。</p>
<p>这本书举了大量的例子，结构比较散乱，基本上解释了意志力的重要性，特点，以及提升它的方法。其中的干货都总结摘抄如下。</p>]]>
      
      </description>
      <content:encoded><![CDATA[<p>看这本书是因为我听到罗辑思维的罗胖宣称自己要将跨年演讲做20年。很多时候人能成功靠的可能就是这样在正确道路上的一份执着，而这份执着用书面语言表达就叫做意志力。看到这本书评分还不低，索性在天天加班的情况下坚持把它读完了。</p>
<p>这本书举了大量的例子，结构比较散乱，基本上解释了意志力的重要性，特点，以及提升它的方法。其中的干货都总结摘抄如下。</p>
<a id="more"></a>
<h1 id="驱动意志力的能量来自哪里">驱动意志力的能量来自哪里</h1><p>为了保持自制力，你最好吃血糖指数低的食物：大多数蔬菜、坚果、很多生水果、奶酪、鱼肉、橄榄油或其他“好”脂肪。</p>
<p>有研究证明，剥夺睡眠会损害葡萄糖的加过，这会立即导致自制力下降——长期下去，还会提高糖尿病风险。</p>
<h1 id="任务清单简史，从上帝到凯里">任务清单简史，从上帝到凯里</h1><p>自我控制的第一部是设置清晰的目标。对我们大部分人而言，问题不是没有目标，而是目标太多。我们每天都列出很多任务，即使没有外界干扰，一天之内也完成不了这些任务，更何况外界干扰总是有的。</p>
<p>只有近端目标才能让学习有所进步、让自我效能感和成绩有所提高。</p>
<h1 id="决策疲劳">决策疲劳</h1><p>做决定要损耗意志力，损耗了意志力后，人们就会想办法推迟或逃避决定。</p>
<h1 id="意志力可以培养吗">意志力可以培养吗</h1><p>设置小目标设法去实现，有助于你实现原本不怎么可能实现的更大的目标。不要仅仅针对目标联系，而是要将练习难度设定得高于目标难度，绝不要地狱目标难度，这样你就有余地，你就知道你总能超过目标。这就是自律，自律就是重复和练习。</p>
<h1 id="深入黑暗之最战胜自己">深入黑暗之最战胜自己</h1><p>为未来指定行为规范时，你大都处于冷静状态，所以你作出不切实际的承诺。<br>不饿的时候，你真的容易统一节食。性没有被唤醒时，你真的容易禁欲。</p>
<h1 id="节食风暴">节食风暴</h1><p>自我控制的第一步是，设置切合实际的目标。</p>
<p>自我控制中，定下目标后，下一步是监控。</p>
<p>如果你用激励措施实现了减肥目标，那么你一直要用同样的激励措施来保持体重不反弹。</p>
<p>为了减肥，你不要制订笼统的计划，而要制订非常详细的计划，规定在某些情形下具体要怎么做。越利用这种行为自动化，你耗费的努力就越少。</p>
<h1 id="关于意志力的10个启示：">关于意志力的10个启示：</h1><h2 id="了解你的极限。">了解你的极限。</h2><p>意志力是有限的，使用就会消耗，就像肌肉一样，使用之后会疲劳。</p>
<p>意志力虽然只有一种，但它被用于各种不同的任务。所以工作压力最大时婚姻往往出问题：人们在工作上用完了所有的意志力。</p>
<p>重要的是过程不是结果。如果你与诱惑作斗争然后曲阜了，你还是会损耗意志力，因为你作斗争了。</p>
<p>建议：一次只做一件事。<br>如果你一心多用，你也许可以暂时兼顾一下，但是，随着意志力消耗殆尽，你越来越可能犯严重错误。如果你想让生活同时发生几个变化，那么最终可能一个变化都发生不了。</p>
<h2 id="留意你的症状">留意你的症状</h2><p>损耗并没有明显的“感受”，因此你自己需要留意那些容易被误解的微妙迹象：判断力受损，更加易怒。。。最好别在这个时候作有法力小丽的决定，因为此时你容易选择短期获得利益、延迟支付成本的选项。为了弥补这一点，你可以在作决定时赋予长期后果更多权重。为了避免屈服于非理性偏差和启发式偏差，你最好把做决定的理由表达出来，考虑它们是否有意义。</p>
<h2 id="挑选你的战斗">挑选你的战斗</h2><p>你无法控制甚至无法预测生活中的压力，但是你可以在冷静期——至少在平静的时刻——计划如何以攻为守。开始定期健身，学习新技能，戒烟，少喝酒，控制饮食。所有这些事情不管是哪一件，最好在其他事情对意志力的要求相对较低的时候做，这样你就可以留出很多意志力给它。</p>
<p>为冗长乏味的任务定下严格的时间限制，给自己顶个最后期限，强迫自己作不想提前作的决定，为更大的“战斗”节省意志力。</p>
<h2 id="列个任务清单——至少列个“不做清单”">列个任务清单——至少列个“不做清单”</h2><p>把一旦写下来就不必再为之操心的事情列成清单。你需要至少计划出具体的下一步：做什么，与谁联系，如何联系。</p>
<p>任务安排的越具体，可执行性越高，执行时消耗的意志力也越少。</p>
<h2 id="当心计划谬误">当心计划谬误</h2><p>避免计划谬误的方法就是强迫你自己想想你的过去做同类事情的时候耗费了多少时间精力。</p>
<h2 id="不要忘了小事情">不要忘了小事情</h2><p>随着你位目标而奋斗，你的大脑会自动削减你用在其他方面的意志力。</p>
<p>想要意志力发挥最大效果，你必须很好地满足身体的基本需求，从饮食和睡眠开始。你可以放纵自己吃甜点，但一定要顶起吃足够的健康食品，这样你的但闹才有足够的能量。睡眠甚至比实物更重要：得到充分休息的意志——更强。</p>
<p>提高意志力的另外一个简单而老式的方法是，稍微花点意志力保持干净整洁。你也许并不在意你的杯子是否叠了、你的桌子是否干净，但是这些环境线索会微妙地影响你的大脑和你的行为，让你最终觉得较难自律。秩序感对提升意志力至关重要。</p>
<p>当心其它影响你行为的线索：上班路上经过甜甜圈店，下午茶时间抽烟或狂吃巧克力。。。远离那些人、事、景。</p>
<h2 id="积极拖延的力量">积极拖延的力量</h2><p>与高速自己绝不要碰巧克力的人相比，告诉自己稍后再吃巧克力的人能更好地抵制巧克力的诱惑。这个延迟想了策略对抵制其它诱惑也有用。</p>
<h2 id="别无选择">别无选择</h2><p>做事情给自己预设一个底线。例如，你可以每天早晨先把90分钟投入到写作上，要么写作，要么什么都不做。剩下的就是自然而然的了。以攻为守，意志力就节省下来了。这种规定，你多遵守一次，它就变常规一些，直到最终自动发生，而你将获得一个保存意志力的长效方法：习惯。</p>
<h2 id="追踪了解">追踪了解</h2><p>不管你作了什么计划，监控都十分关键——甚至，即使你根本没作计划，监控也是有用的。每天称体重、写饮食日记可以帮助你减肥，就像记账可以帮助你少花钱一样。监控越认真越好。</p>
<p>自我监控是件枯燥的事情，但是现在可以用一些新工具：Quantified self、lifehacker</p>
<p>除了提供即时鼓励外，监控还让你改进长期计划。定期检查进展，今儿设置更符合实际的目标。</p>
<p>这让我想到了PDCA，PDCA整体思路很简单，但是CA步骤很少有人执行。</p>
<h2 id="经常奖励">经常奖励</h2><p>如果你只用意志力拒绝东西，那么它就成了残忍讨厌的防守工具。但是，当你用意志力获得东西，你就能从最枯燥的任务中体会到乐趣。</p>
<p>每个人都需要找到自己的小奖励，而且必须是对自己有用的小奖励。</p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2016/02/05/willpower/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[handlebars玩家指南]]></title>
      <link>http://yalishizhude.github.io/2016/01/22/handlebars/</link>
      <guid>http://yalishizhude.github.io/2016/01/22/handlebars/</guid>
      <pubDate>Thu, 21 Jan 2016 16:19:02 GMT</pubDate>
      <description>
      <![CDATA[<img src="/2016/01/22/handlebars/handlebars.png" alt="handlebars.png" title="">
<blockquote>
<p>提示：文中 “{ {” 、“} }”，在实际使用中用双花括号，中间无空格。</p>
</blockquote>
<p>写这篇文章也是因为当初我为了实现一个模板分页的某个功能（这个问题以及解决方法最后说），花了不少时间将官网看了几遍，试验了很久之后依然没有成功，然后凭着一股崛起继续钻研终于解决了这个问题。此时发现handlebars的东西基本上也了解得差不多了，所以干脆抽时间写篇文章整理一下。<br>]]>
      
      </description>
      <content:encoded><![CDATA[<img src="/2016/01/22/handlebars/handlebars.png" alt="handlebars.png" title="">
<blockquote>
<p>提示：文中 “{ {” 、“} }”，在实际使用中用双花括号，中间无空格。</p>
</blockquote>
<p>写这篇文章也是因为当初我为了实现一个模板分页的某个功能（这个问题以及解决方法最后说），花了不少时间将官网看了几遍，试验了很久之后依然没有成功，然后凭着一股崛起继续钻研终于解决了这个问题。此时发现handlebars的东西基本上也了解得差不多了，所以干脆抽时间写篇文章整理一下。<br><a id="more"></a></p>
<h1 id="为什么需要模板引擎">为什么需要模板引擎</h1><p>关于前端的模板引擎，我用一个公式来解释</p>
<pre><code>            模板引擎
模板 + 数据 =======<span class="function">=&gt;</span> html页面
</code></pre><p>模板引擎就像是html的解析生成器，将对应的模板填充完数据之后生成静态的html页面。它可以在浏览器端（比如angular中指令所用的模板）也可以在服务器端执行，不过一般用于服务器端。因为它的一个作用是抽象公共页面来重用，如果在服务端填充数据，可以减少回填数据给页面的ajax请求，从而提升浏览器端整体页面渲染速度。</p>
<h1 id="那些年我用过的模板引擎">那些年我用过的模板引擎</h1><p>接触过的模板引擎不算多，最早应该是jsp，本质上也是一种模板引擎，再到功能稍微强大的freemarker，这两种都是属于java语系的。js语系的jade和ejs我都有所接触，不过不常用，jade那种类python的语法规则以及较低的解析效率都让我不敢兴趣，Express框架也只是早起将其作为模板引擎。后来换成了强大的ejs，无论是功能还是写法上都接近jsp了。直到最新的Express4发布，默认改为了弱逻辑的比较简洁的模板引擎handlebars。</p>
<p>我使用handlebars有以下几个原因：</p>
<ul>
<li>这次新项目前端框架搭建基于Express4，模板引擎只能在ejs/jade/hogan/hbs中选择一个。</li>
<li>默认是handlebars，虽不知道原因，想必有其原因。</li>
<li>看过“去哪儿”的前端技术分享，他们就是在handlebars上进行封装的，证明已经有人填过坑了，可以一试。</li>
<li>开始比较看好ejs，但是官网文档被强了，相比之下handlebars的文档比较清晰，还有实例，虽然逻辑结构比较混乱，但是基本无障碍。</li>
</ul>
<h1 id="码解handlebars">码解handlebars</h1><p>运行环境：Express4、hbs4<br>未接触Express或hbs的可以先看<a href="http://www.expressjs.com.cn/4x/api.html#res.render" target="_blank" rel="external">这里</a></p>
<h2 id="初级玩家：表达式">初级玩家：表达式</h2><p>数据：</p>
<pre><code>{
    title: <span class="string">'Express'</span>,
    obj:{
        version: <span class="string">'v4.3'</span>,
        category: <span class="string">'node'</span>,
        <span class="string">"date~"</span>: <span class="string">'2016'</span>
    }
}
</code></pre><p>模板：</p>
<pre><code><span class="xml"><span class="tag">&lt;<span class="title">p</span>&gt;</span></span><span class="expression">{ {<span class="variable">title</span>}</span><span class="xml"> }<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;<span class="title">p</span>&gt;</span></span><span class="expression">{ {<span class="variable">obj.version</span>}</span><span class="xml"> }<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;<span class="title">p</span>&gt;</span></span><span class="expression">{ {<span class="variable">obj</span><span class="end-block">/category</span>}</span><span class="xml"> }<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;<span class="title">p</span>&gt;</span></span><span class="expression">{ {<span class="variable">obj.date</span>~}</span><span class="xml"> }<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span>
</code></pre><p>html页面：</p>
<pre><code>Express
v4<span class="number">.3</span>
node
</code></pre><p>handlebars中变量都添加双花括号来表示（类似Angular），对比ejs的”&lt;%%&gt;”来说看起来没什么区别，其实这是很人性化的，想一下你键盘上的位置，再考虑按这几个字符的难易程度你就懂了。<br>其中要访问变量的属性值时可以用类似json格式的”.”，也可以用”/“。</p>
<p><em>其中变量名不可包含以下字符。如果包含则不被解析，如上的”“。</em></p>
<pre><code>空格 ! <span class="string">" # % &amp; ' ( ) * + , . / ; &lt; = &gt; @ [ \ ] ^ ` { | } ~</span>
</code></pre><p>但可以用 <strong>“</strong> , <strong>‘</strong> , <strong>[]</strong> 来转译这些特殊字符。</p>
<p>这一条规则意味着 <strong>“&amp;&amp;”,”||”,”!”这类逻辑判断是不能出现在表达式中的！</strong> （看着这一条是不是觉得弱爆了，要不然怎么叫若逻辑模板引擎呢~哈哈，不过当然有另外的解决办法）。</p>
<h2 id="中级玩家：helper">中级玩家：helper</h2><p>英语水平有限，实在找不到一个恰当的词来翻译它了。可以理解为它是注入到模板中的一个函数，用来接收参数并进行逻辑处理。</p>
<h3 id="默认helper">默认helper</h3><h4 id="if_else">if else</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#123;#if author&#125; &#125;</span><br><span class="line">  &lt;h1&gt;&#123; &#123;firstName&#125; &#125; &#123; &#123;lastName&#125; &#125;&lt;/h1&gt;</span><br><span class="line">&#123; &#123;else&#125; &#125;</span><br><span class="line">  &lt;h1&gt;Unknown Author&lt;/h1&gt;</span><br><span class="line">&#123; &#123;/if&#125; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="expression">&#123; &#123;<span class="begin-block">#<span class="keyword">if</span> isActive</span>&#125;</span><span class="xml"> &#125;</span><br><span class="line">  <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"star.gif"</span> <span class="attribute">alt</span>=<span class="value">"Active"</span>&gt;</span></span><br><span class="line"></span><span class="expression">&#123; &#123;<span class="variable">else</span> <span class="variable"><span class="keyword">if</span></span> <span class="variable">isInactive</span>&#125;</span><span class="xml"> &#125;</span><br><span class="line">  <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"cry.gif"</span> <span class="attribute">alt</span>=<span class="value">"Inactive"</span>&gt;</span></span><br><span class="line"></span><span class="expression">&#123; &#123;<span class="end-block">/<span class="keyword">if</span></span>&#125;</span><span class="xml"> &#125;</span></span><br></pre></td></tr></table></figure>
<p>和一般的编程语言的 <strong>if-else</strong> 代码块是差不多的，不过再次重申由于上面提到的特殊字符，所以if条件中是不能有逻辑表达式的，只能是变量或者值。</p>
<h4 id="unless">unless</h4><p>还是因为上面提到的那些字符，handlebars不支持逻辑非(“!”)，所以又有了一个与if相反的helper</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#123;<span class="comment">#unless license&#125; &#125;</span></span><br><span class="line">&lt;h3 <span class="type">class</span>=<span class="string">"warning"</span>&gt;WARNING: This entry <span class="keyword">does</span> <span class="keyword">not</span> have a license!&lt;/h3&gt;</span><br><span class="line">&#123; &#123;/unless&#125; &#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码就等价于</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#123;<span class="comment">#if license&#125; &#125;</span></span><br><span class="line">&#123; &#123;<span class="keyword">else</span>&#125; &#125;</span><br><span class="line">&lt;h3 <span class="type">class</span>=<span class="string">"warning"</span>&gt;WARNING: This entry <span class="keyword">does</span> <span class="keyword">not</span> have a license!&lt;/h3&gt;</span><br><span class="line">&#123; &#123;/<span class="keyword">if</span>&#125; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="each">each</h4><p>都知道each相当于for循环。不过有些地方需要注意：</p>
<ul>
<li>可以用相对路径的方式来获取上一层的上下文。（上下文概念跟js中的上下文差不多，比如在each passage代码块内，每一次循环上下文一次是passage[0],passage[1]…）</li>
<li>一些默认变量，@first/@last 当该对象为数组中第一个/最后一个时返回真值。如果数组成员为值而非对象，@index表示当前索引值，可以用@key或者this获取当前值</li>
<li>可以用 <code>as |xxx|</code>的形式给变量起别名，循环中通过别名可以引用父级变量值。当然也可以通过相对路径的方式引用父级变量。<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#123;#each passage&#125; &#125;</span><br><span class="line">    &#123; &#123;#each paragraphs&#125; &#125;</span><br><span class="line">      &#123; &#123;@../index&#125; &#125;:&#123; &#123;@index&#125; &#125;:&#123; &#123;this&#125; &#125;&lt;/p&gt;</span><br><span class="line">    &#123; &#123;else&#125; &#125;</span><br><span class="line">      &lt;p class=<span class="string">"empty"</span>&gt;No content&lt;/p&gt;</span><br><span class="line">    &#123; &#123;/each&#125; &#125;</span><br><span class="line">&#123; &#123;/each&#125; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#123;#each array as |value, key|&#125; &#125;</span><br><span class="line">  &#123; &#123;#each child as |childValue, childKey|&#125; &#125;</span><br><span class="line">    &#123; &#123;key&#125; &#125; - &#123; &#123;childKey&#125; &#125;. &#123; &#123;childValue&#125; &#125;</span><br><span class="line">  &#123; &#123;/each&#125; &#125;</span><br><span class="line">&#123; &#123;/each&#125; &#125;</span><br></pre></td></tr></table></figure>
<p>同时也可以用来遍历对象，这时@key表示属性名,this表示对应的值</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#123;#each object&#125; &#125;</span><br><span class="line">  &#123; &#123;@key&#125; &#125;: &#123; &#123;this&#125; &#125;</span><br><span class="line">&#123; &#123;/each&#125; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="with">with</h4><p>类似js中的with，可以配合分页使用，限定作用域。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#123;#with author as |myAuthor|&#125; &#125;</span><br><span class="line">  &lt;h2&gt;By &#123; &#123;myAuthor.firstName&#125; &#125; &#123; &#123;myAuthor.lastName&#125; &#125;&lt;/h2&gt;</span><br><span class="line">&#123; &#123;else&#125; &#125;</span><br><span class="line">  &lt;p class=<span class="string">"empty"</span>&gt;No content&lt;/p&gt;</span><br><span class="line">&#123; &#123;/with&#125; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="lookup">lookup</h4><p>这个用于以下这种并列数组的情况，可以按照索引来找兄弟变量对应的值。理解起来有些困难，直接看代码</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="label">    groups:</span> [</span><br><span class="line">        &#123;<span class="string">id:</span> <span class="number">1</span>, <span class="string">title:</span> <span class="string">"group1"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">id:</span> <span class="number">2</span>, <span class="string">title:</span> <span class="string">"group2"</span>&#125;,</span><br><span class="line">    ],</span><br><span class="line"><span class="label">    users:</span> [</span><br><span class="line">        &#123;<span class="string">id:</span><span class="number">1</span>, <span class="string">login:</span> <span class="string">"user1"</span>, <span class="string">groupId:</span> <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">id:</span><span class="number">2</span>, <span class="string">login:</span> <span class="string">"user2"</span>, <span class="string">groupId:</span> <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">id:</span><span class="number">3</span>, <span class="string">login:</span> <span class="string">"user3"</span>, <span class="string">groupId:</span> <span class="number">1</span>&#125;</span><br><span class="line">    ],</span><br><span class="line"><span class="label">    infos:</span> [</span><br><span class="line">        <span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">table</span>&gt;</span></span><br><span class="line">    </span><span class="expression">&#123; &#123;<span class="begin-block">#each users</span>&#125;</span><span class="xml"> &#125;</span><br><span class="line">        <span class="tag">&lt;<span class="title">tr</span> <span class="attribute">data-id</span>=<span class="value">"</span></span></span><span class="expression">&#123; &#123;<span class="variable">id</span>&#125;</span><span class="xml"><span class="tag"><span class="value"> &#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">td</span>&gt;</span></span><span class="expression">&#123; &#123;<span class="variable">login</span>&#125;</span><span class="xml"> &#125;<span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">td</span> <span class="attribute">data-id</span>=<span class="value">"</span></span></span><span class="expression">&#123; &#123;<span class="variable">groupId</span>&#125;</span><span class="xml"><span class="tag"><span class="value"> &#125;"</span>&gt;</span></span><span class="expression">&#123; &#123;<span class="variable">lookup</span> <span class="variable">..</span><span class="end-block">/infos </span>@<span class="variable">index</span>&#125;</span><span class="xml"> &#125;<span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line">    </span><span class="expression">&#123; &#123;<span class="end-block">/each</span>&#125;</span><span class="xml"> &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="title">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user1   <span class="tag">a</span></span><br><span class="line">user2   <span class="tag">b</span></span><br><span class="line">user3   c</span><br></pre></td></tr></table></figure>
<p>这里在users数组中按照索引值引用infos数组中对应的值，如果想引用groups中的groupId呢？很简单，用with。</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">table</span>&gt;</span></span><br><span class="line">    </span><span class="expression">&#123; &#123;<span class="begin-block">#each users</span>&#125;</span><span class="xml"> &#125;</span><br><span class="line">        <span class="tag">&lt;<span class="title">tr</span> <span class="attribute">data-id</span>=<span class="value">"</span></span></span><span class="expression">&#123; &#123;<span class="variable">id</span>&#125;</span><span class="xml"><span class="tag"><span class="value"> &#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">td</span>&gt;</span></span><span class="expression">&#123; &#123;<span class="variable">login</span>&#125;</span><span class="xml"> &#125;<span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">td</span> <span class="attribute">data-id</span>=<span class="value">"</span></span></span><span class="expression">&#123; &#123;<span class="variable">groupId</span>&#125;</span><span class="xml"><span class="tag"><span class="value"> &#125;"</span>&gt;</span></span><span class="expression">&#123; &#123;<span class="begin-block">#with </span>(<span class="variable">lookup</span> <span class="variable">..</span><span class="end-block">/groups </span>@<span class="variable">index</span>)&#125;</span><span class="xml"> &#125;</span><span class="expression">&#123; &#123;<span class="variable">title</span>&#125;</span><span class="xml"> &#125;</span><span class="expression">&#123; &#123;<span class="end-block">/with</span>&#125;</span><span class="xml"> &#125;<span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line">    </span><span class="expression">&#123; &#123;<span class="end-block">/each</span>&#125;</span><span class="xml"> &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="title">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="自定义helper">自定义helper</h3><p>内置的helper不够强大，所以通常需要写js代码自定义helper，先看一个简单的单行helper。</p>
<h4 id="行级helper">行级helper</h4><h5 id="传值">传值</h5><p>数值、字符串、布尔值这种常规数据可以直接传入，同时也可以传递JSON对象（但只能传一个），以key=value这种形式写在后面，最后就可以通过参数的hash属性来访问了。</p>
<p>模板</p>
<pre><code>{ {agree_button <span class="string">"My Text"</span> <span class="keyword">class</span>=<span class="string">"my-class"</span> visible=<span class="literal">true</span> counter=<span class="number">4</span>} }
</code></pre><p>代码</p>
<pre><code>hbs.registerHelper(<span class="string">'agree_button'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
 <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);<span class="comment">//==&gt;"My Text"</span>
 <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>].hash);<span class="comment">//==&gt;{class:"my-class",visible:true,conter:4}</span>
}
</code></pre><h5 id="传变量">传变量</h5><p>传变量时可以用this指针来指代它访问属性，通过逻辑判断后可以返回一段html代码，不过太建议这样做。考虑以后的维护性，这种html代码和js代码混合起来的维护性是比较差的，如果要抽象层组件还是使用分页比较好。</p>
<p>模板：</p>
<pre><code>{ {agree_button <span class="keyword">person</span>} }
</code></pre><p>注册helper：</p>
<pre><code>hbs.registerHelper('agree_button', function(p) {
  console.log(p===this);//==&gt; true
  var blog = hbs.handlebars.escapeExpression(this.<span class="keyword">person</span>.blog),
      name = hbs.handlebars.escapeExpression(this.<span class="keyword">person</span>.name);

  return new hbs.handlebars.SafeString(
    <span class="string">"&lt;a href='"</span>+blog+<span class="string">"'&gt;"</span>+ name + <span class="string">"&lt;/button&gt;"</span>
  );
});
</code></pre><p>数据：</p>
<pre><code>var context = {
    <span class="keyword">person</span>:{name: <span class="string">"亚里士朱德"</span>, blog: <span class="string">"https://yalishizhude.github.io"</span>} };
};
</code></pre><p>html页面：</p>
<pre><code><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"https://yalishizhude.github.io"</span>&gt;</span>亚里士朱德<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
</code></pre><p>当内容只想做字符串解析的时候可以用 <strong>escapeExpression</strong> 和 <strong>SafetString</strong> 函数。</p>
<h4 id="块级helper">块级helper</h4><p>块级helper获取参数的方式跟之前差不多，只是最后多了一个参数，这个参数有两个函数<code>fn</code>和<code>revers</code>可以和<code>else</code>搭配使用。后面将会讲解。</p>
<p>模板：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#123;#list nav&#125; &#125;</span><br><span class="line">  &lt;a href=<span class="string">"&#123; &#123;url&#125; &#125;"</span>&gt;&#123; &#123;title&#125; &#125;&lt;/a&gt;</span><br><span class="line">&#123; &#123;/list&#125; &#125;</span><br></pre></td></tr></table></figure>
<p>注册helper：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Handlebars.registerHelper('<span class="keyword">list</span>', function(context, options) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">ret</span> = <span class="string">"&lt;ul&gt;"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=0, j=context.length; i&lt;j; i++) &#123;</span><br><span class="line">    <span class="keyword">ret</span> = <span class="keyword">ret</span> + <span class="string">"&lt;li&gt;"</span> + options.fn(context[i]) + <span class="string">"&lt;/li&gt;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">ret</span> + <span class="string">"&lt;/ul&gt;"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>数据：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;</span><br><span class="line">  nav: <span class="collection">[</span><br><span class="line">    <span class="collection">&#123; url: <span class="string">"https://yalishihzude.github.io"</span>, title: <span class="string">"blog"</span> &#125;</span>,</span><br><span class="line">    <span class="collection">&#123; url: <span class="string">"https://www.github.com/yalishizhude"</span>, title: <span class="string">"github"</span> &#125;</span>,</span><br><span class="line">  ]</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>html页面：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span>  <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"https://yalishizhude.github.io"</span>&gt;</span>blog<span class="tag">&lt;/<span class="title">a</span>&gt;</span> <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span>  <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"https://www.github.com/yalishizhude"</span>&gt;</span>github<span class="tag">&lt;/<span class="title">a</span>&gt;</span> <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="自定义helper-1">自定义helper</h4><p>each的index变量比较常用，但是它是从0开始的，往往不符合业务中的需求，这里写个helper来扩展一下。</p>
<p>注册helper：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">hbs.registerHelper(<span class="string">'eval'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">str, options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reg = <span class="regexp">/\&#123;\&#123;.*?\&#125;\&#125;/g</span>;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> variables = str.match(reg);</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//如果是each</span></span><br><span class="line">    <span class="keyword">if</span>(options.data)&#123;</span><br><span class="line">      context.first = context.first||options.data.first;</span><br><span class="line">      context.last = context.last||options.data.last;</span><br><span class="line">      context.index = context.index||options.data.index;</span><br><span class="line">      context.key = context.key||options.data.key;</span><br><span class="line">    &#125;</span><br><span class="line">    _.each(variables, <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> key = v.replace(<span class="regexp">/&#123; &#123;|&#125; &#125;/g</span>,<span class="string">""</span>);</span><br><span class="line">      <span class="keyword">var</span> value = <span class="keyword">typeof</span> context[key]===<span class="string">"string"</span>?(<span class="string">'"'</span>+context[key]+<span class="string">'"'</span>):context[key];</span><br><span class="line">      str = str.replace(v, value);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      result = <span class="built_in">eval</span>(str);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> hbs.handlebars.SafeString(result);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> hbs.handlebars.SafeString(<span class="string">''</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(str,<span class="string">'--Handlerbars Helper "eval" deal with wrong expression!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<p>模板：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123; <span class="collection">&#123;#each list&#125;</span> &#125;</span></span><br><span class="line"><span class="collection">&#123; <span class="collection">&#123;eval '<span class="collection">&#123; <span class="collection">&#123;index&#125;</span> &#125;</span><span class="number">+1</span>'&#125;</span> &#125;</span></span><br><span class="line"><span class="collection">&#123; <span class="collection">&#123;/each&#125;</span> &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面说到if不支持复杂的表达式，如果是“&amp;&amp;”操作还可以用子表达式来实现，更加复杂的就不好办了，这里我写了一个helper来实现。</p>
<p>注册helper：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">hbs.registerHelper(<span class="string">'ex'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">str, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reg = <span class="regexp">/\&#123;\&#123;.*?\&#125;\&#125;/g</span>;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> variables = str.match(reg);</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">    _.each(variables, <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> key = v.replace(<span class="regexp">/&#123; &#123;|&#125; &#125;/g</span>,<span class="string">""</span>);</span><br><span class="line">      <span class="keyword">var</span> value = <span class="keyword">typeof</span> context[key]===<span class="string">"string"</span>?(<span class="string">'"'</span>+context[key]+<span class="string">'"'</span>):context[key];</span><br><span class="line">      str = str.replace(v, value);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      result = <span class="built_in">eval</span>(str);</span><br><span class="line">      <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="keyword">return</span> options.fn(<span class="keyword">this</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> options.inverse(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(str,<span class="string">'--Handlerbars Helper "ex" deal with wrong expression!'</span>);</span><br><span class="line">      <span class="keyword">return</span> options.inverse(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<p>模板：</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="expression">&#123; &#123;<span class="begin-block">#ex </span><span class="string">"&#123; &#123;state&#125; &#125;==='submiting'"</span>&#125;</span><span class="xml"> &#125;</span><br><span class="line"><span class="tag">&lt;<span class="title">i</span> <span class="attribute">class</span>=<span class="value">"icon cross-danger"</span>&gt;</span>1<span class="tag">&lt;/<span class="title">i</span>&gt;</span></span><br><span class="line"></span><span class="expression">&#123; &#123;<span class="variable">else</span>&#125;</span><span class="xml"> &#125;</span><br><span class="line"><span class="tag">&lt;<span class="title">i</span> <span class="attribute">class</span>=<span class="value">"icon cross-success"</span>&gt;</span>2<span class="tag">&lt;/<span class="title">i</span>&gt;</span></span><br><span class="line"></span><span class="expression">&#123; &#123;<span class="end-block">/ex</span>&#125;</span><span class="xml"> &#125;</span></span><br></pre></td></tr></table></figure>
<p>先将整个逻辑表达式作为一个字符串传入，然后替换其中的变量值，最后用eval函数来解析表达式，同时增加异常处理。</p>
<h2 id="高级玩家：partial">高级玩家：partial</h2><p>比较推崇使用分页来实现组件化。分页跟helper一样需要先注册。在hbs模块中可以批量注册，比较简单。</p>
<p><code>hbs.registerPartials(__dirname + &#39;/views/partials&#39;);</code></p>
<h3 id="基础引用">基础引用</h3><p>用“&gt;”来引用模板，这种情况一般用来处理页头页尾这种简单的分页。后面可以传入参数。<br><code>{ {&gt; myPartial param} }</code></p>
<p>当使用块级表达式时，我们通常添加“#”，而分页是“&gt;”，所以块级分页使用“#&gt;”，这里表示如果layout分页不存在则显示块内的内容My Content。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#123;#&gt; layout &#125; &#125;</span><br><span class="line">  My Content</span><br><span class="line">&#123; &#123;/layout&#125; &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="动态分页">动态分页</h3><p>当然也可以用表达式来代替分页名称</p>
<p><code>{ {&gt; (whichPartial) } }</code></p>
<p>当分页中一部分代码是固定的，另一部分是变化的时候，可以在分页中添加“@partial-block”，这时当引用这个分页时，在内部编写代码将会填充到这个位置。</p>
<p>partial.hbs：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">亚里士朱德</span><br><span class="line">&#123; &#123;&gt; @partial-block &#125; &#125;</span><br></pre></td></tr></table></figure></p>
<p>模板：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#123;#&gt;partial&#125; &#125;</span><br><span class="line">https:yalishizhude.github.io</span><br><span class="line">&#123; &#123;/partial&#125; &#125;</span><br></pre></td></tr></table></figure></p>
<p>html页面：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">亚里士朱德</span><br><span class="line">https:yalishizhude<span class="class">.github</span><span class="class">.io</span></span><br></pre></td></tr></table></figure></p>
<h3 id="内联分页">内联分页</h3><p>当有多段代码需要填充到分页时,可以用如下方法。分页中内嵌分页变量，模板中通过内联分页的方式传入。</p>
<p>模板：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#123;#&gt; partial&#125; &#125;</span><br><span class="line">  &#123; &#123;#*inline <span class="string">"nav"</span>&#125; &#125;</span><br><span class="line">    亚里士朱德</span><br><span class="line">  &#123; &#123;/inline&#125; &#125;</span><br><span class="line">  &#123; &#123;#*inline <span class="string">"content"</span>&#125; &#125;</span><br><span class="line">    https://yalishizhude.github.io</span><br><span class="line">  &#123; &#123;/inline&#125; &#125;</span><br><span class="line">&#123; &#123;/partial&#125; &#125;</span><br></pre></td></tr></table></figure></p>
<p>partial.hbs：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"nav"</span>&gt;</span><br><span class="line">  &#123; &#123;&gt; nav&#125; &#125;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"content"</span>&gt;</span><br><span class="line">  &#123; &#123;&gt; content&#125; &#125;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>html页面：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">"nav"</span>&gt;</span><br><span class="line">    亚里士朱德</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">"content"</span>&gt;</span><br><span class="line">    https:<span class="comment">//yalishizhude.github.io</span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="大师级玩家：API">大师级玩家：API</h2><p>本文列举的只是handlebars中最重要和常用的功能，更多细碎的功能可以去查看<br><a href="http://handlebarsjs.com/reference.html" target="_blank" rel="external">官方API</a>。</p>
<h1 id="开头的问题">开头的问题</h1><blockquote>
<p>我想将导航条写成一个分页(partial)，导航条左边的文字标题是可以通过参数传递的，但是右边的内容可能是文字、图片其它元素，需要具体业务自定义实现。我又不想把html代码写在js中，所以希望在模板中将这段未知的模板代码填充到分页中进行展现。我在官网文档中找到了 NaN来实现此功能，但是本机实验一直解析报错。<br>解决过程：<br>    这个问题原因可能有两个，一是官方文档有错，二是本机环境的插件有问题（Express用hbs模块，该模块封装了handlebars引擎模块）。为了验证官方文档的正确性，我找到了一个在线handlebars解析器，输入文档中的代码时可以正确解析，那么只可能出现在hbs模块了。这时在github上找到hbs模块最新版本为4，查看本地版本为3，更新后果然可以正常解析了。</p>
</blockquote>
<h1 id="总结">总结</h1><p>handlebars让我们看到一个好的插件应该有的特征：</p>
<ul>
<li>可识别性。接口简单，使用方便，容易上手。</li>
<li>高可用性。自带常用一些功能（helper），不求多而求精。</li>
<li>可扩展性。复杂的业务逻辑，开发人员可以自定义helper去扩展和实现。</li>
</ul>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2016/01/22/handlebars/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[接口调试（下）——让接口服务器为前后端解耦]]></title>
      <link>http://yalishizhude.github.io/2016/01/06/api-test-3/</link>
      <guid>http://yalishizhude.github.io/2016/01/06/api-test-3/</guid>
      <pubDate>Tue, 05 Jan 2016 16:50:54 GMT</pubDate>
      <description>
      <![CDATA[<img src="/2016/01/06/api-test-3/api-server.png" alt="api-server.png" title="">]]>
      
      </description>
      <content:encoded><![CDATA[<img src="/2016/01/06/api-test-3/api-server.png" alt="api-server.png" title="">
<a id="more"></a>
<h1 id="写在前面">写在前面</h1><p>有半个月没有更新博客了，倒不是因为学习分享的积极性降低了。因为这半个月在做一件对于我来说很有意义的事情：写接口服务器。</p>
<h1 id="拿来主义or重复造轮子？">拿来主义or重复造轮子？</h1><p>在有限的时间和精力下，我还是比较推崇拿来主义的。所以我不似乎想验证自己的实力来重复造轮子，实在是看了很多接口文档服务器都不符合我的要求。其中比较优秀的是swagger，但是核心功能是java写的，要我打开eclipse再写java，我内心是拒绝的~项目上一直在使用的redmine，看上去比较清晰，但是编辑方式并不算友好，还有apidoc，都是只能支持API文档查阅和编辑的功能，功能太薄弱。</p>
<h1 id="原理">原理</h1><p>这次编写的接口的服务器的功能设计是想按照Martin Fowler在一篇文章中提到的 <strong>契约测试</strong> 的思想来实现的（虽然并没有完全实现）。契约测试的核心就是双方都保证按照约定好的接口进行开发。前端对请求参数进行验证，后端对返回结果进行验证。时间关系，这个功能我没有完全实现，但是作为替代，对于前端提供了mock服务器，提供假数据，对于后端可以发送请求，测试接口，只是接口的校验还不能完全自动化。这样的好处就是保证前后端分离，实现高效开发。</p>
<h1 id="技术">技术</h1><p>当我写这篇文章的时候，其实我内心是很欣慰的。因为：</p>
<h2 id="MEAN">MEAN</h2><p>使用了我一直很看好的MEAN技术。我看中MEAN的原因以及MEAN的优势可看我另一篇文章《MEAN杂谈》。总体感觉编写比较流畅，但是很多细节方面需要自己把控，需要按需添加第三方模块。</p>
<h2 id="前后端分离">前后端分离</h2><p>提供假数据和发送请求并管理API文档，为了实现这些功能，需要两个服务器配合。一个用来发送请求和管理文档，另一个负责提供mock数据。</p>
<h2 id="测试">测试</h2><p>终于开始在项目中编写测试代码了。当我看到调查中显示一半的开发人员不写单元测试的时候并不吃惊，但是忧心忡忡，因为自己的写的代码根本无法得到保障，只靠鼠标点一点根本不能高效地测试出bug。而且最大的问题是不具有回归性，当功能新增和修改之后，很容易出现之前修复的bug又复现的情况。关于代码测试，我在浏览器端测试代码写完后做一次总结。</p>
<h1 id="目录结构">目录结构</h1><p>和express默认结构相似。<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">-bin    启动文件</span><br><span class="line"></span>-<span class="ruby">-public    浏览器端的静态文件</span><br><span class="line"></span>  -<span class="ruby">-javascripts    业务脚本</span><br><span class="line"></span>  -<span class="ruby">-lib    第三方插件，包括脚本和样式文件，bower管理</span><br><span class="line"></span>  -<span class="ruby">-stylesheets    业务样式</span><br><span class="line"></span>-<span class="ruby">-routes    路由逻辑</span><br><span class="line"></span>-<span class="ruby">-test    测试代码</span><br><span class="line"></span>-<span class="ruby">-views    浏览器端模板,handlebars</span><br><span class="line"></span>app.js    加载中间件，根路径拦截</span><br><span class="line">readme.md    英文版自述文档</span><br><span class="line">readme_zh.md    中文版自述文档</span><br></pre></td></tr></table></figure></p>
<h1 id="下一步">下一步</h1><ul>
<li>国际化。加入i18n模块，让项目支持多种语言。</li>
<li>前端测试。目前的测试代码只覆盖了服务端，浏览器端没有进行测试，需要完善。</li>
<li>参数校验。前端请求参数校验和后端返回结果校验，当前后端和接口不一致时，服务器可以强行校验并报警，这才算真正的契约测试。</li>
<li>搜索功能。优先级排后，页面上可以对名称、路径搜索，能满足基本需求。<br>…</li>
</ul>
<h1 id="项目">项目</h1><p><a href="https://github.com/yalishizhude/api-document" target="_blank" rel="external">https://github.com/yalishizhude/api-document</a></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2016/01/06/api-test-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[MEAN杂谈]]></title>
      <link>http://yalishizhude.github.io/2015/12/24/mean-train/</link>
      <guid>http://yalishizhude.github.io/2015/12/24/mean-train/</guid>
      <pubDate>Thu, 24 Dec 2015 13:08:47 GMT</pubDate>
      <description>
      <![CDATA[<h1 id="前言">前言</h1><p>公司要求组织一次培训，面向所有技术人员，所以讲的东西比较杂浅，高手请绕道~</p>]]>
      
      </description>
      <content:encoded><![CDATA[<h1 id="前言">前言</h1><p>公司要求组织一次培训，面向所有技术人员，所以讲的东西比较杂浅，高手请绕道~</p>
<a id="more"></a>
<h1 id="初识">初识</h1><p>乍看之下以为这是一个js插件/框架，点进<a href="https://github.com/meanjs/mean" target="_blank" rel="external">github首页</a>一看吓了一跳，什么？4种技术融合在一起，了解它之前还得先学其它的，如此高的学习成本只能望而却步了~</p>
<h1 id="偶见">偶见</h1><p>直到有一天一位国外的工程师发邮件告诉我说其有一个<a href="https://blog.udemy.com/node-js-tutorial/" target="_blank" rel="external">不错node.js教程</a>希望通过我的博客介绍给大家。打开一看，天啊~一个教程写了一个长长的页面。。。怀着浮躁的心扫了一眼，觉得摘一下关键点翻译一下就算了。可正当我开始查找关键点的时候，发现教程讲的不仅仅是node.js，而是基于node.js的全栈开发技术，而且教程超级详细，图文结合，于是发了个愿，全文翻译了下来~</p>
<h1 id="why">why</h1><p>为什么mean.js引起我的强烈关注？原因如下：</p>
<ul>
<li><strong>前后端一种开发语言javascript。</strong>这对前端的同学是有利的，大大降低了学习成本。较之前的jsp、php前后端都是用的不同语言。</li>
<li><strong>前后端用一种数据类型JSON。</strong>前端json数据一般到后端都需要进行转译后，再通过sql到数据库。而mean从浏览器到数据库都是用的json格式的数据，即存即取即用，无需转化和复杂的sql语句。<br>这两种主要的特性就好比嬴政建立秦朝之后统一货币、度量单位，重要性可见一斑。</li>
<li><strong>可替换性。</strong>mean的核心是node.js，在使用node.js的前提下，expressjs可以被thinkjs、koajs替换，angularjs可以被vuejs、avalonjs替换，mongodb可以被mysql替换（不过JSON数据格式优势就没有了）。</li>
</ul>
<p>当然，世上没有银弹，每种技术都有自己的缺陷：mongodb不适于事务性较强的系统，angular框架较重不适合密集的dom操作…</p>
<h1 id="另类的mongodb">另类的mongodb</h1><p>和数据库打交道的往往是后端工程师和DBA，对于前端工程师来说，接触得就比较少了。虽然笔者有jsp开发经验，也是基于传统的mysql、oracle等关系型数据库，mongodb还是个新鲜玩意。所以结合官网文档以及个人写的demo来看，有以下几个印象：</p>
<ul>
<li>面向文档。关系数据库是由几个范式来定义的，把数据都转换成二维的结构，规定表中不可以有表。提升数据原子操作的同时牺牲了查询性能（查询一些数据的时候需要多表关联）。而mongodb是nosql数据库中的一种，用BSON(Binary JSON)的格式让数据可以嵌套，属于反范式设计。通过增加数据冗余性来提升查询性能，随之也带来了冗余数据的同步更新问题。<br>据一些资料显示，mongodb的查询性能适用于大数据，所以最近比较火。当然我觉得其取消了sql，使用JSON数据格式使得简化了操作，也是有一定优势的。</li>
</ul>
<h1 id="简捷的express">简捷的express</h1><pre><code><span class="tag">node</span> <span class="tag">i</span> <span class="tag">express</span> <span class="tag">-g</span>
<span class="tag">express</span> <span class="attr_selector">[option]</span> <span class="attr_selector">[dirctory]</span>
</code></pre><p>两条命令创建一个web应用，是不是很geek？第一个特点：快速</p>
<img src="/2015/12/24/mean-train/express-middleware.png" alt="express-middleware.png" title="">
<p>npm上随便一搜，20000+的模块。流行程度和插件支撑都是首屈一指。第二个特点：开放</p>
<img src="/2015/12/24/mean-train/express-project.png" alt="express-project.png" title="">
<p>再看工程结构，十几个文件，清晰小巧。第三个特点：简单</p>
<p>最近有个框架听说也比较火——thinkjs。下载试用了一下，可以用ES6开发，好处是号称解决了回调问题，坏处是学习成本和时间…顺便跟express对比了一下，总的来说，两边的框架结构差不多，主要都是路由、视图、中间件。thinkjs是比较崇拜模块化的，模块化之间耦合度很低，可以独立定义视图引擎等，这种设计在大型应用开发部署上可能会有优势吧。但是它有个短板啊~出生时间短，插件少得可怜，所以还是不敢轻易尝试。</p>
<h1 id="开放的node">开放的node</h1><p>如果要我主观地评价一下node.js，我只能说它就是前端工程师的翅膀，而npm为这双翅膀插上了丰富的羽毛。</p>
<p>它把传统的基于任务/请求的等待模式变成了事件驱动的非阻塞模式，大大提升了并发能力和吞吐量。说着说着想到了nginx，当然现在一些大企业看他们的架构都是nginx架设在node.js之上，真是强强结合。</p>
<p>当然node.js也有问题：单线程易崩溃（cluster利用多核、pm2部署）、回调可读性差（promise模式，q或async插件，ES6下更是自带promise）。只是瑕不掩瑜，如果配合外壳，亦可以开发混合桌面应用，例如hex。无需多说，看看cnode社区的热闹程度就知道了~</p>
<h1 id="强势的angular">强势的angular</h1><p><a href="http://yalishizhude.github.io/2015/09/10/angular-introduction/">angular介绍</a></p>
<p>看2015js调查中，angular使用者还不少，当然这种重框架也经常受人诟病，所以也有替代方案。轻量级的有vue.js（可惜不支持IE8），avalon.js（可惜社区不活跃，插件不多），还有基于jquery的数据绑定插件。可见MV*这种结构还是很受欢迎的。</p>
<h1 id="演示材料">演示材料</h1><p>基于express.js做的ppt<br><a href="https://github.com/yalishizhude/mean-representation" target="_blank" rel="external">MEAN技术分享</a></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/12/24/mean-train/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[【译】基于MEAN的全栈开发实例教程6（完）]]></title>
      <link>http://yalishizhude.github.io/2015/12/13/mean-6/</link>
      <guid>http://yalishizhude.github.io/2015/12/13/mean-6/</guid>
      <pubDate>Sun, 13 Dec 2015 08:13:20 GMT</pubDate>
      <description>
      <![CDATA[<blockquote>
<p>原文地址 <a href="https://blog.udemy.com/node-js-tutorial">https://blog.udemy.com/node-js-tutorial</a><br>感谢来自Udemy的Samantha来信分享</p>
</blockquote>
<h1 id="删除一个视频">删除一个视频</h1><p>在本节中，你将学习如何通过Monk删除文档。你也会再一次回顾你所学到的关于Express和Angular的知识。到这一节的结尾，所有的知识点都会像拼图一样放在一起。</p>]]>
      
      </description>
      <content:encoded><![CDATA[<blockquote>
<p>原文地址 <a href="https://blog.udemy.com/node-js-tutorial" target="_blank" rel="external">https://blog.udemy.com/node-js-tutorial</a><br>感谢来自Udemy的Samantha来信分享</p>
</blockquote>
<h1 id="删除一个视频">删除一个视频</h1><p>在本节中，你将学习如何通过Monk删除文档。你也会再一次回顾你所学到的关于Express和Angular的知识。到这一节的结尾，所有的知识点都会像拼图一样放在一起。</p>
<a id="more"></a>
<p>我们将在后面几步中实现这一功能。从服务器开始，我们将建立一个用于删除视频文档的接口。然后，我们将在列表中为每个视频前面添加一个删除链接。当用户点击这个链接，他们将被重定向到一个页面，在那里他们可以看到视频的细节。我们将在该页上有一个确认删除按钮。一旦他们点击这个按钮，页面将调用API端点，跳转带回的视频列表。</p>
<p>但在我们实现功能之前，我有一个建议。我认为你所学的到目前为止，应该能够独自实现这一功能。我想让你花10~15分钟来实现这个功能，作为一个练习，以检验你所学到的。然后，你可以回顾你的解决方案与我的对比，看看是否有任何改进的空间。在你开始之前，请注意：</p>
<ul>
<li>最好的方式是像我之前提到那样一步一步地完成。一旦你完成每一步，回到这里，回顾你的解决方案。</li>
<li>如果你忘记了Express的语法或者Angular的接口，不要担心。这是学习一个新的框架时的自然现象。只需要浏览源代码，查看我们早期的类似例子就好。</li>
<li>如果你被卡住了，谷歌一下。</li>
</ul>
<h2 id="第1步：构建一个API端点">第1步：构建一个API端点</h2><p>打开 <strong>routes&gt;videos.js</strong> 然后添加一个新的路由：</p>
<pre><code>router.<span class="keyword">delete</span>(<span class="string">'/:id'</span>, <span class="function"><span class="keyword">function</span><span class="params">(req, res)</span></span>{
    <span class="keyword">var</span> collection = db.<span class="keyword">get</span>(<span class="string">'videos'</span>);
    collection.remove({ _id: req.params.id }, <span class="function"><span class="keyword">function</span><span class="params">(err, video)</span></span>{
        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;
        res.json(video);
    });
});
</code></pre><p>这些代码和之前的差不多，唯一的区别是我们使用了 <strong>router.delete</strong> 来为HTTP DELETE请求注册一个路由处理器。</p>
<p>同时注意我们这里使用了视频文档对象的 <strong>remove</strong> 方法。第1个参数你可能已经猜到了，正是一个标准对象。</p>
<h2 id="第2步：构建删除页面">第2步：构建删除页面</h2><p>回到 <strong>partials &gt; home.html</strong>，在每一个视频链接前添加一个删除链接：</p>
<pre><code><span class="tag">&lt;<span class="title">li</span> <span class="attribute">ng-repeat</span>=<span class="value">'video in videos'</span>&gt;</span>
    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/#/video/"</span>&gt;</span>
        <span class="comment"></span>
    <span class="tag">&lt;/<span class="title">a</span>&gt;</span>
    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/#/video/delete/"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">i</span> <span class="attribute">class</span>=<span class="value">"glyphicon glyphicon-remove"</span>&gt;</span><span class="tag">&lt;/<span class="title">i</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">a</span>&gt;</span>
<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
</code></pre><p>在这里<i>用来渲染一个图标。glyphicon和glyphicon-remove都是Bootstrap用来绘制图标的类。Bootstrap包括几十个用来构建应用的现代图标。为了看到所有图标的列表，可以去<a href="http://getbootstrap.com/components/" target="_blank" rel="external">这里</a>。绘制一个图标，你需要使用两个CSS类。一是glyphicon（所有图标的基础类），另一个就是你使用的类（glyphicon-remove）。在Bootstrap文档中，你可以在每个图标下面看到这个CSS类。</i></p>
<p>点击图标页面将跳转到 <strong>/#/video/delete/</strong>。让我们创建一个试图并为它注册一个路由。</p>
<p>在 <strong>partials</strong> 文件夹中添加一个叫做 <strong>video-delete.html</strong> 的新文件。文件中写下如下代码：</p>
<pre><code><span class="tag">&lt;<span class="title">h1</span>&gt;</span>Delete Video<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
<span class="tag">&lt;<span class="title">p</span>&gt;</span>
    Are you sure you want to delete this video?
<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;<span class="title">ul</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span>Title: <span class="comment"></span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span>Description: <span class="comment"></span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"button"</span> <span class="attribute">value</span>=<span class="value">"Yes, Delete"</span> <span class="attribute">class</span>=<span class="value">"btn btn-danger"</span> <span class="attribute">ng-click</span>=<span class="value">"delete()"</span> /&gt;</span>
<span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"btn btn-default"</span> <span class="attribute">href</span>=<span class="value">"/#/"</span>&gt;</span>No, Go Back<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
</code></pre><p>这里并没有什么特别的。用UL和LI来展示视频的不同属性。在真实的应用中，你可能需要一个更加复杂的标签来实现。</p>
<p>这里注意一下，我为删除按钮添加了一个 <strong>btn-danger</strong> 类来让它变成红色，为返回按钮添加了 <strong>btn-default</strong> 让它变成白色。</p>
<p>当我们完成这些步骤之后，页面看起来是这个样子的：</p>

<p>接下来，我们需要为视图编写一个控制器。在控制器中，我们将调用API来获取视频的详细信息并加载到页面上。当用户点击删除按钮我们将调用API来删除这个视频。</p>
<p>打开 <strong>Vidzy.js</strong> 并创建这个控制器：</p>
<pre><code>app.controller(<span class="string">'DeleteVideoCtrl'</span>, [<span class="string">'$scope'</span>, <span class="string">'$resource'</span>, <span class="string">'$location'</span>, <span class="string">'$routeParams'</span>,
    <span class="keyword">function</span>(<span class="variable">$scope</span>, <span class="variable">$resource</span>, <span class="variable">$location</span>, <span class="variable">$routeParams</span>){
        var Videos = <span class="variable">$resource</span>(<span class="string">'/api/videos/:id'</span>);
        Videos.get({ id: <span class="variable">$routeParams</span>.id }, function(video){
            <span class="variable">$scope</span>.video = video;
        })
        <span class="variable">$scope</span>.delete = function(){
            Videos.delete({ id: <span class="variable">$routeParams</span>.id }, function(video){
                <span class="variable">$location</span>.path(<span class="string">'/'</span>);
            });
        }
    }]);
</code></pre><p>最后我们创建一个路由来注册视图和控制器。添加路由到应用的配置中：</p>
<pre><code><span class="class">.when</span>(<span class="string">'/video/delete/:id'</span>, {
    <span class="attribute">templateUrl</span>: <span class="string">'partials/video-delete.html'</span>,
    <span class="attribute">controller</span>: <span class="string">'DeleteVideoCtrl'</span>
})
</code></pre><p>现在已经完成了。测试一下这个删除功能。回到浏览器并且刷新首页。点击删除图标。删除一个视频。这个视频将被删除然后调回首页。</p>
<h1 id="总结">总结</h1><p>如果你按照教程做到这一步了，你已经证明了你对学习新事物充满热情。这非常不错~我希望你喜欢这个教程并且能学习到Node，Express，Angular和MongoDB的基础知识。</p>
<ul>
<li>你使用了Node，Express，Angular和MongoDB成功地建立了一个完整的CRUD应用。</li>
<li>你使用了robomongo创建和填充数据库视频文档。</li>
<li>你使用了Monk在Mongo中来添加、更新、删除和查询视频文档。</li>
<li>你用Express创造了一个RESTful API：GET，POST，PUT，DELETE。</li>
<li>你了解了Node的模块系统，并使用了require方法。</li>
<li>你了解了Node的软件包管理器（NPM），用它来安装Node模块。</li>
<li>你用Angular度来构建一个单页应用程序。</li>
<li>你学到了关于Angular的依赖性管理。</li>
<li>你使用了Angular的内置服务，如$scope、$resource、$location和$routeparams。</li>
<li>你用Angular指令（ng-model, ng-click）将行为添加到DOM元素。</li>
<li>你熟悉了使用Bootstrap的类来给你的表单和按钮添加漂亮、流行的外观。</li>
</ul>
<p>下一步是什么？Node不仅仅是你目前所学的这些，这就是为什么我计划创建一个全面的课程，来教你使用Node做许多令人惊奇的事情。我将重点教会你：</p>
<ul>
<li>认证和授权</li>
<li>预防常见安全攻击</li>
<li>数据验证</li>
<li>缓存</li>
<li>实时应用</li>
<li>更多…</li>
</ul>
<p>如果你很喜欢我的教学风格并且想从我这里学习更多，欢迎订阅我的<a href="http://programmingwithmosh.com/node-js-course-coming-soon/" target="_blank" rel="external">时事通讯</a>。一旦我的课程准备好了将发送通知给你。</p>
<h1 id="源代码">源代码</h1><p>教程中提到的代码已上传到github：<br><a href="https://github.com/yalishizhude/Vidzy" target="_blank" rel="external">https://github.com/yalishizhude/Vidzy</a></p>
<p><em>如果觉得阅读这篇文章有收获，不妨点个赞吧^_^</em></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/12/13/mean-6/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[所谓全栈——《Web全栈工程师的自我修养》读书笔记]]></title>
      <link>http://yalishizhude.github.io/2015/12/12/fullstack-self-improvement/</link>
      <guid>http://yalishizhude.github.io/2015/12/12/fullstack-self-improvement/</guid>
      <pubDate>Sat, 12 Dec 2015 13:05:41 GMT</pubDate>
      <description>
      <![CDATA[<h1 id="简介">简介</h1><p>为什么我会选择读这本书？两个原因，一是本身对于全栈的技术很感兴趣。倒并不是认为全栈工程师懂的东西多就牛逼哄哄，而是在当前这种前后端分离的大势之下，前后端开发人员都越来越聚焦于自己的领域，而缺乏对整站或者整个系统的了解，以全栈的视野更容易了解技术的全貌。二是因为书评分还不错，作者是腾讯社交用户体验设计部高级UI工程师余果。</p>
<p>这本书是由作者从连载专栏中整理出来的。按照作者的定义是“轻松的技术杂文集”。读完两遍之后的整体感觉是：提升视野，拓展思维。</p>]]>
      
      </description>
      <content:encoded><![CDATA[<h1 id="简介">简介</h1><p>为什么我会选择读这本书？两个原因，一是本身对于全栈的技术很感兴趣。倒并不是认为全栈工程师懂的东西多就牛逼哄哄，而是在当前这种前后端分离的大势之下，前后端开发人员都越来越聚焦于自己的领域，而缺乏对整站或者整个系统的了解，以全栈的视野更容易了解技术的全貌。二是因为书评分还不错，作者是腾讯社交用户体验设计部高级UI工程师余果。</p>
<p>这本书是由作者从连载专栏中整理出来的。按照作者的定义是“轻松的技术杂文集”。读完两遍之后的整体感觉是：提升视野，拓展思维。</p>
<a id="more"></a>
<h1 id="什么是全栈工程师">什么是全栈工程师</h1><p><em>一专多长。工程师首先有一个精专的方向，在这个方向上足够精通之后（高级工程师级别），以此为突破点去学习更多的知识，增加自己的长处。</em></p>
<p>在技术上，我一直提倡的是十字型的成长方式，即从水平和垂直两个方向提升自己的能力。比如我擅长的是javascript，我会去学习jquery、angular等这些有用的js库，这属于垂直方向。同时我继续对node.js、mongodb这类后端技术进行学习，这属于水平方向。<br>虽然我觉得这是一个好的学习方法，但是并不能作为衡量一个全栈工程师的标准。全栈工程师应该是在前后端都有一定专业知识，能独立开发的程序员，有没有专精的方向并不重要。即使像下面的被称作“野生程序员”的开发者，能力模型每项都得60分就应该算合格。</p>
<p>对于那些达不到一专多长，虽然知识面比较广，但是各方面都一知半解的开发者，作者给了一个特殊的称号：野生程序员。</p>
<img src="/2015/12/12/fullstack-self-improvement/skill.png" alt="skill.png" title="">
<p>这个能力模型竟然把JQuery单独列出来了，AngularJS、Zepto.js、Vue.js…都表示很失望~</p>
<p><em>老板雇佣一个员工，不是因为他能写程序，而是因为他能帮助自己赚钱。赚钱的方法有两种：减少成本，或者增加收入。程序员如果能加快内部系统的运行效率，让产品制作流程更加顺畅，就是减少成本。如果能让用户更容易一地购买产品，或者提高服务质量吸引更多用户，就能增加收入。</em></p>
<p>嗯，这一点我觉得很重要，使用技术知其然还要知其所以然~<br>为什么要用JQuery？它的选择器很强大，操作dom方便。<br>为什么要用Angular？它的双向数据绑定不再需要选择器，对于CRUD操作很有优势。<br>为什么要用Vue.js？它实现双向数据绑定的同时又是一个轻量级的框架。<br>技术只是手段，最合适的技术即是最好的技术。不迷信于某个技术，本末倒置，而是为了解决某类问题而去选择最低成本的技术，这才是一个成熟的开发者应有的思维。</p>
<h1 id="全栈工程师涉及的一些重要技术">全栈工程师涉及的一些重要技术</h1><h2 id="HTTP">HTTP</h2><p><em>前端需要关注</em></p>
<ul>
<li>发出的请求列表</li>
<li>每个请求的开始时间</li>
<li>每个请求从刚开始到结束花费的时间</li>
<li>每个请求的类型</li>
<li>每个请求的状态吗</li>
<li>每个请求产生的流量消耗</li>
<li>每个请求gzip压缩前的体积，以及在本地gzip解压后的体积</li>
</ul>
<p>这里推荐一本书《图解HTTP》，通俗易懂。</p>
<p><em>优化策略</em></p>
<ul>
<li>尽量减少同一域下的HTTP请求数。域名散列等</li>
<li>尽量减少每一个资源的体积。压缩合并等</li>
</ul>
<p>HTTP2.0下这种优化就变得没意义了，不过预估HTTP1.1还将用10年。</p>
<p><em>后端需要关注</em></p>
<ul>
<li>提高服务器的请求处理能力。利用nginx等服务器做负载均衡等</li>
<li>预防DDoS攻击。生成静态页，利用cdn等</li>
</ul>
<p><em>BigPipe是Facebook公司科学家Changhao Jiang发明的一种非阻塞式模型，这种模型能解决两个问题：</em></p>
<ul>
<li>HTTP3次握手消耗的时间</li>
<li>现有阻塞模型中，服务器计算生成页面需要时间，等服务器完全生成好整个页面，才开始网络传输，网络传输也需要时间。</li>
</ul>
<h2 id="缓存">缓存</h2><h3 id="服务器缓存">服务器缓存</h3><ul>
<li>使用数据库缓存和缓存工具，如memcached，注意提高缓存的命中率。</li>
<li>再加一层文件缓存。作为内存缓存的补充，查找优先级：内存缓存 ——&gt; 文件缓存 ——&gt; 数据库</li>
<li>页面静态化</li>
</ul>
<h3 id="浏览器缓存">浏览器缓存</h3><ul>
<li>Expires</li>
<li>Last-Modified</li>
<li>Cache-Control</li>
</ul>
<h2 id="持续集成">持续集成</h2><p><em>版本控制</em></p>
<ul>
<li>SVN。适合企业内部使用</li>
<li>Git。多用于开源软件</li>
</ul>
<p><em>最佳实践</em></p>
<ul>
<li>鼓励频繁的提交</li>
<li>确定分支流程</li>
<li>定义主干原则，并且坚守它</li>
<li>不要把逻辑的修改和代码格式化操作混在一起</li>
<li>不相干的代码分开提交</li>
<li>保持工作代码库的“干净”</li>
</ul>
<p><em>根据Semver的规范，版本号用小数点分割为三个数字。比如v3.2.1中3是主要版本号，2是次要版本号，1是补丁。</em></p>
<ul>
<li>主要版本号：有API变更导致不兼容旧版本的时候使用</li>
<li>次要版本号：新增功能，但是向前兼容的情况下使用</li>
<li>补丁：修复向前兼容的bug时使用</li>
</ul>
<h1 id="全栈工程师的成长途径">全栈工程师的成长途径</h1><p><em>作品集的积累。程序员和设计师的作品集往往是自己的在线个人网站。对于程序员来说，成本最低的一种作品展示方式就是把自己的代码发布到GitHub上。</em></p>
<p><em>初级前端知识体系</em></p>
<ul>
<li>对浏览器兼容性的了解</li>
<li>对HTML/CSS/Javascript语法和原理的理解</li>
<li>对编辑器和插件的熟悉程度</li>
<li>对调试工具的了解程度</li>
<li>对版本管理软件的熟悉和应用经验</li>
<li>对前端库/框架的使用</li>
<li>标准/规范<br><em>中级前端知识体系</em></li>
<li>对代码质量、代码规范的理解</li>
<li>对Javascript单元测试的熟悉</li>
<li>对性能优化的应用和理解</li>
<li>对SEO的应用和理解</li>
<li>代码部署</li>
<li>移动Web<br><em>高级前端知识体系</em></li>
<li>代码架构</li>
<li>安全</li>
<li>对自动化测试的理解</li>
</ul>
<p><em>虽然VPS对于个人开发者来说比较昂贵，但我还是推荐全栈工程师买一台VPS，自己玩一玩。理由如下：</em></p>
<ul>
<li>对于网站的全貌有所了解</li>
<li>服务器稳定</li>
<li>可以部署自己的环境</li>
<li>可以学习Linux</li>
<li>帮助理解HTTP</li>
</ul>
<p><em>VPS选择</em></p>
<ul>
<li>内存一般是主要瓶颈，建议选择最少512MB</li>
<li>CPU是相对没那么重要的性能指标</li>
<li>硬盘的大小和读写速度是关键</li>
<li>服务商的客户服务</li>
</ul>
<p>自己搭建网站是个很费时费力的事，途中会碰到很多问题，确实可以学到很多东西，适合有精力有兴趣的同学。</p>
<h1 id="全栈工程师扩展技能">全栈工程师扩展技能</h1><h2 id="设计模式">设计模式</h2><ul>
<li>创建型模式。用来创建对象的模式，它对实例化的过程进行了抽象。如单例模式</li>
<li>结构型模式。主要解决类、对象、模块之间的耦合关系。如适配器模式</li>
<li>行为型模式。用来识别对象之间的常用脚力模式并加以实现。如观察者模式</li>
</ul>
<h2 id="设计原则">设计原则</h2><ul>
<li>Don’t Repeat Yourself</li>
<li>惯例优于设置。开发人员仅需规定应用中不符约定的部分。</li>
<li>Keep it simple，stupid</li>
<li>最少知道原则。减少耦合。</li>
</ul>
<p>推荐一本书《大话设计模式》</p>
<h2 id="提高工作效率方式">提高工作效率方式</h2><ul>
<li>阅读英文资料。英文的技术资料更多。Google的搜索能力非常强。英语世界的语言风格比较严谨</li>
<li>时间管理四象限。如果您平时没有做重要的事情，就会发现自己常常在做紧急的事情。</li>
<li>消除重复工作。使用工具来无缝衔接已有流程</li>
<li>给自己留出不被打扰的时间</li>
<li>番茄工作法</li>
<li>跨界思考</li>
<li>纸上头脑风暴</li>
<li>使用版本控制工具和构建系统</li>
</ul>
<p><em>拿工作时长来拼，这还是体力劳动时代打工者的心态在作祟。</em></p>
<h2 id="架构模式">架构模式</h2><ul>
<li>MVC模式（Model-View-Controller）是最有名的一种架构模式。</li>
</ul>
<p>前端有一种MVVM的模式，熟悉Angular的人都知道~</p>
<h2 id="学习设计">学习设计</h2><p><em>设计的四大基本理论：</em></p>
<ul>
<li>亲密。关系亲密的元素要放在一起，关系疏远的元素则要分开。位置的亲密性直接表现出意义的相关性。</li>
<li>对其。</li>
<li>重复。视觉上使用重复的图形和元素、线条、颜色等。</li>
<li>对比。如果两个元素不一样，就让它完全不一样，产生视觉冲击力。</li>
</ul>
<p><em>设计工具</em></p>
<ul>
<li>Axure</li>
<li>Sketch</li>
<li>Quartz Composer</li>
</ul>
<h2 id="学习管理">学习管理</h2><ul>
<li>在项目最开始做出合理的时间评估</li>
<li>根据人员的强项来安排任务</li>
<li>唤起团队对项目成功的渴望</li>
<li>保障沟通。理想沟通频率每周至少两次。</li>
</ul>
<h1 id="阅后即焚的彩蛋">阅后即焚的彩蛋</h1><p><strong>最后感谢原书作者余果。为了感谢各位读者，由我手批版（我做了点笔记的二手书）的《Web全栈工程师的自我修养》将转赠给想看此书的读者。领取方式可参看我的新浪微博：
</strong><br><strong><a href="http://dwz.cn/2l3rYK" target="_blank" rel="external">http://dwz.cn/2l3rYK</a></strong></p>
<p><em>如果觉得阅读这篇文章有收获，不妨点个赞吧^_^</em></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/12/12/fullstack-self-improvement/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Duang~简单实用的angular滚动列表特效(移动端)]]></title>
      <link>http://yalishizhude.github.io/2015/12/02/angular-scrollpin/</link>
      <guid>http://yalishizhude.github.io/2015/12/02/angular-scrollpin/</guid>
      <pubDate>Wed, 02 Dec 2015 15:22:11 GMT</pubDate>
      <description>
      <![CDATA[<img src="/2015/12/02/angular-scrollpin/scrollpin.gif" alt="scrollpin.gif" title="">]]>
      
      </description>
      <content:encoded><![CDATA[<img src="/2015/12/02/angular-scrollpin/scrollpin.gif" alt="scrollpin.gif" title="">
<a id="more"></a>
<h1 id="故事起因">故事起因</h1><p>在微信端开发的一个答题页面，产品部突发奇想说要优化，做成滚动时固定，然后可以被下一个元素顶上去的效果（具体见上图，卡顿是录屏软件造成的，不是代码原因）。老大说jquery有个<a href="http://www.bootcss.com/p/jquery.pin/" target="_blank" rel="external">pin的插件</a>实现了类似效果，可以看一下。</p>
<p>打开网站一看，貌似是我要的效果，仔细一琢磨，原来是用浮动脱离了文档流，然后滚动时改为固定定位。浮动似魔鬼，而且也顶不起来，只能另辟蹊径了~</p>
<h1 id="替代插件">替代插件</h1><p>优化需求一般对于功能需求来说优先级肯定是最后的，所以先实现功能：当题干太长时把题目与固定住。<br>为解燃眉之急，由于之前一直使用的也是angular-ui，所以采用了angular-ui下的轻量级指令scrollfix，一时翻不了墙，给不了网址。该插件类似jquery.pin的效果，能满足基本使用，不过就是实现不了“顶起”的效果。</p>
<h1 id="重整思路">重整思路</h1><p>最近终于抽时间把页面性能、代码结构优化之后，剩下的就是这个特效的优化了。</p>
<p>整个操作思路还是比较简单的，当题目滚动出屏幕时题目描述继续钉在顶部而剩下的可以继续滚动，滚动到下一题题目与当前固定题目描述接触时上移，直到下一题题目描述固定在顶部。其中有两个核心问题：</p>
<p><strong>如何让题目描述平滑地固定在顶部？这里我想到了两种方法：一是用<code>position:fixed;</code>，但是这脱离了标准文档流，会导致后面元素的样式错乱，所以想到了另一个方法：伪固定，用<code>position:relative</code>，通过该表<code>top</code>值来实现“固定”效果，这是个好方法吗？显然不是，要实时计算多个元素的top值，消耗性能，容易出错。回到第一个方法，为了解决其它元素样式错乱的问题有个另外的解决方法：元素占位。</strong></p>
<p><strong>一开始就直接让题目描述脱离文档流，并遮住占位元素，然后用<code>fixed</code>固定和移出。</strong></p>
<p><strong>如何让下一题将当前题顶出？不管用<code>position:relative;</code>还是<code>position:fixed</code>，反正都是通过计算滚动位移、元素偏移值、元素高度来设置<code>top</code>值让当前题上移，出现“顶起”的效果。</strong></p>
<h2 id="具体实现">具体实现</h2><p>部分代码如下：</p>
<p>html部分，pin样式让div脱离文档流，name样式div为占位元素，使用了自定义的scrollpin指令，属性值为元素高度。</p>
<pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"title"</span> <span class="attribute">ng-repeat-start</span>=<span class="value">"sub in subjects"</span>&gt;</span>
    <span class="comment">&lt;!-- 滚动效果元素 --&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"pin"</span> <span class="attribute">ng-bind</span>=<span class="value">"sub.name"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="comment">&lt;!-- 占位元素，避免塌陷，scroll-child属性为当前元素高度--&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"name"</span> <span class="attribute">ng-bind</span>=<span class="value">"sub.name"</span> <span class="attribute">scrollpin</span>=<span class="value">"42"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"content"</span> <span class="attribute">ng-repeat-end</span> <span class="attribute">ng-bind</span>=<span class="value">"sub.content"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</code></pre><p>指令的逻辑比较简单，绑定scroll事件之后判断滚动位移，动态改变<code>position</code>属性值和<code>top</code>值。</p>
<pre><code>.directive(<span class="string">'scrollpin'</span>, <span class="keyword">function</span>(<span class="variable">$window</span>){
    return {
        link: function(scope, element, attrs){
            angular.element(<span class="variable">$window</span>).on(<span class="string">'scroll'</span>, onScroll);
            function onScroll(){
                var offset = <span class="variable">$window</span>.pageYOffset;
                var offsetTop = element[<span class="number">0</span>].offsetTop;
                var before = element[<span class="number">0</span>].previousElementSibling;
                if(offsetTop&lt;offset) {
                    var move = parseInt(attrs.scrollpin||<span class="number">0</span>)+offsetTop-offset;
                    before.style.position = <span class="string">'fixed'</span>;
                    if(move&lt;<span class="number">0</span>&amp;&amp;-move&lt;parseInt(attrs.scrollpin)){
                        before.style.top = move+<span class="string">'px'</span>;
                    } else {
                        before.style.top = <span class="string">'0'</span>;
                    }
                } else {
                    before.style.position = <span class="string">'absolute'</span>;
                    before.style.top = <span class="string">''</span>;
                }
            }
        }
    };
})
</code></pre><p>完整代码：<a href="https://github.com/yalishizhude/angular-scrollpin" target="_blank" rel="external">https://github.com/yalishizhude/angular-scrollpin</a><br>欢迎star和pull~</p>
<p><em>如果觉得阅读这篇文章有收获，不妨点个赞吧^_^</em></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/12/02/angular-scrollpin/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[【译】基于MEAN的全栈开发实例教程5：实现编辑功能]]></title>
      <link>http://yalishizhude.github.io/2015/11/30/mean-5/</link>
      <guid>http://yalishizhude.github.io/2015/11/30/mean-5/</guid>
      <pubDate>Mon, 30 Nov 2015 14:43:00 GMT</pubDate>
      <description>
      <![CDATA[<blockquote>
<p>原文地址 <a href="https://blog.udemy.com/node-js-tutorial">https://blog.udemy.com/node-js-tutorial</a><br>感谢来自Udemy的Samantha来信分享</p>
</blockquote>
<h1 id="编辑一个视频">编辑一个视频</h1><p>在这一节中，你将看见另一个API端点，Angular视图，控制器和路由。</p>
<p>我们将以类似的方式从这一部分到最后一个部分。首先，我们将建立两个API端点：一个用于通过ID获取视频，另一个用于更新视频。然后，我们将添加一个链接到主页中的每个视频。当用户点击这个链接，他们将被重定向到一个由视频详情填充的表单。当他们点击保存，更改将被保存然后返回到主页。</p>]]>
      
      </description>
      <content:encoded><![CDATA[<blockquote>
<p>原文地址 <a href="https://blog.udemy.com/node-js-tutorial" target="_blank" rel="external">https://blog.udemy.com/node-js-tutorial</a><br>感谢来自Udemy的Samantha来信分享</p>
</blockquote>
<h1 id="编辑一个视频">编辑一个视频</h1><p>在这一节中，你将看见另一个API端点，Angular视图，控制器和路由。</p>
<p>我们将以类似的方式从这一部分到最后一个部分。首先，我们将建立两个API端点：一个用于通过ID获取视频，另一个用于更新视频。然后，我们将添加一个链接到主页中的每个视频。当用户点击这个链接，他们将被重定向到一个由视频详情填充的表单。当他们点击保存，更改将被保存然后返回到主页。</p>
<a id="more"></a>
<h2 id="第1步：创建API端点">第1步：创建API端点</h2><p>下面这一步很熟悉，创建两个新的路由：</p>
<pre><code>GET /api/videos/{<span class="property">id</span>}
PUT /api/videos/{<span class="property">id</span>}
</code></pre><p>然后打开 <strong>routes&gt;videos.js</strong> 添加以下路由信息：</p>
<pre><code>router.<span class="keyword">get</span>(<span class="string">'/:id'</span>, <span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> </span>{
    <span class="keyword">var</span> collection = db.<span class="keyword">get</span>(<span class="string">'videos'</span>);
    collection.findOne({ _id: req.params.id }, <span class="function"><span class="keyword">function</span><span class="params">(err, video)</span></span>{
        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;
        res.json(video);
    });
});
</code></pre><p>注意这里有一个路由参数，在一个冒号后面声明(:id)。你可以访问这个参数值通过 <strong>req.params.id</strong>。</p>
<p>除此之外，其余的这条路由配置是类似于你以前见过的。唯一的区别是，我们使用集合中的findOne方法来返回一个对象。对该方法的第一个参数是标准对象。因此，我们通过_id等于req.params.id来寻找一个文档。</p>
<p>创建另一个路由：</p>
<pre><code>router.put(<span class="string">'/:id'</span>, <span class="function"><span class="keyword">function</span><span class="params">(req, res)</span></span>{
    <span class="keyword">var</span> collection = db.<span class="keyword">get</span>(<span class="string">'videos'</span>);
    collection.update({
        _id: req.params.id
    },
    {
        title: req.body.title,
        description: req.body.description
    }, <span class="function"><span class="keyword">function</span><span class="params">(err, video)</span></span>{
        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;
        res.json(video);
    });
});
</code></pre><p>注意我们通过 <strong>router.put</strong> 来定义这个路由。当这个端点上有HTTP PUT请求时这个处理器将会被调用。</p>
<p>通过集合中的 <strong>update</strong> 方法来更新一个文档。第一个参数是一个标准对象。只更新 <strong>_id</strong> 和 <strong>req.params.id</strong><br>匹配的文档。第二个参数代表了需要更新的值。</p>
<p>这种rest接口其实非常简单。</p>
<h2 id="第2步：创建一个编辑页面">第2步：创建一个编辑页面</h2><p>首先我们需要为主页上的每个视频添加一个链接。打开 <strong>partials&gt;home.html</strong> 如下改变LI标签。</p>
<pre><code><span class="tag">&lt;<span class="title">li</span> <span class="attribute">ng-repeat</span>=<span class="value">'video in videos'</span>&gt;</span>
    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/#/video/"</span>&gt;</span>
        <span class="comment"></span>
    <span class="tag">&lt;/<span class="title">a</span>&gt;</span>
<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
</code></pre><p>Angular绑定表达式通过视频ID来渲染动态URL。注意这个URL带有前缀<code>/#</code>来兼容老的浏览器。</p>
<p>现在我们需要通过一个带有表单的视图来编辑一个视频。现在我们已经有了一个带有表单的视图。所以我们我考虑重用它。</p>
<p>在 <strong>vidzy.js</strong> 中添加一个新的路由：</p>
<pre><code><span class="class">.when</span>(<span class="string">'/video/:id'</span>, {
    <span class="attribute">templateUrl</span>: <span class="string">'partials/video-form.html'</span>
})
</code></pre><p>由于我们还没有创建控制器，所以在路由中还不能设置控制器。让我们来回顾一下我们的工作。</p>
<p>回到浏览器主页然后刷新页面。每个视频现在都由一个超链接替代。点击一个视频。你将看见一个空的表单。</p>
<p>下一步我们为表单添加行为：填充表单数据和处理点击保存按钮事件。</p>
<h2 id="第3步：实现控制器">第3步：实现控制器</h2><p>现在我们有了2个选择。我们可以创建一个新的控制器，如editvideoctrl，或使用现有的控制器（addvideoctrl）。你认为最好的解决办法是什么？答案是：没有最好的解决办法。需要看情况而定。如果2个案例（添加和编辑）有很多相似之处，则创建一个控制器来处理这两种情况。另一方面，如果两个场景有很大的不同，你会写很多丑陋的条件语句在一个控制器中。这种情况下，最好把它们分为2个不同的控制器。</p>
<p>在写这一步的教程之前，我开始重复使用相同的控制器但是我对最终结果感到不满意。所以，我决定把它们拆分成2个不同的控制器。</p>
<p>在 <strong>vidzy.js</strong>中，如下创建一个新的控制器：</p>
<pre><code>app.controller(<span class="string">'EditVideoCtrl'</span>, [<span class="string">'$scope'</span>, <span class="string">'$resource'</span>, <span class="string">'$location'</span>, <span class="string">'$routeParams'</span>,
<span class="keyword">function</span>(<span class="variable">$scope</span>, <span class="variable">$resource</span>, <span class="variable">$location</span>, <span class="variable">$routeParams</span>){   
    var Videos = <span class="variable">$resource</span>(<span class="string">'/api/videos/:id'</span>, { id: <span class="string">'@_id'</span> }, {
        update: { method: <span class="string">'PUT'</span> }
    });
    Videos.get({ id: <span class="variable">$routeParams</span>.id }, function(video){
        <span class="variable">$scope</span>.video = video;
    });
    <span class="variable">$scope</span>.save = function(){
        Videos.update(<span class="variable">$scope</span>.video, function(){
            <span class="variable">$location</span>.path(<span class="string">'/'</span>);
        });
    };
}]);
</code></pre><p>让我解释一下这里发生了什么。</p>
<p>首先，这个控制器，并不像我们的 <strong>AddVideoCtrl</strong> 有4个依赖。这里我们有一个额外的依赖： <strong>$routeParams</strong> 用来访问路由参数。这种情况下，编辑中使用的视频ID将成为路由参数。</p>
<p>在这个控制器内，首先我们使用 <strong>$resource</strong> 服务来获取一个对象通过和API端点交互。但这一次，我们通过另一种方式来使用 <strong>$resource</strong>。</p>
<pre><code>var Videos = <span class="variable">$resource</span>(<span class="string">'/api/videos/:id'</span>, { id: <span class="string">'@_id'</span> }, {
     update: { method: <span class="string">'PUT'</span> }
});
</code></pre><p>传输给端点的第一个参数是URL。这里我们有一个冒号声明的参数(:id)。因为我们在这一节中之前创建的端点都是带有路由参数的，所以我们使用参数化的路由。</p>
<pre><code>GET /api/videos/:<span class="property">id</span>
PUT /api/videos/:<span class="property">id</span>
</code></pre><p>这个方法的第2个参数是1个对象，为路由参数 <strong>:id</strong> 提供默认值。</p>
<pre><code>{ <span class="attribute">id</span>: <span class="string">'@_id'</span> }
</code></pre><p>这里 ‘@_id’ 告诉Angular在请求对象中查找一个叫做 _id 的属性。所以当我们发送一个PUT请求 <strong>/api/videos/:id</strong>，Angular将使用视频对象的_id属性来设置路由中的:id参数。</p>
<p><strong>$resource</strong> 方法第3个参数用来扩展 <strong>$resource</strong> 服务。</p>
<pre><code>{
update: { <span class="keyword">method</span>: '<span class="type">PUT</span>' }
}
</code></pre><p>只有Angular的开发者才知道，在某些情况下，默认你不能用$resource服务发送HTTP PUT请求，你需要扩展它通过一个使用HTTP UPT的 <strong>update</strong> 方法。</p>
<p>下面我们通过给定的ID使用 <strong>Videos.get</strong> 来获取这个视频。</p>
<pre><code>Videos.get({ id: <span class="variable">$routeParams</span>.id }, <span class="keyword">function</span>(video){
    <span class="variable">$scope</span>.video = video;
});
</code></pre><p>现在实现在页面加载的时候填充表单。<strong>Videos.get</strong> 方法的第一个参数为路由提供了第一个参数 <strong>:id</strong>。我们使用 <strong>$routeParams.id</strong> 来获取浏览器地址栏中的这个参数。还记得我们为编辑页面定义的路由吗？</p>
<pre><code><span class="class">.when</span>(<span class="string">'/video/:id'</span>, {
    <span class="attribute">templateUrl</span>: <span class="string">'partials/video-form.html'</span>,
})
</code></pre><p>这里我们使用一个路由参数（:id）。然后我们通过 <strong>$routeParams</strong> 来访问它。</p>
<p>在 <strong>Videos.get</strong> 的回调方法中，我们从服务端获得返回的视频然后将它存储在 <strong>$scope</strong> 中。同时通过Angular的双向数据绑定在后台运行，这个表格将会被我们的视屏对象自动填充。还记得 <strong>ng-model</strong> 吗？我们将输入域绑定到$scope对象的属性上。任何在输入域上发生的改变将会反射到$scope，反之亦然。</p>
<p>最后在控制器中，我们定义一个 <strong>save</strong> 方法，当保存按钮被点击时调用。</p>
<pre><code><span class="variable">$scope</span>.save = <span class="keyword">function</span>(){
    Videos.update(<span class="variable">$scope</span>.video, function(){
        <span class="variable">$location</span>.path(<span class="string">'/'</span>);
    });
}
</code></pre><p>注意这里，我们用 <strong>Videos.update</strong> 来替代 <strong>Videos.save</strong>。这是我们早在扩展 <strong>$resource</strong> 服务的时候就定义的新方法。这里将发送一个HTTP PUT请求给我们的API端点。</p>
<p>到这里差不多完成了。新控制器已经写好了。我们只需要添加引用到路由配置中。如下改变路由配置：</p>
<pre><code><span class="class">.when</span>(<span class="string">'/video/:id'</span>, {
    <span class="attribute">templateUrl</span>: <span class="string">'partials/video-form.html'</span>,
    <span class="attribute">controller</span>: <span class="string">'EditVideoCtrl'</span>
})
</code></pre><p>让我们测试这个新功能。返回到浏览器，刷新主页。选择一个视频。做一些修改，点击保存按钮。一切都应该工作。</p>
<p>在下一节中，我们将添加一个功能，来使我们的视频租赁商店的应用程序具有完整的增删改查功能。</p>
<p><em>如果觉得阅读这篇文章有收获，不妨点个赞吧^_^</em></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/11/30/mean-5/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[满满的正能量——《你只是看起来很努力》读书笔记]]></title>
      <link>http://yalishizhude.github.io/2015/11/28/try-hard/</link>
      <guid>http://yalishizhude.github.io/2015/11/28/try-hard/</guid>
      <pubDate>Sat, 28 Nov 2015 15:15:59 GMT</pubDate>
      <description>
      <![CDATA[<p><em>不明不白盲目努力的生活，不值得一过。</em></p>]]>
      
      </description>
      <content:encoded><![CDATA[<p><em>不明不白盲目努力的生活，不值得一过。</em></p>
<a id="more"></a>
<h1 id="楔子">楔子</h1><ul>
<li>生活中经常有这样的例子：看是每天都去自习室带了很多书，却还带了手机；看是晚上学到很晚，却只是在发呆；看是在健身房锻炼，却仅仅拍了两张照片在朋友圈。。。其实都只是一些假象，只是看起来很努力的自欺欺人。</li>
</ul>
<p>想读这本书只是看到了类似上述的情况中的一个故事，想想工作中也不乏这种例子。很多人号称自己写了几万行代码，但是有没有回顾过自己写的代码有多少是可以抽象公用模块化的，却偷懒用ctrl+c/ctrl+v？有多少是重复劳动？有多少是自己真正积累学习到的知识？</p>
<p>其实读这本书之前我心中就有了态度：</p>
<ul>
<li>努力不是一场真人秀</li>
<li>忙碌不是逃避思考的借口</li>
</ul>
<h1 id="理想">理想</h1><ul>
<li>记得，优秀不够，一定要卓越，一定要无可替代才是最重要的。而无可替代的方式有两种：做别人不愿意做的事情；把别人都能做好的事情做卓越。</li>
</ul>
<p>作者给“卓越”下的这个定义还算比较精准吧。</p>
<ul>
<li>在大城市，最不缺的就是梦想，最不差的就是优秀的人。</li>
</ul>
<p>很多人口口声声说为了梦想。我只是觉得梦想其实是一个很平常的东西，就像网上的那句：梦想就像内裤，你得有，但是不要经常拿出来炫耀。<br>从不觉得一个人为了梦想付出很多就显得很高尚。每个人都有自己的生活方式，没有梦想或者不愿意为梦想付出的人也值得尊重，也可能靠运气成功。<br>和优秀的人在一起，相互学习进步，这应该是吸引很多人才到大城市的一个重要原因。</p>
<ul>
<li><p>耐得住寂寞，才能享受繁华。</p>
</li>
<li><p>这世界上，有多少人，为了第一步能走的潇洒霸气，却一辈子没有迈出第一步。</p>
</li>
</ul>
<p>还有一些人，做好了所有的准备，却坚持不下来。最近我看到琢磨先生写的一篇文章《如果你是妓女，不是等到有感觉之后才去接客》，话糙理不糙，和这个道理相通。</p>
<ul>
<li>不求目的的学习都是作秀，不问效果的努力都只是浪费时间。</li>
</ul>
<p>以结果导向，轮功劳不论苦劳。</p>
<h1 id="爱情">爱情</h1><ul>
<li>真正的幸福是努力成为自己想成为的人，然后找到一个不用讨好的另一半。</li>
</ul>
<p>最不累的方式生活才能长久。始终相信权利和责任是对等的，越是妥协往往越是得不到好结果。</p>
<ul>
<li><p>最好的情侣，是能用灵魂平等地交流，是能用心去温暖彼此的两个人。</p>
</li>
<li><p>这世界上有多少情侣，热恋期过后，自己找出各种事情，继续延续热恋时的高温，却不知道，这样持久高温的恋爱，一不小心会唐生对方。我曾经见过一个女孩子为了证明男生还爱她，让他去为自己打架，最后引发出悲剧。</p>
</li>
</ul>
<p>不作就不会死。</p>
<ul>
<li>其实两个人在一起和钱没有太大的关系，而是看两个人是不是在一个频道上，不需要刻意地讨好对方，不用踮起脚去爱另一个人，更不用腆着脸去够另一个人。</li>
</ul>
<h1 id="亲情">亲情</h1><ul>
<li><p>中国很多家长了，大招就是两句矛盾的话，一是你已经不小了，二是你还是个孩子。所向披靡，无坚不摧。</p>
</li>
<li><p>真正的关心，根本不是绑架，更不是从自己的利益出发去关心别人，真正关心你的人，会在你迷惑的时候分享自己的意见，在你寒冷的时候给你第一件衣服。然后她不提条件得离开真心对你好的人从不会不停地强调自己多爱你。</p>
</li>
</ul>
<p>非常赞同，爱是一种牺牲和奉献，可以无私地付出，不是强加限制和索取。虽然爱这个词被滥用了，但始终还是最高尚的感情，因为它超越了生物那种趋利避害的生存逻辑逻辑。</p>
<h1 id="友情">友情</h1><ul>
<li>如果两个朋友，一个从来都只是以自己为中心，不管另一个人的感受，这种自私的人还是要远离他才好。朋友之间的感情和爱情其实很像，如果不互相考虑，彼此倾听，只是单方索取，一面幸福，不顾对方，那么这样的朋友还是越少越好吧。</li>
</ul>
<p>我看到很多人有时候在问，为什么我对他（她）那么好，他（却）对我这样。抱着作者所述的平等、尊重的态度与人交往，类似的疑问应该不会有了。</p>
<h1 id="总结">总结</h1><p>书中精华大致如此，作者李尚龙感觉像是一个文艺青年，文笔中带着一些书生意气。实践性的内容并不多，都是个人观点+具体事例，读来觉得真实偶有热血翻腾之感。<br>读这本书其实有两个原因：一是作者文笔亲切，和当年作诗写词，为赋新词强说愁的我有些像。二是书中观点基本与我所想契合。<br>生活迷茫之时读一读或许可以激发人的斗志，生活安逸之时也可以当做一本故事书来读~</p>
<p><em>如果觉得阅读这篇文章有收获，不妨点个赞吧^_^</em></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/11/28/try-hard/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[【译】基于MEAN的全栈开发实例教程4：实现新增功能]]></title>
      <link>http://yalishizhude.github.io/2015/11/19/mean-4/</link>
      <guid>http://yalishizhude.github.io/2015/11/19/mean-4/</guid>
      <pubDate>Thu, 19 Nov 2015 02:16:04 GMT</pubDate>
      <description>
      <![CDATA[<blockquote>
<p>原文地址 <a href="https://blog.udemy.com/node-js-tutorial">https://blog.udemy.com/node-js-tutorial</a><br>感谢来自Udemy的Samantha来信分享</p>
</blockquote>
<h1 id="添加一个新视频">添加一个新视频</h1><p>在这一部分中，你将学习更多关于在Express中创建API端点，利用Angular构建表单，用Monk在Mongo中存储文档。</p>
<p>类似于上一节，我们将在随后几步中将从前端到后端实现这一功能。首先，我们将创建一个添加视频的API。我们将使用Express路由创建此端点并用Monk存储视频文件在Mongo中。然后，我们将创建一个新的页面来添加一个视频并用Angular来构建这个页面。</p>
<p>让我们开始吧。</p>]]>
      
      </description>
      <content:encoded><![CDATA[<blockquote>
<p>原文地址 <a href="https://blog.udemy.com/node-js-tutorial" target="_blank" rel="external">https://blog.udemy.com/node-js-tutorial</a><br>感谢来自Udemy的Samantha来信分享</p>
</blockquote>
<h1 id="添加一个新视频">添加一个新视频</h1><p>在这一部分中，你将学习更多关于在Express中创建API端点，利用Angular构建表单，用Monk在Mongo中存储文档。</p>
<p>类似于上一节，我们将在随后几步中将从前端到后端实现这一功能。首先，我们将创建一个添加视频的API。我们将使用Express路由创建此端点并用Monk存储视频文件在Mongo中。然后，我们将创建一个新的页面来添加一个视频并用Angular来构建这个页面。</p>
<p>让我们开始吧。</p>
<a id="more"></a>
<h2 id="第1步：创建1个API端点">第1步：创建1个API端点</h2><p>打开 <strong>routes&gt;videos.js</strong> 然后在文件后面和 <strong>module.exports</strong> 前面新增路由（记住，module.exports 应该是模块中的最后一行）：</p>
<pre><code>router.post(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span><span class="params">(req, res)</span></span>{
    <span class="keyword">var</span> collection = db.<span class="keyword">get</span>(<span class="string">'videos'</span>);
    collection.insert({
        title: req.body.title,
        description: req.body.description
    }, <span class="function"><span class="keyword">function</span><span class="params">(err, video)</span></span>{
        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;
        res.json(video);
    });
});
</code></pre><p>这些代码和之前有些类似。让我回顾一下重要的部分。首先，注意router.post方法的用法。在最后一节，我们使用router.get方法来处理一个HTTP GET请求。这里，我们使用REST约定中用来创建对象的 HTTP POST请求。</p>
<p>在路由处理器中，首先我们获得了一个 <strong>videos</strong> 集合的引用，然后使用 <strong>insert</strong>方法在Mongo中添加一个新的文档。</p>
<p>这个方法的第1个参数是一个JSON对象，它有两个属性： <strong>title</strong> 和 <strong>description</strong>。我们用 <strong>req.body</strong> 从这些属性中读取值。它代表数据将被提交到请求的body中。</p>
<p>最后，在回调方法中新增一个文档，如果我们没有获取任何错误，我们使用response（res）的 <strong>json</strong> 方法来返回一个新增的用JSON表示的视频文档。</p>
<h2 id="第2步：创建一个表单">第2步：创建一个表单</h2><p>现在API已经准备好了。我们需要一个表单来新增一个视频。</p>
<p>在 <strong>public &gt; partials</strong> 目录下创建一个新的视图 <strong>video-form.html</strong> 。在文件中输入以下代码：</p>
<pre><code><span class="tag">&lt;<span class="title">h1</span>&gt;</span>Add a Video<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
<span class="tag">&lt;<span class="title">form</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span>
        <span class="tag">&lt;<span class="title">label</span>&gt;</span>Title<span class="tag">&lt;/<span class="title">label</span>&gt;</span>        
        <span class="tag">&lt;<span class="title">input</span>&gt;</span><span class="tag">&lt;/<span class="title">input</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span>
        <span class="tag">&lt;<span class="title">label</span>&gt;</span>Description<span class="tag">&lt;/<span class="title">label</span>&gt;</span>
        <span class="tag">&lt;<span class="title">textarea</span>&gt;</span><span class="tag">&lt;/<span class="title">textarea</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"button"</span> <span class="attribute">value</span>=<span class="value">"Save"</span>&gt;</span><span class="tag">&lt;/<span class="title">input</span>&gt;</span>  
<span class="tag">&lt;/<span class="title">form</span>&gt;</span>
</code></pre><p>现在当用户跳转到 <strong>/add-video</strong> 时我们需要告诉Angular来展示这个视图。所以需要一个新的路由。</p>
<p>打开 <strong>vidzy.js</strong> 并且更新路由配置如下：</p>
<pre><code>app.config([<span class="string">'$routeProvider'</span>, <span class="keyword">function</span>(<span class="variable">$routeProvider</span>){
    <span class="variable">$routeProvider</span>
        .when(<span class="string">'/'</span>, {
            templateUrl: <span class="string">'partials/home.html'</span>,
            controller: <span class="string">'HomeCtrl'</span>
        })
        .when(<span class="string">'/add-video'</span>, {
            templateUrl: <span class="string">'partials/video-form.html'</span>
        })
        .otherwise({
            redirectTo: <span class="string">'/'</span>
        });
}]);
</code></pre><p>注意这里我们还没有配置controller，因为我们还没有写controller，我们在下一步中设置。</p>
<p>视图和路由已经准备好了。最后，我们添加一个链接 <strong>/add-video</strong> 在首页中。打开 <strong>partials&gt;home.html</strong> 在 <strong>UL</strong> 标签前面添加1个新的链接：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/#/add-video"</span>&gt;</span>Add a Video<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</code></pre><p>注意在Angular应用中需要在链接前添加 <strong>/#</strong>。这是为了兼容老的不支持单页应用的浏览器。</p>
<p>让我们预览一下目前为止我们开发的页面。回到浏览器并刷新首页。你将看到添加一个视频的链接。点击链接可以看到添加视频的页面。</p>
<p>不得不说这个表单看起来真的很丑并且和真正应用的表单看起来差别很大。让我们给它一个漂亮、现代化的外观。</p>
<h2 id="第3步：添加Bootstrap">第3步：添加Bootstrap</h2><p>我们将使用Bootstrap来为表单添加一些样式。如果你不熟悉Bootstrap，简单解释一下，它是一个用来构建现代和响应式web应用的前端CSS框架。在这个步骤中，我们将引用Bootstrap CSS文件，通过Bootstrap类来装饰我们的表单元素。</p>
<p>打开 <strong>views &gt; layout.jade</strong></p>
<p>在 <strong>head</strong> 标签的最后一行添加</p>
<pre><code>link<span class="list">(<span class="keyword">rel=</span><span class="quoted">'stylesheet</span>', href=<span class="quoted">'https</span><span class="keyword">://maxcdn</span>.bootstrapcdn.com/bootstrap/3.<span class="number">3.5</span>/css/bootstrap.min.css')</span>
</code></pre><p>确认它和上一行有同样的缩进空格数</p>
<p>现在回到 <strong>partials &gt; video-form.html</strong>。添加下面的类到HTML元素：</p>
<pre><code><span class="tag">&lt;<span class="title">h1</span>&gt;</span>Add a Video<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>

<span class="tag">&lt;<span class="title">form</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"form-group"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">label</span>&gt;</span>Title<span class="tag">&lt;/<span class="title">label</span>&gt;</span>        
        <span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"form-control"</span>&gt;</span><span class="tag">&lt;/<span class="title">input</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"form-group"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">label</span>&gt;</span>Description<span class="tag">&lt;/<span class="title">label</span>&gt;</span>
        <span class="tag">&lt;<span class="title">textarea</span> <span class="attribute">class</span>=<span class="value">"form-control"</span>&gt;</span><span class="tag">&lt;/<span class="title">textarea</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"button"</span> <span class="attribute">class</span>=<span class="value">"btn btn-primary"</span> <span class="attribute">value</span>=<span class="value">"Save"</span>&gt;</span><span class="tag">&lt;/<span class="title">input</span>&gt;</span>  
<span class="tag">&lt;/<span class="title">form</span>&gt;</span>
</code></pre><p>这些都是标准的Bootstrap用来创建表单的类。更多关于怎样用Bootstrap创建现代表单的例子，请查看<a href="http://getbootstrap.com/" target="_blank" rel="external">Bootstrap 文档</a></p>
<p>回到浏览器并刷新页面。</p>
<img src="/2015/11/19/mean-4/add.png" alt="add.png" title="">
<p>现在看起来好多了。</p>
<p>这个表单还没有行为。如果你点击保存按钮的话什么也不会发生，这就是我们下一步将要添加的功能。</p>
<h2 id="第4步：实现控制器">第4步：实现控制器</h2><p>正如我之前所说，在MVC框架中，一个控制器主要处理视图中的事件。我们将创建一个Angular控制器来处理保存按钮的点击事件。</p>
<p>打开 <strong>vidzy.js</strong> 并在文件末尾输入下列代码</p>
<pre><code>app.controller(<span class="string">'AddVideoCtrl'</span>, [<span class="string">'$scope'</span>, <span class="string">'$resource'</span>, <span class="string">'$location'</span>,
    <span class="keyword">function</span>(<span class="variable">$scope</span>, <span class="variable">$resource</span>, <span class="variable">$location</span>){
        <span class="variable">$scope</span>.save = function(){
            var Videos = <span class="variable">$resource</span>(<span class="string">'/api/videos'</span>);
            Videos.save(<span class="variable">$scope</span>.video, function(){
                <span class="variable">$location</span>.path(<span class="string">'/'</span>);
            });
        };
    }]);
</code></pre><p>这个控制器有3个依赖：<strong>$scope</strong>是控制器和视图之间的胶水，<strong>$resource</strong>用来调用RESTful API，<strong>$location</strong>用来改变浏览器地址栏的URL。所有这些已经在Angular服务中构建。</p>
<p>在控制器中，我们在 <strong>$scope</strong> 上定义 <strong>save</strong> 方法。这个方法将在用户点击保存按钮时被调用。稍后将它挂载在视图上，先来看看方法中的逻辑。</p>
<p>首先，我们调用 <strong>$resource</strong> 方法来传递API中的地址（<strong>/api/videos</strong>），返回一个对象来与API交互。在最后一节中，我们使用 <strong>query</strong> 方法来获取所有的视频。这里，我们使用 <strong>save</strong> 方法来提交一个视频给API。</p>
<p><strong>videos.save</strong> 方法需要两个参数：用来提交的对象和回调函数（当异步调用执行完成时调用）。在回调函数中，我们使用 <strong>$location</strong> 服务来修改浏览器地址到网站的根路径。Angular知道根URL是绑定到home视图的。它将展示home页面给用户。</p>
<p>打开 <strong>partials &gt; videos-form.html</strong> 如下修改input域</p>
<pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"form-group"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">label</span>&gt;</span>Title<span class="tag">&lt;/<span class="title">label</span>&gt;</span>        
    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"form-control"</span> <span class="attribute">ng-model</span>=<span class="value">"video.title"</span>&gt;</span><span class="tag">&lt;/<span class="title">input</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"form-group"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">label</span>&gt;</span>Description<span class="tag">&lt;/<span class="title">label</span>&gt;</span>
    <span class="tag">&lt;<span class="title">textarea</span> <span class="attribute">class</span>=<span class="value">"form-control"</span> <span class="attribute">ng-model</span>=<span class="value">"video.description"</span>&gt;</span><span class="tag">&lt;/<span class="title">textarea</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</code></pre><p><strong>ng-model</strong>属性是另一个用来绑定数据的指令。通过它，我们告诉Angular如果用户点击这个按钮，它将自动更新引用$scope的属性。在第一个例子中，当文本框的值改变时，Angular将自动修改 <strong>$scope.video.title</strong>。</p>
<p>接下来修改按钮的声明如下：</p>
<pre><code>&lt;input <span class="class"><span class="keyword">type</span>=</span><span class="string">"button"</span> <span class="class"><span class="keyword">class</span>=</span><span class="string">"btn btn-primary"</span> value=<span class="string">"Save"</span> ng-click=<span class="string">"save()"</span>&gt;&lt;/input&gt;
</code></pre><p><strong>ng-click</strong>属性也是Angular的另一个用来处理HTML元素点击事件的指令。通过这个指令，我们告诉Angular如果用户点击这个按钮，它将执行 <strong>$scope</strong>上的 <strong>save</strong>方法。</p>
<p>最后在路由中注册一个新的控制器</p>
<pre><code><span class="class">.when</span>(<span class="string">'/add-video'</span>, {
        <span class="attribute">templateUrl</span>: <span class="string">'partials/video-form.html'</span>,
        <span class="attribute">controller</span>: <span class="string">'AddVideoCtrl'</span>
    })
</code></pre><p>现在已经完成了，测试一下这个应用。回到浏览器，填写并提交表单。你将在列表中看到一个新的视频。</p>
<p>快速总结一下这一节中学到的知识。我们用Express创建了一个新的API端点然后使用Monk来存储一个视频文档到Mongo。然后，我们创建了一个Angular视图并通过表单添加一个视频。我们通过使用Bootstrap来美化了表单。最后，我们创建控制器来处理视图中的点击事件。在处理点击事件中，我们使用 <strong>$resource</strong>服务来提交数据给服务端。</p>
<p>在下一节中，我们将添加一个编辑功能。</p>
<p><em>如果觉得阅读这篇文章有收获，不妨点个赞吧^_^</em></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/11/19/mean-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[那么多“扫一扫”，不妨“摇一摇”——微信“摇一摇周边”功能开发实录]]></title>
      <link>http://yalishizhude.github.io/2015/11/17/shake-nearby/</link>
      <guid>http://yalishizhude.github.io/2015/11/17/shake-nearby/</guid>
      <pubDate>Tue, 17 Nov 2015 15:29:45 GMT</pubDate>
      <description>
      <![CDATA[<p>这次为了准备一个会议的答题抽奖活动，在这个“二维码扫一扫”泛滥的时代，决定采用微信上比较新颖的一个功能：“摇一摇周边”。简单的说就是打开微信、蓝牙，站在开启的无线设备周边摇一摇，就可以摇到对应的页面，点击可进入。常用场景参考下图，其它用途可以发挥现象~</p>]]>
      
      </description>
      <content:encoded><![CDATA[<p>这次为了准备一个会议的答题抽奖活动，在这个“二维码扫一扫”泛滥的时代，决定采用微信上比较新颖的一个功能：“摇一摇周边”。简单的说就是打开微信、蓝牙，站在开启的无线设备周边摇一摇，就可以摇到对应的页面，点击可进入。常用场景参考下图，其它用途可以发挥现象~</p>
<a id="more"></a>
<img src="/2015/11/17/shake-nearby/cover.png" alt="cover.png" title="">
<p>参考微信提供的官方文档，加上审核填坑时间，前前后后也就几个小时（文档上说审核是1~3个工作日，没想到这么快）。下面就是对整个开发流程的一个记录~</p>
<h1 id="准备条件">准备条件</h1><ul>
<li>微信公众号</li>
<li><p>iBeacon设备。<a href="http://kf.qq.com/faq/120911VrYVrA150410Y7NjiY.html，" target="_blank" rel="external">http://kf.qq.com/faq/120911VrYVrA150410Y7NjiY.html，</a> 这里提供了可选设备列表，设备名称和厂商正确，不过网址已经过时，直接去网上购买就行，价格也就几十块~</p>
<img src="/2015/11/17/shake-nearby/device.png" alt="device.png" title="">
</li>
<li><p>开着蓝牙装着微信的智能手机</p>
</li>
</ul>
<h1 id="后端配置">后端配置</h1><p>申请功能和设备开通“摇一摇周边”功能，和 <strong>后台配置</strong>同时进行。 <strong>都是采用https协议，POST请求，json格式数据。</strong><br>后端配置api写得很清楚，直接摘抄整理了~</p>
<h2 id="功能开通">功能开通</h2><h3 id="申请开通摇周边功能">申请开通摇周边功能</h3><h4 id="请求地址">请求地址</h4><p><a href="https://api.weixin.qq.com/shakearound/account/register?access_token=ACCESS_TOKEN" target="_blank" rel="external">https://api.weixin.qq.com/shakearound/account/register?access_token=ACCESS_TOKEN</a></p>
<h4 id="参数">参数</h4><pre><code>{
  "<span class="attribute">name</span>": <span class="value"><span class="string">"联系人姓名，不超过20汉字或40个英文字母"</span></span>,
  "<span class="attribute">phone_number</span>": <span class="value"><span class="string">"联系人电话"</span></span>,
  "<span class="attribute">email</span>": <span class="value"><span class="string">"联系人邮箱"</span></span>,
  "<span class="attribute">industry_id</span>": <span class="value"><span class="string">"平台定义的行业代号，具体请查看链接[行业代号](http://3gimg.qq.com/shake_nearby/Qualificationdocuments.html)"</span></span>,
  "<span class="attribute">qualification_cert_urls</span>": <span class="value">[
  <span class="string">"相关资质文件的图片url，图片需先上传至微信侧服务器，用“素材管理-上传图片素材”接口上传图片，返回的图片URL再配置在此处"</span>
  ]
</span>}
</code></pre><h4 id="返回值">返回值</h4><pre><code>{
   "<span class="attribute">data</span>": <span class="value">{}</span>,
   "<span class="attribute">errcode</span>": <span class="value"><span class="number">0</span></span>,
   "<span class="attribute">errmsg</span>": <span class="value"><span class="string">"success."</span>
</span>}
</code></pre><h3 id="查询审核状态">查询审核状态</h3><h4 id="请求地址-1">请求地址</h4><p><a href="https://api.weixin.qq.com/shakearound/account/auditstatus?access_token=ACCESS_TOKEN" target="_blank" rel="external">https://api.weixin.qq.com/shakearound/account/auditstatus?access_token=ACCESS_TOKEN</a></p>
<h4 id="返回值-1">返回值</h4><pre><code>{
    "<span class="attribute">data</span>": <span class="value">{
        "<span class="attribute">apply_time</span>": <span class="value">提交申请的时间戳</span>,
        "<span class="attribute">audit_comment</span>": <span class="value"><span class="string">"审核备注，包括审核不通过的原因"</span></span>,
        "<span class="attribute">audit_status</span>": <span class="value">审核状态。<span class="number">0</span>：审核未通过、<span class="number">1</span>：审核中、<span class="number">2</span>：审核已通过；审核会在三个工作日内完成</span>,
        "<span class="attribute">audit_time</span>": <span class="value">确定审核结果的时间戳；若状态为审核中，则该时间值为<span class="number">0</span>
    </span>}</span>,
    "<span class="attribute">errcode</span>": <span class="value"><span class="number">0</span></span>,
    "<span class="attribute">errmsg</span>": <span class="value"><span class="string">"success."</span>
</span>}
</code></pre><blockquote>
<p><a href="http://mp.weixin.qq.com/wiki/13/025f1d471dc999928340161c631c6635.html" target="_blank" rel="external">官方文档</a></p>
</blockquote>
<h2 id="设备申请">设备申请</h2><h3 id="申请设备id">申请设备id</h3><h4 id="请求地址-2">请求地址</h4><p><a href="https://api.weixin.qq.com/shakearound/device/applyid?access_token=ACCESS_TOKEN" target="_blank" rel="external">https://api.weixin.qq.com/shakearound/device/applyid?access_token=ACCESS_TOKEN</a></p>
<h4 id="参数-1">参数</h4><pre><code>{
   "<span class="attribute">quantity</span>":<span class="value">申请的设备ID的数量，单次新增设备超过<span class="number">500</span>个，需走人工审核流程</span>,
   "<span class="attribute">apply_reason</span>":<span class="value"><span class="string">"申请理由，不超过100个汉字或200个英文字母"</span>
</span>}
</code></pre><h4 id="返回值-2">返回值</h4><pre><code>{
"<span class="attribute">data</span>": <span class="value">{
               "<span class="attribute">apply_id</span>": <span class="value"><span class="number">123</span></span>,
    "<span class="attribute">audit_status</span>": <span class="value"><span class="number">1</span></span>,  
    "<span class="attribute">audit_comment</span>": <span class="value"><span class="string">"审核中"</span>  
   </span>}</span>,
   "<span class="attribute">errcode</span>": <span class="value"><span class="number">0</span></span>,
   "<span class="attribute">errmsg</span>": <span class="value"><span class="string">"success."</span>
</span>}
</code></pre><h3 id="查询设备ID申请审核状态">查询设备ID申请审核状态</h3><h4 id="请求地址-3">请求地址</h4><p><a href="https://api.weixin.qq.com/shakearound/device/applystatus?access_token=ACCESS_TOKEN" target="_blank" rel="external">https://api.weixin.qq.com/shakearound/device/applystatus?access_token=ACCESS_TOKEN</a></p>
<h4 id="请求参数">请求参数</h4><pre><code>{
   "<span class="attribute">apply_id</span>": <span class="value">批次ID，申请设备ID时所返回的批次ID  
</span>}
</code></pre><h4 id="返回值-3">返回值</h4><pre><code>{
    "<span class="attribute">data</span>": <span class="value">{
        "<span class="attribute">apply_time</span>": <span class="value"><span class="number">1432026025</span></span>,
        "<span class="attribute">audit_comment</span>": <span class="value"><span class="string">"test"</span></span>,
        "<span class="attribute">audit_status</span>": <span class="value"><span class="number">1</span></span>,
        "<span class="attribute">audit_time</span>": <span class="value"><span class="number">0</span>
    </span>}</span>,
    "<span class="attribute">errcode</span>": <span class="value"><span class="number">0</span></span>,
    "<span class="attribute">errmsg</span>": <span class="value"><span class="string">"success."</span>
</span>}
</code></pre><blockquote>
<p><a href="http://mp.weixin.qq.com/wiki/15/b9e012f917e3484b7ed02771156411f3.html" target="_blank" rel="external">官方文档</a></p>
</blockquote>
<h2 id="页面配置（可选）">页面配置（可选）</h2><h3 id="查询页面id">查询页面id</h3><h4 id="请求地址-4">请求地址</h4><p><a href="https://api.weixin.qq.com/shakearound/page/search?access_token=ACCESS_TOKEN" target="_blank" rel="external">https://api.weixin.qq.com/shakearound/page/search?access_token=ACCESS_TOKEN</a></p>
<h4 id="返回值-4">返回值</h4><pre><code>{
    "<span class="attribute">type</span>": <span class="value"><span class="number">1</span></span>,
    "<span class="attribute">page_ids</span>":<span class="value">[<span class="number">12345</span>, <span class="number">23456</span>, <span class="number">34567</span>]
</span>}
</code></pre><h3 id="编辑页面信息">编辑页面信息</h3><h4 id="请求地址-5">请求地址</h4><p><a href="https://api.weixin.qq.com/shakearound/page/update?access_token=ACCESS_TOKEN" target="_blank" rel="external">https://api.weixin.qq.com/shakearound/page/update?access_token=ACCESS_TOKEN</a></p>
<h4 id="参数-2">参数</h4><pre><code>{
 "<span class="attribute">page_id</span>":<span class="value"><span class="string">""</span>
 <span class="string">"title"</span>:<span class="string">"页面标题，最多6个字"</span></span>,   
 "<span class="attribute">description</span>":<span class="value"><span class="string">"页面副标题，最多7个字"</span></span>,
 "<span class="attribute">page_url</span>":<span class="value"><span class="string">"页面路径"</span></span>,
 "<span class="attribute">icon_url</span>":<span class="value"><span class="string">"页面图片路径"</span>
</span>}
</code></pre><h4 id="返回值-5">返回值</h4><pre><code>{
    "<span class="attribute">data</span>": <span class="value">{

    }</span>,
    "<span class="attribute">errcode</span>": <span class="value"><span class="number">0</span></span>,
    "<span class="attribute">errmsg</span>": <span class="value"><span class="string">"success."</span>
</span>}
</code></pre><blockquote>
<p><a href="http://mp.weixin.qq.com/wiki/5/6626199ea8757c752046d8e46cf13251.html" target="_blank" rel="external">官方文档</a></p>
</blockquote>
<h1 id="后台配置">后台配置</h1><p>这个需要登录微信公众号进行操作，在后端申请成功后，点击左边的 <strong>页面配置</strong> 进行编辑并配置到对应的设备上，一个页面可以配置到多个设备，但是一个设备只能关联到一个页面。</p>
<img src="/2015/11/17/shake-nearby/page-config-1.png" alt="page-config-1.png" title="">
<img src="/2015/11/17/shake-nearby/page-config-2.png" alt="page-config-2.png" title="">
<p>同时下载设备列表（一个xls文件）<br><img src="/2015/11/17/shake-nearby/device-list.png" alt="device-list.png" title=""></p>
<h1 id="设备配置">设备配置</h1><p>微信给出的教程是使用手机软件通过蓝牙连接进行配置，个人偏好用电脑数据线连接配置。从官网上下载一个配置软件，连接设备之后，启动设备读取信息。<br>根据上一步得到的设备列表文件，找到之前申请的设备id，将UUID、majorId、minorId写入设备。</p>
<img src="/2015/11/17/shake-nearby/device-config.png" alt="device-config.png" title="">
<h1 id="页面开发">页面开发</h1><p>页面和设备关联之后，先启动设备，打开手机蓝牙，切换到微信摇一摇，如果手机在设备周边就会出现一个 <strong>“周边”</strong> ，这里会出现配置的页面，点击之后微信内置浏览器会打开页面，如下形式：<br><a href="http://abc.com/xx.html?ticket=9255cca12ad1bfc8fcafd0994e7ecdf4&amp;activityid=918158" target="_blank" rel="external">http://abc.com/xx.html?ticket=9255cca12ad1bfc8fcafd0994e7ecdf4&amp;activityid=918158</a><br>url中传入两个参数：ticket和activityid，activityid暂时未用到，ticket可以和access_token查询用户的openId，从而调用jsapi。<br>这里的例子是先判断是否关注微信公众号，如果未关注则需要先关注，然后通过ticket获取openId跳转到另一个页面。</p>
<pre><code><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>
<span class="attribute">src</span>=<span class="value">"http://zb.weixin.qq.com/nearbycgi/addcontact/BeaconAddContactJsBridge.js"</span>&gt;</span><span class="undefined">
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="actionscript">
    <span class="keyword">var</span> domain = <span class="string">'网站域名'</span>;
    <span class="keyword">var</span> url1 =<span class="string">'获取openId接口'</span>;
    <span class="keyword">var</span> url2 = <span class="string">'跳转页面'</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">getQueryString</span><span class="params">(key)</span></span>{
        <span class="comment">//获取querystring</span>
    }
    BeaconAddContactJsBridge.ready(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="comment">//判断是否关注</span>
        BeaconAddContactJsBridge.invoke(<span class="string">'checkAddContactStatus'</span>,{} ,<span class="function"><span class="keyword">function</span><span class="params">(apiResult)</span></span>{
            <span class="keyword">if</span>(apiResult.err_code == <span class="number">0</span>){
                <span class="keyword">var</span> status = apiResult.data;
                <span class="keyword">if</span>(status == <span class="number">1</span>){
                    <span class="comment">//调用本地页面，通过ticket获取openId</span>
                    $.<span class="keyword">get</span>(domain+url1+getQueryString(<span class="string">'ticket'</span>),<span class="function"><span class="keyword">function</span><span class="params">(resp)</span></span>{
                        <span class="keyword">if</span>(resp.data) openId = resp.data.openid;
                        url2 += openId;
                        location.href = url;
                    });
                }<span class="keyword">else</span>{
                    <span class="comment">//跳转到关注页</span>
                    BeaconAddContactJsBridge.invoke(<span class="string">'jumpAddContact'</span>);
                }
            }<span class="keyword">else</span>{
                alert(apiResult.err_msg)
            }
        });
    });
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p><a href="http://mp.weixin.qq.com/wiki/3/9fe34e4bfdc162ff173d85d98dc06db3.html" target="_blank" rel="external">官方文档</a></p>
<h1 id="FAQ">FAQ</h1><p><a href="http://kf.qq.com/faq/120911VrYVrA150412Izm2qi.html" target="_blank" rel="external">微信摇一摇周边常见问题解答</a></p>
<blockquote>
<p>如果觉得阅读这篇文章有收获，不妨点个赞吧^_^</p>
</blockquote>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/11/17/shake-nearby/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[从JQuery到Angular的一次改版]]></title>
      <link>http://yalishizhude.github.io/2015/11/13/jquery2angular/</link>
      <guid>http://yalishizhude.github.io/2015/11/13/jquery2angular/</guid>
      <pubDate>Thu, 12 Nov 2015 22:43:15 GMT</pubDate>
      <description>
      <![CDATA[<h1 id="前言">前言</h1><p>最近主要在对之前的流程进行改版优化，之前一直使用的JQuery来实现，因为考虑到Angular在可移植性、可维护性、耦合性方面都优于JQuery，缺点就是学习成本比较高，不过之前一直在微信端使用Angular，所以这一点也不成问题。于是探坑之旅就这样开始了…</p>]]>
      
      </description>
      <content:encoded><![CDATA[<h1 id="前言">前言</h1><p>最近主要在对之前的流程进行改版优化，之前一直使用的JQuery来实现，因为考虑到Angular在可移植性、可维护性、耦合性方面都优于JQuery，缺点就是学习成本比较高，不过之前一直在微信端使用Angular，所以这一点也不成问题。于是探坑之旅就这样开始了…</p>
<a id="more"></a>
<h1 id="代码量">代码量</h1><h2 id="JQuery">JQuery</h2><p>体积：84.6k（html 20.2k，js 64.4k）<br>文件数：9（4个html，5个js）</p>
<h2 id="Angular">Angular</h2><p>体积：95.1k（html 39.7k，js 55.4k）<br>文件：12（5个html，7个js）</p>
<p>这里只考虑业务逻辑，忽略第三方代码。<br>原有的业务逻辑由js动态生成dom，所以js部分会比较庞大。<br>在html插入指令和业务逻辑，所以html体积增大。</p>
<h1 id="页面结构">页面结构</h1><p>整个业务流程分为3个步骤，每个步骤完成之后才能进入下个步骤，所有步骤完成之后才可以提交给后端。<br>最简单的实现方法是把每个步骤做成表单放在一个页面里面，所有表单完成后抽取整合放在ajax里进行提交。这样实现的话容易造成代码的耦合性提高从而可维护性降低，并不是最佳的实现方式。所以对于JQuery和Angular分别采取了不同的实现形式。</p>
<h2 id="JQuery-1">JQuery</h2><p>类似单页应用的加载方式，好处的就是不会刷新页面，数据不丢失，容易整合提交</p>
<h3 id="路由">路由</h3><p>考虑到学习成本以及业务流程相对简单，没有使用backbone之类的第三方js管理路由，自己对hash值进行判断来管理路由。首先实现<code>onhashchange</code>函数来监控路由变化</p>
<pre><code>window.onhashchange = function()<span class="decorator">{...}</span>;
</code></pre><p>然后获取<code>location.hash</code>对其判断</p>
<pre><code><span class="keyword">switch</span> (location.hash) {
  <span class="keyword">case</span> <span class="string">'#step-0'</span>:
    <span class="keyword">break</span>;
    <span class="comment">//此处省略几十行代码</span>
}
</code></pre><p>路由的跳转也是通过修改<code>location.hash</code>值来实现，这里url使用了underscore的template的函数，起作用可以理解为<code>replace</code>。</p>
<pre><code><span class="keyword">var</span> urlTemplate = _.<span class="keyword">template</span>(location.pathname + location.search + '<span class="comment">#&lt;%=step%&gt;');</span>
location.href = urlTemplate({step: 'step-<span class="number">2</span>'});
</code></pre><h3 id="分页">分页</h3><p>使用的JQuery的load函数,这个函数从服务端加载html，然后填充在所选dom中，加载完成后执行回调函数进行初始化操作。</p>
<pre><code>$(<span class="string">'#view'</span>).load(url, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
  init();
});
</code></pre><h2 id="Angular-1">Angular</h2><p>用单页路由的形式也是可以实现的，不过我采用了指令的方式伪装成“分页”来实现。这样也达到了降低耦合性的效果。</p>
<h3 id="“分页”">“分页”</h3><p>前面说了，这里使用自定义的指令来做成单个分页，所以页面的切换就变成了控制指令的显示和隐藏，实现方式也很简单，使用<code>ng-show</code>通过改变<code>nowDirective</code>的值即可</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"container"</span> ng-controller=<span class="string">"mainCtrl"</span>&gt;
    &lt;<span class="keyword">div</span> projects ng-show=<span class="string">"nowDirective=='1'"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
    &lt;<span class="keyword">div</span> checkin ng-show=<span class="string">"nowDirective=='2'"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
    &lt;<span class="keyword">div</span> submit ng-show=<span class="string">"nowDirective=='3'"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><h3 id="“路由”">“路由”</h3><p>不过上面只是完成了html的加载，业务逻辑初始化需要借助Angular事件三基友：<code>$emit,$on,$broadcast</code>。当指令显示完成时<code>mainCtrl</code>用<code>$broadcast</code>发出广播给每个指令中的<code>controller</code>，指令的<code>controller</code>通过<code>$on</code>来接收事件并初始化。当前流程完成后用<code>$emit</code>向上冒泡通知父<code>controller</code>完成页面切换。</p>
<h1 id="require与Angular">require与Angular</h1><p>Angular这个东西的神奇之处在于：它本身是一个完整的框架，基本实现了开发中所需的各种功能，同时和其它第三方js又不冲突，比如JQuery、require。<br>这里使用require来管理代码并不是最优的方式，只是因为项目一直使用require来启动和管理项目上的js逻辑。Angular本身可以通过module函数来实现模块化，在项目中我也是这么实现的。</p>
<p>比如我在定义service的时候是这么写的</p>
<pre><code>define([<span class="string">'Angular'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">Angular</span>) </span>{
<span class="pi">    'use strict'</span>;
    Angular.module(<span class="string">'service'</span>, []).service(<span class="string">'customService'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        <span class="comment">//此处省略几百行代码</span>
    });
});
</code></pre><p>在引用这个服务的时侯先引用对应的js文件，然后就和Angular的引用方式一样先module后service。</p>
<pre><code>define([<span class="string">'JQuery'</span>, <span class="string">'Angular'</span>, <span class="string">'underscore'</span>, <span class="string">'./customService.js'</span>, <span class="string">'iCheck'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$, Angular, _</span>)</span>{
<span class="pi">    'use strict'</span>;
    Angular.module(<span class="string">'directive'</span>, [<span class="string">'service'</span>]).directive(<span class="string">'fold'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="comment">//此处省略几百行代码</span>
    });
});
</code></pre><p>这样就完成了模块化和解耦的工作。</p>
<h1 id="JQuery插件替换">JQuery插件替换</h1><p>以前的第三方插件大多是基于JQuery实现的，<br>以项目中的表格校验插件为例，JQuery下使用的是JQuery-validation插件，Angular下我使用Angular-validation。插件的替换分两块：样式和逻辑。逻辑放面按照官方文档进行替换即可，这里的配置文件我单独写了一个校验规则，内容不是很全，有兴趣的可以看一看 <a href="http://runjs.cn/code/lqzztwys。" target="_blank" rel="external">http://runjs.cn/code/lqzztwys。</a> 样式修改就变得很手工了，直接抠图、重写css。</p>
<img src="/2015/11/13/jquery2angular/error.png" alt="error.png" title="">
<img src="/2015/11/13/jquery2angular/success.png" alt="success.png" title="">
<h1 id="数据交互">数据交互</h1><p>主要方式分两类，一类是利用浏览器缓存，如localstorage、cookie，一类是利用Angular自身的通信方式。利用浏览器经常容易出现兼容性的问题，不考虑了，Angular的内部通信机制大致有3种：</p>
<ul>
<li>写个service存储数据，最规范优雅</li>
<li>利用上面提到的事件三基友，中规中矩</li>
<li>利用父子controller之间共享$scope对象属性的特点，最简单粗暴<br>这里考虑到项目进度我做了一回粗鲁的人…囧</li>
</ul>
<h1 id="总结">总结</h1><ul>
<li>Angular由于其数据绑定的特性，在操作、动态生成dom的时候非常具有优势，从此妈妈再也不用担心我忘记刷新dom/数据了~</li>
<li>Angular非常有利于模块化，同时模块内部注意html尽量写成directive，数据操作用service，业务逻辑用controller。因为service是对数据模型的高度抽象，所以复用性较好，这次试用的service都是从微信端直接拷贝过来使用的。</li>
</ul>
<blockquote>
<p>如果觉得阅读这篇文章有收获，不妨点个赞吧^_^</p>
</blockquote>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/11/13/jquery2angular/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[【译】你应该了解Nginx的7个原因]]></title>
      <link>http://yalishizhude.github.io/2015/11/07/nginx-solutions/</link>
      <guid>http://yalishizhude.github.io/2015/11/07/nginx-solutions/</guid>
      <pubDate>Sat, 07 Nov 2015 15:20:00 GMT</pubDate>
      <description>
      <![CDATA[<blockquote>
<p>Nginx (“engine x”)是一个高性能的HTTP和反向代理服务器，也是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器</p>
</blockquote>]]>
      
      </description>
      <content:encoded><![CDATA[<blockquote>
<p>Nginx (“engine x”)是一个高性能的HTTP和反向代理服务器，也是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器</p>
</blockquote>
<a id="more"></a>
<h1 id="1_负载均衡实现可扩展的浏量管理">1 <a href="https://www.nginx.com/solutions/load-balancing/" target="_blank" rel="external">负载均衡实现可扩展的浏量管理</a></h1><p>通过Nginx实现负载均衡将给你所需要的控制权，用来管理并扩展您的Web和移动应用。它提供了一个完整的基于软件应用的分发平台的解决方案，只消耗一小部分的硬件来平衡HTTP和TCP应用的负载。最大限度地提高您的网站和应用程序的可用性和可靠性，并尽量减少失望的客户和损失的收入。</p>
<h1 id="2_改造升级的Web服务器">2 <a href="https://www.nginx.com/solutions/web-server/" target="_blank" rel="external">改造升级的Web服务器</a></h1><p>Nginx是现代Web应用的HTTP操作系统。无论是分发内容还是流媒体视频或音频，或者部署复杂的Web服务，Nginx都是连接用户和应用的最佳平台。Nginx的高性能，高效率的HTTP处理引擎负责处理桌面，移动，和API交互，而这些任务都能在路由转发请求到正确的服务之前进行有效处理。企业部署Nginx来管理与HTTP相关的复杂度和风险，使他们的Web应用程序变得反应更灵敏，扩展性更强，更快速，更安全。</p>
<h1 id="3_快速和可扩展的视频传送">3 <a href="https://www.nginx.com/solutions/streaming-media/" target="_blank" rel="external">快速和可扩展的视频传送</a></h1><p>如果有人正在销售一个产品，培训一个新的用户，或提供一个企业信息。然而，提供高质量的视频内容给多样化的客户群是个问题，因为在这样的情况下交付质量容易迅速降低。用户希望你的视频在任何设备上能立即加载，就像世界上最流行的媒体一样。<br>Nginx可以帮助一些世界领先的流媒体公司提供快速、完美的内容。通过Nginx，可以可靠地将流视频和音频内容转发的任何设备–通过适当的访问控制，带宽管理和会话持久性可以进一步增强这个特性。</p>
<h1 id="4_加速Web和移动端性能">4 <a href="https://www.nginx.com/solutions/web-mobile-acceleration/" target="_blank" rel="external">加速Web和移动端性能</a></h1><p>Nginx是功能强大的Web加速解决方案来提升网站和应用的性能。通过Nginx，你的网页加载速度更快所以您的客户花费更少的时间等待，从而提高客户满意度，转换率，和收入。</p>
<h1 id="5_保护应用安全">5 <a href="https://www.nginx.com/solutions/application-security/" target="_blank" rel="external">保护应用安全</a></h1><p>保护网络应用不仅是保护数据，而且也意味着保持网站在面对恶意流量能正常运行。Nginx软件包就结合了这两个特点来为网站和应用提供全面的保护。</p>
<h1 id="6_为API提供安全保障和使用策略">6 <a href="https://www.nginx.com/solutions/api-gateway/" target="_blank" rel="external">为API提供安全保障和使用策略</a></h1><p>随着API在应用程序内爆炸式地增长，确保他们的受保护，被追踪它，和可量化变得非常关键。Nginx是一个管理安全的基于HTTP API流量的可信平台。通过领先的API管理平台的杠杆，Nginx将提供快速，可靠，可扩展，和安全的API为基础的服务。</p>
<h1 id="7_取代昂贵的ADC硬件负载平衡器">7 <a href="https://www.nginx.com/solutions/adc/" target="_blank" rel="external">取代昂贵的ADC硬件负载平衡器</a></h1><p>Nginx是一个完整的软件应用分发平台，只需要少量地消耗ADC硬件，就能获得利用商品硬件或云基础设施得到相同的功能和性能。由于在吞吐量和连接方面没有限制，Nginx允许应用充分发挥自身的潜能。</p>
<blockquote>
<p>如果觉得阅读这篇文章有收获，不妨点个赞吧^_^</p>
</blockquote>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/11/07/nginx-solutions/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[【译】基于MEAN的全栈开发实例教程3：通过Angular展示数据]]></title>
      <link>http://yalishizhude.github.io/2015/11/02/mean-3/</link>
      <guid>http://yalishizhude.github.io/2015/11/02/mean-3/</guid>
      <pubDate>Mon, 02 Nov 2015 13:36:35 GMT</pubDate>
      <description>
      <![CDATA[<blockquote>
<p>原文地址 <a href="https://blog.udemy.com/node-js-tutorial">https://blog.udemy.com/node-js-tutorial</a><br>感谢来自Udemy的Samantha来信分享</p>
</blockquote>
<h1 id="从数据库中查询所有视频">从数据库中查询所有视频</h1><p>首先，我们来实现一个简单的功能：在首页上展示数据库中所有的视频。有几种方式来实现这个功能。我们可以从前端到后端开发，也可以反过来。这并没有什么对错，不过在本教程中，处于教学原因我推荐从后端开始开发。<br>我们将通过以下几个步骤来实现：</p>
<ol>
<li>我们将在Mongo中创建一个数据库并且构建一些视频文件。</li>
<li>然后我们通过Express在数据库中创建一个API</li>
<li>最后我们用Angular来调用API并显示这些数据<br>如果你对这些技术没有任何经验也并无大碍。在本章节中，将覆盖这些技术的基础知识。然而，学习起来可能会有一点曲折。请保持耐心，因为一旦我们实现了接下来这些功能，在你再次运用这些概念的时候将会变得得心应手。</li>
</ol>]]>
      
      </description>
      <content:encoded><![CDATA[<blockquote>
<p>原文地址 <a href="https://blog.udemy.com/node-js-tutorial" target="_blank" rel="external">https://blog.udemy.com/node-js-tutorial</a><br>感谢来自Udemy的Samantha来信分享</p>
</blockquote>
<h1 id="从数据库中查询所有视频">从数据库中查询所有视频</h1><p>首先，我们来实现一个简单的功能：在首页上展示数据库中所有的视频。有几种方式来实现这个功能。我们可以从前端到后端开发，也可以反过来。这并没有什么对错，不过在本教程中，处于教学原因我推荐从后端开始开发。<br>我们将通过以下几个步骤来实现：</p>
<ol>
<li>我们将在Mongo中创建一个数据库并且构建一些视频文件。</li>
<li>然后我们通过Express在数据库中创建一个API</li>
<li>最后我们用Angular来调用API并显示这些数据<br>如果你对这些技术没有任何经验也并无大碍。在本章节中，将覆盖这些技术的基础知识。然而，学习起来可能会有一点曲折。请保持耐心，因为一旦我们实现了接下来这些功能，在你再次运用这些概念的时候将会变得得心应手。</li>
</ol>
<a id="more"></a>
<h2 id="第1步：构建数据库">第1步：构建数据库</h2><p>我们怎么通过数据文件来构建MongoDB数据库？MongoDB有一个可以通过控制台访问的脚本，然而通过脚本访问并不是很友好，所以为了开发变得简单，我们将用到一个免费的工具——RboMongo。登陆到 <a href="http://robomongo.org" target="_blank" rel="external">http://robomongo.org</a> 然后下载适合你操作系统的安装程序。<br>启动RoboMongo。你将看见一个用来连接MongoDB服务器的对话框<br><img src="/2015/11/02/mean-3/robomongo-1.png" alt="robomongo-1.png" title=""><br>点击顶部的 <strong>Create</strong>按钮。<br>将连接名称改为 <strong>localhost</strong>。注意连接地址指向的是<strong>localhost:27017。默认情况下MongoDB将在27017端口上启动。<br><img src="/2015/11/02/mean-3/robomongo-2.png" alt="robomongo-2.png" title=""><br>如果你点击 </strong>Test<strong>按钮，你可能看到一个类似这样的错误“Authorization skipped by you”。不用担心，忽略这个错误连接你本地的MongoDB。<br>保存配置的连接。回到 </strong>Connect<strong>对话框。连接 </strong>localhost<strong>。<br>在 </strong>View<strong>菜单中，勾选 </strong>Explorer<strong>选项。现在你的RoboMongo看起来应该是这样：<br><img src="/2015/11/02/mean-3/robomongo-3.png" alt="robomongo-3.png" title=""><br>在 </strong>Explorer<strong>面板，右键 </strong>localhost<strong>选择 </strong>Create Database<strong>。命名数据库为 </strong>vidzy<strong>。展开 </strong>vidzy<strong>，右键 </strong>Collections<strong>然后点击
 </strong>Create Collection<strong>。在MongoDB中，一个集合就类似于关系型数据库中的一张表。将这个集合命名为 </strong>videos<strong>。然后这个集合就显示在了列表中。<br> 接下来右键 </strong>videos<strong> 集合然后选择 </strong>Insert Document**。1个文档再MongoDB中类似关系型数据库中的1条记录。而MongoDB文档与之不同的是可以包含其它的文档。在Mongo中，我们使用JSON格式来展现文档。复制粘贴下面的代码到对话框中来新增一个视频文档：</p>
<pre><code>{
 "<span class="attribute">title</span>" : <span class="value"><span class="string">"Terminator Genisys"</span></span>,
 "<span class="attribute">genre</span>" : <span class="value"><span class="string">"SciFi"</span></span>,
 "<span class="attribute">description</span>" : <span class="value"><span class="string">"When John Connor, leader of the human resistance, sends Sgt. Kyle Reese back to 1984 to protect Sarah Connor and safeguard the future, an unexpected turn of events creates a fractured timeline."</span>
</span>}
</code></pre><p>注意：在粘贴这些代码之前请确保对话框中的内容已经清除，不然可能会得到一个非JSON对象。<br>重复上一步继续添加两个文档到videos集合：</p>
<pre><code>{
 <span class="comment">"title"</span> : <span class="comment">"The Lord of the Rings"</span>,
 <span class="comment">"genre"</span> : <span class="comment">"Fantasy"</span>,
 <span class="comment">"description"</span> : <span class="comment">"A meek hobbit of the Shire and eight companions set out on a journey to Mount Doom to destroy the One Ring and the dark lord Sauron."</span>
}
{
 <span class="comment">"title"</span> : <span class="comment">"Apollo 13"</span>,
 <span class="comment">"genre"</span> : <span class="comment">"Drama"</span>,
 <span class="comment">"description"</span> : <span class="comment">"NASA must devise a strategy to return Apollo 13 to Earth safely after the spacecraft undergoes massive internal damage putting the lives of the three astronauts on board in jeopardy."</span>
}
</code></pre><p>现在右键videos集合并选择 <strong>View Documents。你将在 </strong>videos**集合中看见3个文档。<br><img src="/2015/11/02/mean-3/robomongo-4.png" alt="robomongo-4.png" title=""><br>注意到每个文档都有一个由MongoDB自动生成的ID。<br>大功告成！我们的数据库准备就绪。现在，让我们用Express创建一个API来获取这些视频文档。</p>
<h2 id="第2步：通过Express创建1个API">第2步：通过Express创建1个API</h2><p>在这个步骤中，你将学习到关于Node模块系统，Express路由和用Monk从MongoDB中获取数据。<br>用你最喜欢的代码编辑器在项目根目录中打开app.js。文件中第1部分包含了几个 <strong>require</strong>函数调用。 <strong>require</strong>方法是Node中内置方法之一，主要用来引用其它文件中定义的模块：</p>
<pre><code><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);
<span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);
<span class="keyword">var</span> favicon = <span class="built_in">require</span>(<span class="string">'serve-favicon'</span>);
<span class="keyword">var</span> logger = <span class="built_in">require</span>(<span class="string">'morgan'</span>);
<span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>);
<span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);
</code></pre><p>第2部分引入了我们的路由模块。1个路由模块定义了1个或多个关联的端点以及对应的处理器。在这个由Express Generator生成的示例应用中，我们有两个路由模块： <strong>index</strong> 和 <strong>users</strong>：</p>
<pre><code><span class="keyword">var</span> routes = <span class="built_in">require</span>(<span class="string">'./routes/index'</span>);
<span class="keyword">var</span> users = <span class="built_in">require</span>(<span class="string">'./routes/users'</span>);
</code></pre><p>让我们看一看其中的一个路由模块，打开 <strong>rutes&gt;index.js</strong>。你将看到以下代码：</p>
<pre><code><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);
<span class="keyword">var</span> router = express.Router();

<span class="comment">/* GET home page. */</span>
router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>{
 res.render(<span class="string">'index'</span>, { title: <span class="string">'Express'</span> });
});

<span class="built_in">module</span>.exports = router;
</code></pre><p>来分析一下这段代码。</p>
<p>在第1行，我们在当前模块引用了Express。当使用 <strong>require</strong>方法时，依赖于目标模块是怎样实现的， <strong>require</strong>方法可能返回1个方法或者对象。在这个例子中，这个 <strong>express</strong>变量是1个对象。它提供了一个叫做 <strong>Router</strong>的方法，我们在第2行就调用了这个方法。用来访问Express中的路由对象。我们用1个路由来定义我们应用中的端点。我们在这些端点中接收请求。每个端点将会被关联到1个路由处理器，处理器负责处理在端点中收到的请求。</p>
<p>现在看下一行中路由配置的示例。</p>
<pre><code><span class="tag">router</span><span class="class">.get</span>(<span class="string">'/'</span>, <span class="function">function</span>(req, res, next) {
  <span class="tag">res</span><span class="class">.render</span>(<span class="string">'index'</span>, { <span class="attribute">title</span>: <span class="string">'Express'</span> });
});
</code></pre><p>我们使用路由中定义的 <strong>get</strong>方法来定义1个路由和它的处理器。第1个参数是这个端点；在这里，’/‘代表网站的根路径或者主页。第2个参数就是路由的处理器。</p>
<p>在Express中，所有的路由处理器都有一个同样的签名。第1个参数是请求对象，第2个参数是响应对象，第3个参数是当前链中的下一个处理器。Express使用的中间件函数采用链式调用的方式。当Express使用中间件时，有时候你可能需要在当前链中调用下一个中间件。你可以通过 <strong>next</strong> 变量实现。但是当我们在处理路由的时候，我们几乎不需要这个操作，所以这里你可以安全地删除 <strong>next</strong> 变量。</p>
<p>现在看一下这个函数体。 <strong>res</strong> 变量代表了响应对象。这个响应对象自带了一些有用的函数。</p>
<ul>
<li><strong>render</strong>：用来渲染视图</li>
<li><strong>send</strong>：用来发送文本内容到客户端</li>
<li><strong>json</strong>：发送json对象到客户端</li>
<li><strong>redirect</strong>：重定向客户端到另一个地址</li>
</ul>
<p>在这里，我们渲染index视图，这个视图在 <strong>views&gt;index.jade</strong>中已经定义了。</p>
<p>这就是一个路由的基础结构。我们现在需要为我们的视频创建一个RESTful API。我们将在1个类似 <strong>/api/videos</strong>的端点中展示我们的视频。</p>
<p>在 <strong>routes</strong> 目录下创建1个新的路由模块叫做 <strong>videos.js</strong> ,然后在文件输入以下代码，之后我会对这段代码进行逐行讲解。</p>
<pre><code><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);
<span class="keyword">var</span> router = express.Router();

<span class="keyword">var</span> monk = <span class="built_in">require</span>(<span class="string">'monk'</span>);
<span class="keyword">var</span> db = monk(<span class="string">'localhost:27017/vidzy'</span>);

router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>{
    <span class="keyword">var</span> collection = db.get(<span class="string">'videos'</span>);
    collection.find({}, <span class="function"><span class="keyword">function</span>(<span class="params">err, videos</span>)</span>{
        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;
        res.json(videos);
    });
});

<span class="built_in">module</span>.exports = router;
</code></pre><p>头两行和之前的一样，我们引入了Express然后获取路由对象。</p>
<p>然后我们引入了Monk，一个用来持久化MongoDB数据的模块。另一个叫做 <strong> Mongoose</strong> 的模块也可以达到这个效果。但是在本教程中，我更倾向用Monk。</p>
<p>之前曾经提过， <strong>require</strong> 方法会根据模块的实现方式来返回一个对象或者方法。当我们引入Monk的时候得到的是一个方法而不是对象。所以 <strong>monk</strong> 变量是一个我们通过调用来访问数据库的方法。</p>
<pre><code><span class="keyword">var</span> db = monk(<span class="string">'localhost:27017/vidzy'</span>);
</code></pre><p>现在来实现我们路由处理器的逻辑。</p>
<pre><code><span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> </span>{
    <span class="keyword">var</span> collection = db.<span class="keyword">get</span>(<span class="string">'videos'</span>);
    collection.find({}, <span class="function"><span class="keyword">function</span><span class="params">(err, videos)</span></span>{
        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;
        res.json(videos);
    });
}
</code></pre><p>首先我们调用 <strong>db</strong> 对象的 <strong>get</strong> 方法，传入集合的名称（<strong>video</strong>）。它将返回一个集合对象。这个集合对象提供了一个数字和一些方法来操作集合上的文档。</p>
<ul>
<li>inser</li>
<li>find</li>
<li>findOne</li>
<li>update</li>
<li>remove</li>
</ul>
<p>这里我们使用 <strong>find</strong> 方法来获取集合中的所有视频。这个方法的第1个参数是一个用来过滤的对象。由于我们需要查询所有视频，我们传入一个空对象。第2个参数是一个回调方法，从数据库返回结果之后调用。这个方法遵循Node回调函数的标准协议模式——“错误优先”。在这个模式中，回调函数的第1个参数是一个错误对象，第2个参数才是返回结果。当你开发更多的Node应用的时候，你将发现更多的这种回调模式。</p>
<p>在这种回调中，我们首先检查 <strong>err</strong> 对象是否被设置。如果在查询视频文档中没有出现错误， <strong>err</strong> 的值是 <strong>null</strong>；否则它将被设置。我们抛出 <strong>err</strong> 来中断程序的执行并且告知用户。如果没有错误，就通过调用 <strong>res.json</strong> 简单地返回一个JSON对象。</p>
<p>看最后一行</p>
<pre><code><span class="function"><span class="keyword">module</span>.<span class="title">exports</span> =</span> router;
</code></pre><p>这一行定义了一个对象返回值，当别的模块引用这个模块时我们将返回这个对象。在这种情况下我们返回路由对象给Express。这个模块的主要功能就是获取路由并注册一些路由配置并返回。</p>
<p>现在还剩下一个小步骤。虽然写了一个模块来为我们的新API配置路由信息，但是我们并没有调用它。再次打开 <strong>app.js</strong> 然后靠近顶部查找以下代码：</p>
<pre><code><span class="keyword">var</span> routes = <span class="built_in">require</span>(<span class="string">'./routes/index'</span>);
<span class="keyword">var</span> users = <span class="built_in">require</span>(<span class="string">'./routes/users'</span>);
</code></pre><p>通过以下代码将我们的路由模块引入到应用程序模块。添加下面这行代码。</p>
<pre><code><span class="keyword">var</span> videos = <span class="built_in">require</span>(<span class="string">'./routes/videos'</span>);
</code></pre><p>将新模块复制给 <strong>videos</strong>变量供之后使用。将 <strong>app.js</strong> 往下滚动一点然后找到下面代码：</p>
<pre><code>app.<span class="keyword">use</span>(<span class="string">'/'</span>, routes);
app.<span class="keyword">use</span>(<span class="string">'/users'</span>, users);
</code></pre><p>添加一行代码：</p>
<pre><code>app.<span class="keyword">use</span>(<span class="string">'/api/videos'</span>, videos);
</code></pre><p>这一行代码的作用就是让 <strong>videos</strong> 模块给任何以 <strong>/api/vides</strong>开头的路由使用。</p>
<p>现在来测试一下我们的API。打开浏览器输入地址  <a href="http://localhost:3000/api/videos" target="_blank" rel="external">http://localhost:3000/api/videos</a>  。你将看到以下JSON对象</p>
<img src="/2015/11/02/mean-3/json.png" alt="json.png" title="">
<p>我使用了 <strong>JSONView</strong> Chrome插件来高亮显示JSON对象。</p>
<p>接下来几步我们将使用Angular来构建前端代码展示这些视频。</p>
<h2 id="第3步：添加Angular">第3步：添加Angular</h2><p>在这一步中，你将学习到Angular的基础知识。如果你已经熟悉Angular，可以跳过这些描述，但是请拷贝这些代码到项目中。</p>
<p>Angular是一个用来构建单页应用（SPA）的非常流行的前端框架。它提供了路由，依赖注入，测试和MVC的结构实现的代码解耦。如果这些听起来太极客了，也不用担心。这一章将带你了解这些特性。</p>
<p>首先，需要添加Angular脚本到应用中。打开 <strong>views&gt;layout.jad</strong> 添加以下3个脚本文件引用在 <strong>head</strong>的末尾（一般考虑性能会放在body标签的末端）。</p>
<pre><code>script<span class="list">(<span class="keyword">src=</span><span class="quoted">'https</span><span class="keyword">://cdnjs</span>.cloudflare.com/ajax/libs/angular.js/1.<span class="number">4.5</span>/angular.js')</span>
script<span class="list">(<span class="keyword">src=</span><span class="quoted">'https</span><span class="keyword">://cdnjs</span>.cloudflare.com/ajax/libs/angular.js/1.<span class="number">4.5</span>/angular-resource.js')</span>
script<span class="list">(<span class="keyword">src=</span><span class="quoted">'https</span><span class="keyword">://cdnjs</span>.cloudflare.com/ajax/libs/angular.js/1.<span class="number">4.5</span>/angular-route.js')</span>
</code></pre><p>确保他们的缩进空格数相等，因为jad对缩进空格非常敏感。Express Generator生成Jade视图的时候将会把两个空格当做缩进。所以你需要遵循同样的缩进并且不能省略。否则将会报错。</p>
<p>这些是什么脚本？第1个是Angular框架的主脚本，第2个是用来调用RESTful APIs，第3个是用来管理路由的。通过路由来定义应用导航对应展示的页面。</p>
<p>下一步，在 <strong>public&gt;javascripts</strong> 路径下创建一个名为 <strong>vidzy.js</strong>的文件，在里面编写javascript代码。</p>
<p>在Angular脚本之后，添加 <strong>vidzy.js</strong> 引用</p>
<pre><code><span class="function"><span class="title">script</span><span class="params">(src=<span class="string">'/javascripts/vidzy.js'</span>)</span></span>
</code></pre><p>请再次确保缩进空格数一致。</p>
<p>现在主要脚本已经引入，可以添加Angular到我们的应用了。添加Angular包括两步：</p>
<ul>
<li>第1步，在HTML元素上添加 <strong>ng-app</strong> 属性。当Angular脚本加载完时，它将在DOM中找到这个属性然后挂载应用程序。</li>
<li>第2步，为应用创建一个Angular模块。Angular应用通常由1个或者多个模块构成。这个简单的应用，你只需要一个 <strong>app</strong> 模块。但是随着应用的扩展，为了提升代码结构和可维护性，你可能需要划分不同的功能到不同的模块。</li>
</ul>
<p>打开 <strong>layout.jade</strong> 添加 <strong>ng-app</strong> 到html元素。</p>
<pre><code>doctype <span class="tag">html</span>
<span class="function"><span class="title">html</span><span class="params">(ng-app=<span class="string">'Vidzy'</span>)</span></span>
</code></pre><p>在Jade中，我们使用括号来为HTML标签添加属性。当该行被Jade模板引擎渲染时，我们将获取以下HTML元素</p>
<pre><code><span class="tag">&lt;<span class="title">html</span> <span class="attribute">ng-app</span>=<span class="value">’Vidzy’</span>&gt;</span>
</code></pre><p>我们给ng-app设置的值就是应用的名称。现在我们需要创建这个模块。</p>
<p>打开 vidzy.js输入以下代码：</p>
<pre><code><span class="keyword">var</span> app = angular.<span class="built_in">module</span>(<span class="string">'Vidzy'</span>, []);
</code></pre><p><strong>Angular</strong>现在是一个全局可用的对象， <strong>module</strong> 方法可以用来定义一个新的模块或者获取已有模块的引用。第1个参数和我们之前在 <strong>ng-app</strong> 中定义的值一致。第2个参数是一个依赖数组。这里传入一个空数组来声明当前模块不依赖任何其他模块。</p>
<p>我们做这些就是为了将Angular挂载到我们的应用上。接下来我们将重构首页，使用Angular来展示数据库中所有的视频。</p>
<h2 id="第4步：用Angular重构首页">第4步：用Angular重构首页</h2><p>Express Generator生成的默认项目使用了Jade做为视图引擎。这些Jade视图在服务端被解析和渲染成HTML然后返回给客户端。这就是很多网页框架如何工作的。但是在本应用中，我们将使用一种不同的构建风格。我们将返回JSON给客户端（Angular）来渲染视图来替代返回HTML。下面说一说这样做的原因。</p>
<p>开始的时候，在本章关于“什么时候使用Node”中，我提到一种通用的场景：Node擅长在文档数据库上构建基于RESTful APIs的应用。通过这种架构，我们不必把时间花在数据转换上。我们存储JSON对象在Mongo中，通过RESTful API导出它们并且直接在客户端进行展示（通过Angular）。JSON就是Javascript和MongoDB的原生对像。所以用它来贯穿整个技术栈，我们就减少了匹配和转换数据的工作。通过从API返回JSON对象然后在客户端渲染视图，来提高性能和可扩展性。因为服务器的CPU将不会被浪费在为大量并发用户渲染视图上。另外，我们可以重用同样的API去构建另一个客户端，例如Iphone和Android app。</p>
<p>在这一步中，我们将用Angular视图来取代首页上默认的Jade视图。</p>
<p>在 <strong>public</strong> 下创建一个新的叫做 <strong>partials</strong> 的文件夹用来存储视图文件。在这个文件夹下创建一个新的文件 <strong>home.html</strong>，在文件中输入</p>
<pre><code><span class="tag">&lt;<span class="title">h1</span>&gt;</span>Home Page<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
</code></pre><p>现在，我们需要告诉Angular当跳转到这个首页时渲染这个视图。我们通过Angular路由来实现这个功能。</p>
<p>在 <strong>vidzy.js</strong> 中，改变 <strong>app</strong> 模块的声明如下：</p>
<pre><code><span class="keyword">var</span> app = angular.<span class="built_in">module</span>(<span class="string">'Vidzy'</span>, [<span class="string">'ngRoute'</span>]);
</code></pre><p>在依赖数组中我添加了一个 <strong>ngRoute</strong> 的引用。 <strong>ngRoute</strong> 是构建Angular模块中用来配置路由的。</p>
<p>在 <strong>app</strong> 模块声明中写下如下代码：</p>
<pre><code>app.config([<span class="string">'$routeProvider'</span>, <span class="keyword">function</span>(<span class="variable">$routeProvider</span>){
<span class="variable">$routeProvider</span>
    .when(<span class="string">'/'</span>, {
        templateUrl: <span class="string">'partials/home.html'</span>
    })
    .otherwise({
        redirectTo: <span class="string">'/'</span>
    });
}]);
</code></pre><p>让我来为你讲解一下。我们使用 <strong>app</strong> 模块的 <strong>config</strong> 方法来为我们的应用提供配置。这个代码将在Angular检测到 <strong>ng-app</strong> 并且视图启动的时候执行。 <strong>config</strong> 方法的参数是一个数组：</p>
<pre><code><span class="tag">app</span><span class="class">.config</span>(<span class="attr_selector">[]</span>);
</code></pre><p>这个数组可以有0个或更多的依赖以及一个函数来实现配置逻辑。这里我们有一个依赖 <strong>$routeProvider</strong>，这是一个在 <strong>ngRoute</strong> 中国定义的模块。这就是我们修改app模块声明来依赖 <strong>ngRoute</strong> 的原因。配置函数接收 <strong>$routeProvider</strong> 作为一个参数</p>
<pre><code>app.config([<span class="string">'$routeProvider'</span>, <span class="keyword">function</span>(<span class="variable">$routeProvider</span>){
}]);
</code></pre><p>在我们的配置函数中，我们使用 <strong>$routeProvider</strong> 的 <strong>when</strong> 方法来配置路由。</p>
<pre><code><span class="variable">$routeProvider</span>
    .<span class="keyword">when</span>(<span class="string">'/'</span>, {
        templateUrl: <span class="string">'partials/home.html'</span>
    })
</code></pre><p>第1个参数(‘/‘)是相对路径。第2个参数是一个对象，定义了路径对应的视图(通过 <strong>templateUrl</strong>)。我们可以多次调用 <strong>when</strong> 方法，每次定义个不同的路由。最后，我们使用 <strong>otherwise</strong> 方法来声明如果用户浏览其他URLs，将被重定向到根路径(‘/‘)。</p>
<p>现在还差一点点。我们只需要做一些小小的改动来时使Jade视图映射到首页。打开 <strong>views&gt;index.jade</strong> 然后改变文件的内容：</p>
<pre><code>extends layout

block <span class="attribute">content</span>
  <span class="function"><span class="title">div</span><span class="params">(ng-view)</span></span>
</code></pre><p>我溢出了视图中之前的内容(Welcom to Express)添加了一个带有 <strong>ng-view</strong> 的 <strong>div</strong>。这个属性告诉Angular在当前dom下渲染视图。通过这个设置，用户首次进入主页时，Jade视图将会在服务端渲染并且返回给客户端。在实际项目中，站点视图将有基础的模板（）例如导航条，logo等）。它也有一个内容区（通过 <strong>ng-view</strong> 声明）由Angular来渲染视图。当用户通过应用来访问页面时，Angular将用不同的Angular视图来替换内容区域。这样避免了整个页面的刷新从而带来了更好的效果。这就是我们称这些应用为单页应用的原因：从本质上说只有一个页面被完整地从服务器下载，然后其他子页面只是简单的用来替换内容区。</p>
<p>注意：我必须再一次强调Jade对空格符非常敏感。在同一个视图中你不能混淆空格和tab键的缩进。Express Genrator默认生成的Jade视图用两个空格键来缩进。确保添加两个空格在 <strong>div(ng-view)</strong> 前面，否则你运行时将报错。</p>
<p>在最后一步之前让我们快速测试一下。回到你的浏览器，输入<a href="http://localhost:3000.你将看见我们通过Angular构建的新首页" target="_blank" rel="external">http://localhost:3000.你将看见我们通过Angular构建的新首页</a></p>
<img src="/2015/11/02/mean-3/home.png" alt="home.png" title="">
<h2 id="第5步：实现控制器">第5步：实现控制器</h2><p>首页已经被正确地挂载了。现在需要从服务端获取视频并渲染到首页。在Angular或其他MVC中，这是控制器的主要职责。视图只负责展现响应的数据，控制器负责为视图获取数据或者处理视图中发生的事件。</p>
<p>现在为我们的首页视图创建一个控制器。打开 <strong>vidzy.js</strong> 并且改变 <strong>app</strong> 模块的声明：</p>
<pre><code><span class="keyword">var</span> app = angular.<span class="built_in">module</span>(<span class="string">'Vidzy'</span>, [<span class="string">'ngResource'</span>, <span class="string">'ngRoute'</span>]);
</code></pre><p>现在我们依赖两个模块：ngResource，用来调用RESTful APIs和ngRoute来管理路由。</p>
<p>接下来在文件末尾输入以下代码来创建一个控制器：</p>
<pre><code>app.controller(<span class="string">'HomeCtrl'</span>, [<span class="string">'$scope'</span>, <span class="string">'$resource'</span>,
    <span class="keyword">function</span>(<span class="variable">$scope</span>, <span class="variable">$resource</span>){
}]);
</code></pre><p>这里我们使用 <strong>app</strong> 模块提供的 <strong>controller</strong> 方法来定义一个新的控制器。</p>
<p>第1个参数是1个字符串，用来定义控制器的名称。按照管理，我们通常在Angular控制器名末尾添加 <strong>Ctrl</strong>。</p>
<p>第2个参数是数组。这个数组可以引用0个或更多的字符串，每个代表了1个控制器的依赖。这里定义了依赖 <strong>$scope</strong> 和 <strong>resource</strong>。这些都是Angular的内部服务，所以她们都有一个前缀”$”。<strong>$scope</strong>用来传递数据给视图，<strong>$resource</strong>用来调用RESTful API。数组中最后一个对象是函数，这个函数就是控制器的主体。在这个例子中，我们的函数获取了两个参数 <strong>$scope</strong> 和 <strong>$resource</strong> 。因为我们依赖了 <strong>$scope</strong> 和 <strong>$resource</strong> 在函数声明之前。</p>
<p>让我们实现控制器的主体部分。在控制器函数内部，输入以下代码</p>
<pre><code>app.controller(<span class="string">'HomeCtrl'</span>, [<span class="string">'$scope'</span>, <span class="string">'$resource'</span>,
<span class="keyword">function</span>(<span class="variable">$scope</span>, <span class="variable">$resource</span>){
    var Videos = <span class="variable">$resource</span>(<span class="string">'/api/videos'</span>);
    Videos.query(function(videos){
        <span class="variable">$scope</span>.videos = videos;
    });
}]);
</code></pre><p>这里我们调用 <strong>$resouce</strong> 方法通过给定的API端点（/api/videos）来获取一个资源对象。这个对象将提供一些方法来访问我们的 <strong>API</strong>。我们用 <strong>query</strong> 方法来获取所有视频。 <strong>query</strong> 方法在查询结果就绪后将得到一个回调函数。这个函数将获得我们从服务端获取的视频。最后我们将视频存储到 <strong>$scope</strong>对象中然后渲染到视图中。记住 <strong>$scope</strong> 就是视图和控制器之间的胶水。</p>
<p>现在我们需要改变视图来渲染视图中的列表。打开 <strong>partials&gt;home.html</strong> 然后输入代码：</p>
<pre><code><span class="tag">&lt;<span class="title">ul</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">ng-repeat</span>=<span class="value">'video in videos'</span> <span class="attribute">ng-bind</span>=<span class="value">"video.title"</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</code></pre><p>我们用ul和li来渲染视频列表。li标签有一个Angular定义的属性叫做 <strong>ng-repeat</strong>。这些属性在Angular中叫做指令，用来为HTML元素添加一些行为。<strong>ng-repeat</strong>属性的值是一个类似js中foreach的表达式。<strong>videos</strong>变量是我们之前在 <strong>$scope</strong>中定义的属性。<strong>video in videos</strong>表示一次从数组中获取一个video。所以li元素将会被数组中的video对象重复渲染。我们用双花括号来编写表达式。这里我们简单的渲染video对象中的title属性在li标签中。</p>
<p>最后我们需要将这个控制器注册到路由上。回到 <strong>vidzy.js</strong>，改变路由配置</p>
<pre><code><span class="class">.when</span>(<span class="string">'/'</span>, {
    <span class="attribute">templateUrl</span>: <span class="string">'partials/home.html'</span>,
    <span class="attribute">controller</span>: <span class="string">'HomeCtrl'</span>
})
</code></pre><p>完成了这些步骤，当用户进入网站根路径时，Angular将展示 <strong>partials/home.html</strong> 并且为它添加 <strong>HomeCtrl</strong> 控制器。</p>
<p>回到浏览器并刷新首页。你将看到视频列表。</p>
<img src="/2015/11/02/mean-3/list.png" alt="list.png" title="">
<p>如果你是一个Angular新手并且还有些困惑，没关系，在接下来的章节中我们将继续使用更多的Angular控制器，视图和路由。</p>
<p>总结下，本章节中，为我们的应用添加了第一个功能。我们开始用RoboMongo来连接MongoDB。我们创建了一个数据库然后填充了一些视频文档。然后我们创建了一个API用Express来导出视频列表。最后，我们添加Angular到应用中来调用API渲染视频列表。</p>
<p>在下一节中，我们将添加另一个功能到应用中。</p>
<blockquote>
<p>这一部分的内容很多，翻译花费了很多时间。原文作者写教程的时候确实是很用心的，这也是我答应作者翻译这篇教程的一个原因。如果想看更多教程可以去作者的官网，如果觉得这篇教程不错，还请点个赞~3q~</p>
</blockquote>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/11/02/mean-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[10段代码打通js学习的任督二脉]]></title>
      <link>http://yalishizhude.github.io/2015/10/25/10/</link>
      <guid>http://yalishizhude.github.io/2015/10/25/10/</guid>
      <pubDate>Sun, 25 Oct 2015 13:37:39 GMT</pubDate>
      <description>
      <![CDATA[<h1 id="前言">前言</h1><p>为了node.js做准备，js的基本功还是很重要的。所以正值1024程序员节的时候所以找了些题目，整理了一下知识点。这篇文章感觉代码太多，难免枯燥，所以文章最后留了个 <strong>彩蛋</strong>给读者。<br>]]>
      
      </description>
      <content:encoded><![CDATA[<h1 id="前言">前言</h1><p>为了node.js做准备，js的基本功还是很重要的。所以正值1024程序员节的时候所以找了些题目，整理了一下知识点。这篇文章感觉代码太多，难免枯燥，所以文章最后留了个 <strong>彩蛋</strong>给读者。<br><a id="more"></a></p>
<hr>
<h1 id="简单回调">简单回调</h1><h2 id="代码">代码</h2><pre><code><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span>{</span>
    console.<span class="built_in">log</span><span class="params">(this.a)</span>;
}
<span class="function"><span class="keyword">function</span> <span class="title">doFoo</span><span class="params">(fn)</span>{</span>
    fn<span class="params">()</span>;
}
<span class="function"><span class="keyword">function</span> <span class="title">doFoo2</span><span class="params">(o)</span>{</span>
    o.foo<span class="params">()</span>;
}
var obj = {
    a: <span class="number">2</span>,
    foo: foo
};
var a = <span class="string">"I'm an a"</span>;
doFoo<span class="params">(obj.foo)</span>;
doFoo2<span class="params">(obj)</span>;
</code></pre><h2 id="分析">分析</h2><p>在Javascript中，this指向函数 <strong>执行时的当前对象，而非声明环境有</strong>。<br>执行doFoo的时候执行环境就是doFoo函数，执行环境为全局。<br>执行doFoo2时是在对象内部调用函数，this指针指向该对象。</p>
<h2 id="结果">结果</h2><pre><code>I<span class="comment">'m an a</span>
<span class="number">2</span>
</code></pre><h1 id="用apply改变函数作用域">用apply改变函数作用域</h1><pre><code><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">somthing</span>)</span>{
    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, somthing);
}
<span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, obj</span>)</span>{
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        <span class="keyword">return</span> fn.apply(obj, <span class="built_in">arguments</span>);
    }
}
<span class="keyword">var</span> obj = {
    a:<span class="number">2</span>
}
<span class="keyword">var</span> bar = bind(foo, obj);
<span class="keyword">var</span> b = bar(<span class="number">3</span>);
<span class="built_in">console</span>.log(b);
</code></pre><h2 id="分析-1">分析</h2><p>apply、call、bind都有个作用就是改变作用域，这里用apply将foo函数的作用域指向obj对象，同时传入参数。<br>再简单分析一下bind函数内部的嵌套，执行bind函数的时候返回的是一个匿名函数，所以执行bar(3)的时候实际上是执行的bind内部的匿名函数，返回的是之前传入的foo函数的执行结果。<br>函数没有返回值的情况下默认返回undefined。</p>
<h2 id="结果-1">结果</h2><pre><code><span class="number">2</span> <span class="number">3</span>
undefined
</code></pre><h1 id="new关键字">new关键字</h1><pre><code><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>)</span>{
    <span class="keyword">this</span>.val = a+b;
}
<span class="keyword">var</span> bar = foo.bind(<span class="literal">null</span>, <span class="string">'p1'</span>);
<span class="keyword">var</span> baz = <span class="keyword">new</span> bar(<span class="string">'p2'</span>);
<span class="built_in">console</span>.log(baz.val);
</code></pre><h2 id="分析-2">分析</h2><p>bind函数的第一个参数为null代表作用域不变，后面的不定参数将会和函数本身的参数按次序进行绑定，绑定之后执行函数只能从未绑定的参数开始传值。</p>
<h2 id="结果-2">结果</h2><pre><code>p1p2
</code></pre><h1 id="自执行函数">自执行函数</h1><pre><code><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span><span class="comment">{
    console.log(this.a);
}</span>
<span class="title">var</span> <span class="title">a</span> = 2;</span>
<span class="keyword">var</span> o = <span class="comment">{a:3,foo:foo}</span>;
<span class="keyword">var</span> p = <span class="comment">{a:4}</span>;
(p.foo=o.foo)();
</code></pre><h2 id="分析-3">分析</h2><p>经常可以看到这样的代码</p>
<pre><code><span class="list">(<span class="keyword">function</span><span class="list">()</span><span class="collection">{
    //...
}</span>)</span><span class="list">()</span>
</code></pre><p>这种代码通常是创建一个立即执行的函数同时避免污染全局变量。<br>很少有人去关注赋值语句执行之后会返回什么结果，其实就是返回当前值。也就是说当括号内执行完赋值之后，返回的是o对象中的foo函数。函数的执行环境中有一个a对象，嗯，就是它了~</p>
<h2 id="答案">答案</h2><pre><code><span class="number">2</span>
</code></pre><h1 id="变量属性">变量属性</h1><pre><code>var <span class="literal">a</span> = []<span class="comment">;</span>
<span class="literal">a</span>[<span class="number">0</span>] = <span class="number">1</span><span class="comment">;</span>
<span class="literal">a</span>['foobar'] = <span class="number">2</span><span class="comment">;</span>
console.log(<span class="literal">a</span>.length)<span class="comment">;</span>
console.log(<span class="literal">a</span>.foobar)<span class="comment">;</span>
</code></pre><h2 id="分析-4">分析</h2><p>当一个变量被声明后，扩充其属性并不会改变原数据类型。</p>
<h2 id="结果-3">结果</h2><pre><code><span class="number">1</span>
<span class="number">2</span>
</code></pre><h1 id="精度问题">精度问题</h1><pre><code>var a = 'foo'<span class="comment">;</span>
a[1] = 'O'<span class="comment">;</span>
console.log(<span class="number">0.1+0.2</span>==0.3||a)<span class="comment">;</span>
</code></pre><h2 id="分析-5">分析</h2><p>当操作小数时请小心，js的小数计算并不精确，所以上面的判断是false。<br>字符串变量是常量。</p>
<h2 id="结果-4">结果</h2><pre><code>foo
</code></pre><h1 id="命名提升">命名提升</h1><pre><code>foo<span class="params">()</span>;
var foo = <span class="number">0</span>;
<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span>{</span>
    console.<span class="built_in">log</span><span class="params">(<span class="number">1</span>)</span>;
}
foo = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    console.<span class="built_in">log</span><span class="params">(<span class="number">2</span>)</span>;
};
</code></pre><h2 id="分析-6">分析</h2><p>声明的变量和命名函数都会被提升到代码的最前面，只不过声明的变量的赋值语句在代码中的位置不变。所以上面这段代码应该被理解为：</p>
<pre><code>var foo;
<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span>{</span>
    console.<span class="built_in">log</span><span class="params">(<span class="number">1</span>)</span>;
}
foo<span class="params">()</span>;
foo = <span class="number">0</span>;
foo = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    console.<span class="built_in">log</span><span class="params">(<span class="number">2</span>)</span>;
};
</code></pre><h2 id="结果-5">结果</h2><pre><code><span class="number">1</span>
</code></pre><h2 id="思考">思考</h2><pre><code>foo<span class="params">()</span>;
var foo = <span class="number">0</span>;
<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span>{</span>
    console.<span class="built_in">log</span><span class="params">(<span class="number">1</span>)</span>;
}
foo<span class="params">()</span>;
foo = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    console.<span class="built_in">log</span><span class="params">(<span class="number">2</span>)</span>;
};
foo<span class="params">()</span>;
</code></pre><p>上面代码的结果：</p>
<pre><code><span class="number">1</span>
报错
</code></pre><h1 id="作用域">作用域</h1><pre><code>foo<span class="params">()</span>;
var a = <span class="literal">true</span>;
<span class="keyword">if</span><span class="params">(a)</span>{
    <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span>{</span>
        console.<span class="built_in">log</span><span class="params">('a')</span>;
    }
} <span class="keyword">else</span> {
    <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span>{</span>
        console.<span class="built_in">log</span><span class="params">('b')</span>;
    }
}
</code></pre><h2 id="分析-7">分析</h2><p>javascript并不是以代码段为作用域，而是以函数。<br>再根据命名提升的原则，所以这段代码应该是这样的：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span>{</span>
    console.<span class="built_in">log</span><span class="params">('a')</span>;
}
<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span>{</span>
    console.<span class="built_in">log</span><span class="params">('b')</span>;
}
foo<span class="params">()</span>;
var a = <span class="literal">true</span>;
<span class="keyword">if</span><span class="params">(a)</span>{
} <span class="keyword">else</span> {
}
</code></pre><h2 id="结果-6">结果</h2><pre><code>b
</code></pre><h1 id="闭包陷阱">闭包陷阱</h1><pre><code><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++){
    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        <span class="built_in">console</span>.log(i);
    }, i*<span class="number">1000</span>);
}
</code></pre><h2 id="分析-8">分析</h2><p>闭包有个重要的作用就是，在内层函数引用外层函数定义的变量时，外层函数的变量不会被会被持久化。<br>这里有个隐藏陷阱就是for循环结束之后i仍然自增了1。</p>
<h2 id="结果-7">结果</h2><pre><code><span class="number">6</span>
<span class="number">6</span>
<span class="number">6</span>
<span class="number">6</span>
<span class="number">6</span>
</code></pre><h1 id="伪闭包">伪闭包</h1><pre><code><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span>{</span>
    console.<span class="built_in">log</span><span class="params">(a)</span>;
}
<span class="function"><span class="keyword">function</span> <span class="title">bar</span> <span class="params">()</span> {</span>
    var a = <span class="number">3</span>;
    foo<span class="params">()</span>;
}
var a = <span class="number">2</span>;
bar<span class="params">()</span>;
</code></pre><h2 id="分析-9">分析</h2><p>闭包是函数的嵌套定义，而不是函数的嵌套调用。</p>
<h2 id="结果-8">结果</h2><pre><code><span class="number">2</span>
</code></pre><h2 id="思考-1">思考</h2><p>如何输出3？</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">bar</span> <span class="params">()</span> {</span>
    <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span>{</span>
        console.<span class="built_in">log</span><span class="params">(a)</span>;
    }
    var a = <span class="number">3</span>;
    foo<span class="params">()</span>;
}
var a = <span class="number">2</span>;
bar<span class="params">()</span>;
</code></pre><h1 id="彩蛋">彩蛋</h1><p>光说不练假把式~<br>一周月内将下题正确答案发送至我邮箱内（邮箱地址请参考博客），将获得本年度我阅读过最优秀的关于AngularJS的电子书一本。</p>
<pre><code><span class="keyword">var</span> Obj = {
    name: <span class="string">'zdl'</span>,
    <span class="keyword">do</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);
    }
}
</code></pre><p><strong>写个对象a继承Obj的方法（不使用new）。</strong></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/10/25/10/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[js高手进阶之路：underscore源码经典（完）]]></title>
      <link>http://yalishizhude.github.io/2015/10/21/underscore-source-4/</link>
      <guid>http://yalishizhude.github.io/2015/10/21/underscore-source-4/</guid>
      <pubDate>Wed, 21 Oct 2015 14:37:08 GMT</pubDate>
      <description>
      <![CDATA[<h1 id="对象">对象</h1><pre><code><span class="number">921</span> _.keys = <span class="function"><span class="keyword">function</span><span class="params">(obj)</span> {</span>
    <span class="keyword">if</span> <span class="params">(!_.isObject<span class="params">(obj)</span>)</span> return [];
    <span class="keyword">if</span> <span class="params">(nativeKeys)</span> return nativeKeys<span class="params">(obj)</span>;
    var keys = [];
    <span class="keyword">for</span> <span class="params">(var key in obj)</span> <span class="keyword">if</span> <span class="params">(_.has<span class="params">(obj, key)</span>)</span> keys.push<span class="params">(key)</span>;
    <span class="comment">// Ahem, IE &lt; 9.</span>
    <span class="keyword">if</span> <span class="params">(hasEnumBug)</span> collectNonEnumProps<span class="params">(obj, keys)</span>;
    return keys;
  };

  <span class="comment">// Retrieve all the property names of an object.</span>
  _.allKeys = <span class="function"><span class="keyword">function</span><span class="params">(obj)</span> {</span>
    <span class="keyword">if</span> <span class="params">(!_.isObject<span class="params">(obj)</span>)</span> return [];
    var keys = [];
    <span class="keyword">for</span> <span class="params">(var key in obj)</span> keys.push<span class="params">(key)</span>;
    <span class="comment">// Ahem, IE &lt; 9.</span>
    <span class="keyword">if</span> <span class="params">(hasEnumBug)</span> collectNonEnumProps<span class="params">(obj, keys)</span>;
    return keys;
  };
</code></pre><p><code>keys</code>和<code>allKeys</code>这两个函数很有对比意义。<br>前者是该对象的枚举属性，先用默认函数处理，再考虑循环遍历，最后考虑老版本浏览器的时候返回默认属性解决方案。<br>后者是该对象的枚举属性以及继承的属性，直接进行深度遍历，然后考虑老版本浏览器的时候直接返回默认属性解决方案。</p>]]>
      
      </description>
      <content:encoded><![CDATA[<h1 id="对象">对象</h1><pre><code><span class="number">921</span> _.keys = <span class="function"><span class="keyword">function</span><span class="params">(obj)</span> {</span>
    <span class="keyword">if</span> <span class="params">(!_.isObject<span class="params">(obj)</span>)</span> return [];
    <span class="keyword">if</span> <span class="params">(nativeKeys)</span> return nativeKeys<span class="params">(obj)</span>;
    var keys = [];
    <span class="keyword">for</span> <span class="params">(var key in obj)</span> <span class="keyword">if</span> <span class="params">(_.has<span class="params">(obj, key)</span>)</span> keys.push<span class="params">(key)</span>;
    <span class="comment">// Ahem, IE &lt; 9.</span>
    <span class="keyword">if</span> <span class="params">(hasEnumBug)</span> collectNonEnumProps<span class="params">(obj, keys)</span>;
    return keys;
  };

  <span class="comment">// Retrieve all the property names of an object.</span>
  _.allKeys = <span class="function"><span class="keyword">function</span><span class="params">(obj)</span> {</span>
    <span class="keyword">if</span> <span class="params">(!_.isObject<span class="params">(obj)</span>)</span> return [];
    var keys = [];
    <span class="keyword">for</span> <span class="params">(var key in obj)</span> keys.push<span class="params">(key)</span>;
    <span class="comment">// Ahem, IE &lt; 9.</span>
    <span class="keyword">if</span> <span class="params">(hasEnumBug)</span> collectNonEnumProps<span class="params">(obj, keys)</span>;
    return keys;
  };
</code></pre><p><code>keys</code>和<code>allKeys</code>这两个函数很有对比意义。<br>前者是该对象的枚举属性，先用默认函数处理，再考虑循环遍历，最后考虑老版本浏览器的时候返回默认属性解决方案。<br>后者是该对象的枚举属性以及继承的属性，直接进行深度遍历，然后考虑老版本浏览器的时候直接返回默认属性解决方案。</p>
<a id="more"></a>
<pre><code><span class="number">31</span> nativeKeys         = Object<span class="class">.keys</span>,
</code></pre><p><code>Object</code>自带的这个<code>keys</code>函数来判断对象的枚举属性很方便，不过也是ECMAScript5新增的函数。</p>
<pre><code><span class="number">1260</span> _.has = <span class="function"><span class="keyword">function</span><span class="params">(obj, key)</span> </span>{
    <span class="keyword">return</span> obj != <span class="literal">null</span> &amp;&amp; hasOwnProperty.call(obj, key);
  };
</code></pre><p><code>hasOwnProperty</code>函数可以有效的判断枚举属性。</p>
<h1 id="函数">函数</h1><pre><code><span class="number">758</span> _.delay = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait</span>) </span>{
    <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);
    <span class="keyword">return</span> setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
      <span class="keyword">return</span> func.apply(<span class="literal">null</span>, args);
    }, wait);
  };
</code></pre><p>一个闭包的好例子，把参数缓存起来供延迟函数加载。</p>
<pre><code><span class="number">870</span> _.after = <span class="function"><span class="keyword">function</span>(<span class="params">times, func</span>) </span>{
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
      <span class="keyword">if</span> (--times &lt; <span class="number">1</span>) {
        <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);
      }
    };
  };
</code></pre><p>这个代码没有太多新意，不过这个函数的使用方法很有意思。但用于多个异步请求的时候非常有用。例如这个例子：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">()</span></span>{<span class="comment">//...}</span>
<span class="keyword">var</span> renderNotes = _.after(notes.length, render);
_.<span class="keyword">each</span>(notes, <span class="function"><span class="keyword">function</span><span class="params">(note)</span> </span>{
  note.asyncSave({success: renderNotes});
});
</code></pre><h1 id="总结">总结</h1><p>underscore之所以经典，一方面它是一个JavaScript实用库，提供了很多工具函数，可以有效地减少我们的代码量，尤其是在对数组和对象的操作上；另一方面是其体现了JavaScript函数式编程的特点，源码中随处可见函数的嵌套。像函数式编程的无状态、高阶编程这些特点和闭包都有着紧密的联系，所以下一阶段希望能透过JavaScript闭包特性的学习一探函数式编程的精妙。</p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/10/21/underscore-source-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[高端唯有定制，把sublime打造成专属的IDE]]></title>
      <link>http://yalishizhude.github.io/2015/10/20/sublime/</link>
      <guid>http://yalishizhude.github.io/2015/10/20/sublime/</guid>
      <pubDate>Tue, 20 Oct 2015 14:49:13 GMT</pubDate>
      <description>
      <![CDATA[<h1 id="前言">前言</h1><p>用过一些IDE，如eclipse、intelliJ，这些IDE是很智能，插件也不少，但个个都不是省油的灯————内存杀手。更受不了的是10G内存eclipse占了2G+之后还是卡。<br>不再做全栈开发之后开始使用轻量级的编辑器，用过的编辑器有Emacs（ctrl到死实在用不惯）、Vim（比较好用，但是速度上以及插件方便程度不如sublime）、ultraedit（据说是黑客必备编辑器，插件太少）、atom（github版的sublime，一直很看好，可惜速度慢我不能接受）、sublime（速度快，插件丰富，还支持vim操作）。最终选择了受众多人追捧的sublime。<br>本人平常开发主要语言是javascript（jquery、angular）、html、css（bootstrap），用到一些工具如gurnt、less、git、svn。除了命令行（其实sublime也有个terminal插件，不过窗口太丑，功能也不强大，所以不如直接<code>win+r</code>来得快），基本上都在sublime这个“IDE”上操作。主要用到了以下插件：<br>]]>
      
      </description>
      <content:encoded><![CDATA[<h1 id="前言">前言</h1><p>用过一些IDE，如eclipse、intelliJ，这些IDE是很智能，插件也不少，但个个都不是省油的灯————内存杀手。更受不了的是10G内存eclipse占了2G+之后还是卡。<br>不再做全栈开发之后开始使用轻量级的编辑器，用过的编辑器有Emacs（ctrl到死实在用不惯）、Vim（比较好用，但是速度上以及插件方便程度不如sublime）、ultraedit（据说是黑客必备编辑器，插件太少）、atom（github版的sublime，一直很看好，可惜速度慢我不能接受）、sublime（速度快，插件丰富，还支持vim操作）。最终选择了受众多人追捧的sublime。<br>本人平常开发主要语言是javascript（jquery、angular）、html、css（bootstrap），用到一些工具如gurnt、less、git、svn。除了命令行（其实sublime也有个terminal插件，不过窗口太丑，功能也不强大，所以不如直接<code>win+r</code>来得快），基本上都在sublime这个“IDE”上操作。主要用到了以下插件：<br><a id="more"></a></p>
<h1 id="代码校验、提示、优化">代码校验、提示、优化</h1><h2 id="Alignment">Alignment</h2><p>美化对其”=”、”:”这些符号。</p>
<h2 id="BracketHighlight">BracketHighlight</h2><p>代码块括号高亮工具，可以自定义括号颜色。<br><img src="/2015/10/20/sublime/brack.png" alt="brack.png" title=""></p>
<h2 id="DocBlockr">DocBlockr</h2><p>在函数上一行输入<code>/**</code>然后回车，神奇的事情发生了，jsdoc就生成了。</p>
<h2 id="Emmet">Emmet</h2><p>以前叫zencoding，快速编写html的一个插件。</p>
<h2 id="HTML-CSS-JS_Prettify">HTML-CSS-JS Prettify</h2><p>html、css、js文件一键优化，但貌似只会优化缩进</p>
<h2 id="AngularJS">AngularJS</h2><p>编写Angular时给出智能提示</p>
<h2 id="JQuery">JQuery</h2><p>JQueryAPI的智能提示</p>
<h2 id="SublimeLinter">SublimeLinter</h2><h2 id="SublimeLinter-jshint">SublimeLinter-jshint</h2><p>配合使用，支持js语法规则校验，每个js编写者必备。</p>
<h1 id="文件保存预览">文件保存预览</h1><h2 id="Local_History">Local History</h2><p>非常推荐，智能缓存编辑过的文件，有点像本地版本管理工具。</p>
<h2 id="Markdown_Preview">Markdown Preview</h2><h2 id="MarkdownEditing">MarkdownEditing</h2><p>写markdown的好搭档，用来显示预览md格式文件的效果。</p>
<h2 id="Minifier">Minifier</h2><p>手动版js文件压缩工具。</p>
<h1 id="版本控制">版本控制</h1><h2 id="SVN">SVN</h2><p>插件功能很像小乌龟TortoiseSVN，在侧边栏上右键操作即可。</p>
<h2 id="Git">Git</h2><p>右键可视化操作，同上。</p>
<h1 id="sublime自身优化">sublime自身优化</h1><h2 id="Dracula_Color_Scheme">Dracula Color Scheme</h2><p>黑白灰，一个极简主题，适合低调的开发者。<br><img src="/2015/10/20/sublime/theme.png" alt="theme.png" title=""></p>
<h2 id="AdvancedNewFile">AdvancedNewFile</h2><p>可以直接用快捷键<code>ctrl+alt+n</code>在sublime的控制台创建文件（夹）</p>
<h1 id="自动化工具">自动化工具</h1><h2 id="Grunt">Grunt</h2><p>IDE都有一个神奇的功能，只要保存代码，就会自动编译发布，这一点可以利用Grunt的watch插件来实现。sublime的Grunt插件只是方便调用项目中已经配置的Gruntfile.js中的任务。用<code>ctrl+p</code>输入<code>grunt</code>即可使用，智能方便。</p>
<p>目前听说的自动化工具有3种：Grunt、Fis、Gulp。<br>Grunt是比较成熟的自动化管理工具，有丰富的插件，将代码自动化分解成一个一个的任务来执行。<br>Fis百度出的自动化工具，应该比较符合国人习惯，如果偷懒可以考虑使用。<br>Gulp比较推荐，类似node.js的流处理效率较高，插件也蛮丰富，据资料显示目前人气最高的自动化工具。</p>
<h1 id="最后补充">最后补充</h1><h2 id="改为vim模式">改为vim模式</h2><p>vim是一个脱离鼠标操作的古老编辑器，vim的操作方式意味着通过模式的切换来执行光标定位、移动、剪切等操作，大大提高编写速度。很高兴的是sublime可以配置成一个”伪vim”。<br>在菜单栏上依次点击<br>Preferences ——&gt; setting-user<br>添加一个属性：<br>“ignored_packages”: [“Vintage”]</p>
<h2 id="更多">更多</h2><p>sublime能够如此之火的原因在于插件非常丰富，在packagecontrol上查看top100的插件逐个筛查也是一种高效的查找方式。<br><a href="https://packagecontrol.io/browse/popular" target="_blank" rel="external">https://packagecontrol.io/browse/popular</a></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/10/20/sublime/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[【译】基于MEAN的全栈开发实例教程2：搭建开发环境]]></title>
      <link>http://yalishizhude.github.io/2015/10/17/mean-2/</link>
      <guid>http://yalishizhude.github.io/2015/10/17/mean-2/</guid>
      <pubDate>Sat, 17 Oct 2015 08:43:39 GMT</pubDate>
      <description>
      <![CDATA[<blockquote>
<p>原文地址 <a href="https://blog.udemy.com/node-js-tutorial">https://blog.udemy.com/node-js-tutorial</a><br>感谢来自Udemy的Samantha来信分享</p>
</blockquote>
<p>最近有些忙，更新可能不及时，如有兴趣希望大家去看原文网站。</p>]]>
      
      </description>
      <content:encoded><![CDATA[<blockquote>
<p>原文地址 <a href="https://blog.udemy.com/node-js-tutorial" target="_blank" rel="external">https://blog.udemy.com/node-js-tutorial</a><br>感谢来自Udemy的Samantha来信分享</p>
</blockquote>
<p>最近有些忙，更新可能不及时，如有兴趣希望大家去看原文网站。</p>
<a id="more"></a>
<h1 id="搭建开发环境">搭建开发环境</h1><p>在我们开始之前，为了开发MEAN应用你需要提前安装一些开发工具。安装这些工具需要15-20分钟。安装完成后，你就有了一个对于MEAN应用的开发环境，并且今后不需要再次安装。<br>所以请先安装我列举的这些工具。如果你已经安装了其中某些工具的话，可以跳过相关部分。</p>
<h2 id="安装Sublime_Text">安装Sublime Text</h2><p>Sublime Text 是一个轻量级而且功能强大的代码编辑器。你可以使用任何编辑器来构建node应用，但是如果你之前没有使用过sublime的话，我建议你尝试一下sublime。你可以在<a href="http://sublimetext.com网站上进行下载。" target="_blank" rel="external">http://sublimetext.com网站上进行下载。</a></p>
<h2 id="安装Mongo">安装Mongo</h2><p>登陆<a href="http://mongodb.org" target="_blank" rel="external">http://mongodb.org</a> 然后点击 <strong>Download MongoDB</strong>。按照官网上提供的文档进行安装。安装过程很简单，不像SQL Server那样需要半个多小时，只需要一两分钟即可。<br>安装完Mongo，你需要按照下面的操作来运行它。你需要创建一个目录用来存储Mongo的数据库文件。这个目录对于当前用于必须有写权限。然后你需要启动MongoD(Mongo Daemon)，这是一个用来处理数据请求的后台进程。<br>默认情况下，MongoD将会把数据存储在系统盘的 <strong>/data/db</strong>目录下(如果提示错误不存在，请自行创建)。在本教程中我建议你保持默认设置。如果你希望修改这个路径，请参考官网上的指令进行修改。<br>接下来让我们在默认配置下启动Mongo<br><strong>对于windows用户</strong><br>用管理员权限打开命令行窗口</p>
<pre><code>&gt; md <span class="command">\data</span><span class="command">\db</span>
&gt; cd “C:<span class="command">\Program</span> Files<span class="command">\MongoDB</span><span class="command">\Server</span>\3.0<span class="command">\bin</span>” (你的MongoDB安装目录)
&gt; mongod
</code></pre><p>注意你可以将MongoD设置为windows服务，这样的话你就不用每次从命令行来启动了。具体设置方法可以参考MongDB的官网。<br>然后你可以看到一个弹出窗口，显示 MongoD listening for network connections. Give access to MongoD.<br><strong>对于Mac用户</strong><br>打开终端</p>
<pre><code><span class="variable">$ </span>sudo mkdir -p /data/db
<span class="variable">$ </span>whoami
moshfeghhamedani
<span class="variable">$ </span>sudo chown moshfeghhamedani /data/db
<span class="variable">$ </span>mongod
</code></pre><p>你将看见MongoD在命令行弹出窗口或者终端中执行正在等待连接。<br><img src="/2015/10/17/mean-2/mongod.png" alt="mongod.png" title=""><br>如果你在启动MongoD时发现了任何问题，最好查看MongoDB的官网然后进行完整安装。</p>
<h2 id="安装Node">安装Node</h2><p>登陆<a href="https://nodejs.org并且点击安装。不管是使用的是windows还是Mac，它将提供合适的装程序。" target="_blank" rel="external">https://nodejs.org并且点击安装。不管是使用的是windows还是Mac，它将提供合适的装程序。</a></p>
<p>安装Node的时候会自动安装NPM（Node Package Manager）。NPM对于Node来说有点像Ruby Gems对于Ruby和NuGet对于.NET。我们通过NPM来下载和安装开源可复用的包/模块到应用中。</p>
<h2 id="安装Express_Generator">安装Express Generator</h2><p>Express Generator是一个用来搭建应用的Node模块。为了安装Express Generator，我们需要打开另一个Mac的终端或者windows的命令提示窗口，<br>然后执行：</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> express-generator</span>
</code></pre><p><code>-g</code>参数代表全局安装。</p>
<h2 id="搭建一个项目">搭建一个项目</h2><p>所有的工具都已经安装完毕。现在让我用Express Generator搭建一个框架。我们将开发一个适用于录像租赁店的叫Vidzy的应用。打开终端窗口，选择一个合适的目录来创建项目：</p>
<pre><code><span class="title">express</span> Vidzy
</code></pre><p>Express Generator 将在Vidzy目录下搭建一个应用。<br>现在在你喜欢的代码编辑器中打开Vidzy文件夹。如果你使用的是Sublime，你可以把这个文件夹拖入Sublime。<br>下面是目录结构</p>
<pre><code>bin
    www
public
    images
    javascripts
    stylesheets
routes
    index<span class="class">.js</span>
    users<span class="class">.js</span>
views
    error<span class="class">.jade</span>
    index<span class="class">.jade</span>
    layout<span class="class">.jade</span>
app<span class="class">.js</span>
    package.son
</code></pre><p><strong>public</strong> 我们将存储一些公共资源到这个目录下，例如javascript文件、样式文件、图片等。<br><strong>routes</strong> 包括一系列的javascript文件，每一个文件都为该应用的给定模块定义了一些路由以及业务逻辑。<br><strong>views</strong> 包括了应用中的视图文件。Express支持很多常见的模板引擎例如：Jade，Haml，EJS，Handlebars等。Jade是默认的模板引擎。<br><strong>app.js</strong>程序的主入口。包括一些程序配置和声明。<br><strong>package.json</strong>每个Node应用都有一个这样的文件。这个文件用来描述当前应用的信息和依赖的插件。<br>我们打开pakcage.json，可能看到如下信息：</p>
<pre><code>{
  "<span class="attribute">name</span>": <span class="value"><span class="string">"Vidzy"</span></span>,
  "<span class="attribute">version</span>": <span class="value"><span class="string">"0.0.0"</span></span>,
  "<span class="attribute">private</span>": <span class="value"><span class="literal">true</span></span>,
  "<span class="attribute">scripts</span>": <span class="value">{
    "<span class="attribute">start</span>": <span class="value"><span class="string">"node ./bin/www"</span>
  </span>}</span>,
  "<span class="attribute">dependencies</span>": <span class="value">{
    "<span class="attribute">body-parser</span>": <span class="value"><span class="string">"~1.13.2"</span></span>,
    "<span class="attribute">cookie-parser</span>": <span class="value"><span class="string">"~1.3.5"</span></span>,
    "<span class="attribute">debug</span>": <span class="value"><span class="string">"~2.2.0"</span></span>,
    "<span class="attribute">express</span>": <span class="value"><span class="string">"~4.13.1"</span></span>,
    "<span class="attribute">jade</span>": <span class="value"><span class="string">"~1.11.0"</span></span>,
    "<span class="attribute">morgan</span>": <span class="value"><span class="string">"~1.6.1"</span></span>,
    "<span class="attribute">serve-favicon</span>": <span class="value"><span class="string">"~2.3.0"</span>
  </span>}
</span>}
</code></pre><p>在文件中，我们定义了程序的名称和版本以及依赖模块。所有这些依赖模块都是用Node编写的模块。</p>
<h2 id="安装依赖模块">安装依赖模块</h2><p>当你通过Express Generator生成一个应用时，这些依赖模块并没有被安装。它们只是在package.json文件中进行了配置。你需要单独安装这些依赖。<br>来安装这些依赖，首先返回到控制台并且输入命令：</p>
<pre><code><span class="built_in">cd</span> Vidzy
npm install
</code></pre><p>安装需要花费一些时间。NPM将参照 <strong>package.json</strong> 文件中定义的依赖。然后它将从NPM仓库中下载这些依赖到一个叫做 <strong>node_modules</strong> 的目录中。让我们看看这些模块吧。<br>在 <strong>Vidzy</strong> 文件夹中，进入 <strong>node_modules/express</strong>，注意这个目录下有另一个 <strong>package.json</strong>用来定义Express.js的依赖模块。所以，这里也有另一个 <strong>node_modules</strong>目录来存储依赖模块。这就是一个Node应用的常见目录结构。每一个模块都有一个 <strong>package.json</strong>文件和一个 <strong>node_modules</strong> 文件夹。</p>
<h2 id="安装Nodemon">安装Nodemon</h2><p>当你启动Node应用的时候，一个用来接收请求的最基本的web服务器就在3000端口上启动了。如果你修改了代码，这些改变将不会生效直到你重启了服务器。频繁的重启服务器来使代码生效是一件蛋疼的事情。为了解决这个问题，我们使用 <strong>Nodemon</strong>，这个模块在检测到源文件修改时自动重启web服务器。<br>安装Nodemon：</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> nodemon -<span class="keyword">g</span></span>
</code></pre><h2 id="安装Monk">安装Monk</h2><p>Monk是一个用来读写MongoDB的Node模块。<br>安装monk：</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> monk <span class="comment">--save</span></span>
</code></pre><p><code>--save</code>参数告诉NPM将这个依赖加入到package.json文件中。这样做的好处就是你将代码提交到版本库，别人将代码签出，所有的依赖模块都可以从就package.json中读取出来。（也就是说我们不需要保存这些第三方模块，任何时候我们搭建项目只需要读取这个package.json文件即可安装，减少了项目的维护代码）。然后只需要简单的执行 <strong>npm install</strong>，然后自动安装这些引用模块。这就是我们搭建应用框架的时候需要做的事情。</p>
<h2 id="运行应用">运行应用</h2><p>太棒了！我们已经安装了所有需要的工具。现在是时候来运行应用了。从控制台进入Vidzy目录输入以下命令：</p>
<pre><code>nodemon
</code></pre><p>Nodemon将在3000端口上启动你的web服务器。你可能会看到一个弹出窗口显示Node正在侦听连接。<br>现在启动你的浏览器跳转到</p>
<p><a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a></p>
<p>这就是你的第一个express应用。</p>
<img src="/2015/10/17/mean-2/express.png" alt="express.png" title="">
<p>接下来的几个章节，我们将为这个录像租赁店应用开发各种功能。</p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/10/17/mean-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[js高手进阶之路：underscore源码经典（三）]]></title>
      <link>http://yalishizhude.github.io/2015/10/17/underscore-source-3/</link>
      <guid>http://yalishizhude.github.io/2015/10/17/underscore-source-3/</guid>
      <pubDate>Sat, 17 Oct 2015 06:00:48 GMT</pubDate>
      <description>
      <![CDATA[<p>后面的代码真是越看越难理解，经常需要结合内部/接口函数一起，所以采用跳读的方式解析，基本按照模块由易到难的顺序解析。<br>]]>
      
      </description>
      <content:encoded><![CDATA[<p>后面的代码真是越看越难理解，经常需要结合内部/接口函数一起，所以采用跳读的方式解析，基本按照模块由易到难的顺序解析。<br><a id="more"></a></p>
<pre><code><span class="number">456</span>  _.initial = function(<span class="built_in">array</span>, n, guard) {
    <span class="keyword">return</span> slice.call(<span class="built_in">array</span>, <span class="number">0</span>, Math.max(<span class="number">0</span>, <span class="built_in">array</span>.length - (n == null || guard ? <span class="number">1</span> : n)));
  };
</code></pre><p>这个guard参数说是保证默认返回第一个值，不过我看了很久觉得意义不大，猜测可能是以前的接口。这里的<code>slice = Array.prototype.slice</code>。这里有两个地方比较好，一是用Array的原型函数来处理array参数，这样可以避免判断array是否数组，二是用max来避免超出数组长度。</p>
<pre><code><span class="number">671</span> _.range = function(start, stop, <span class="built_in">step</span>) {
    <span class="keyword">if</span> (arguments.<span class="built_in">length</span> &lt;= <span class="number">1</span>) {
      stop = start || <span class="number">0</span>;
      start = <span class="number">0</span>;
    }
    <span class="built_in">step</span> = <span class="built_in">step</span> || <span class="number">1</span>;

    var <span class="built_in">length</span> = Math.<span class="built_in">max</span>(Math.<span class="built_in">ceil</span>((stop - start) / <span class="built_in">step</span>), <span class="number">0</span>);
    var range = Array(<span class="built_in">length</span>);

    <span class="keyword">for</span> (var idx = <span class="number">0</span>; idx &lt; <span class="built_in">length</span>; idx++, start += <span class="built_in">step</span>) {
      range[idx] = start;
    }

    <span class="keyword">return</span> range;
  };
</code></pre><p>这个函数本什没有什么特别的，只不过我在调用的时候将step赋值为小数，就出现了javascript著名的精度问题。网上应该有不少的解决方案，这里提供一种目前我在项目中用到的解决方法：将数字转为字符串在去小数点之后转为整数进行计算，计算完成后转字符串加上小数点再转成小数，举个例子</p>
<pre><code><span class="number">1.11</span> =<span class="function">=&gt;</span> <span class="string">"1.11"</span> =<span class="function">=&gt;</span> <span class="string">"111"</span> =<span class="function">=&gt;</span> <span class="number">111</span>
<span class="number">2.2</span> =<span class="function">=&gt;</span> <span class="string">"2.2"</span> =<span class="function">=&gt;</span> <span class="string">"220"</span> =<span class="function">=&gt;</span> <span class="number">220</span>
<span class="number">111</span>+<span class="number">220</span> =<span class="function">=&gt;</span> <span class="number">331</span> =<span class="function">=&gt;</span> <span class="string">"331"</span> =<span class="function">=&gt;</span> <span class="string">"3.31"</span> =<span class="function">=&gt;</span> <span class="number">3.31</span>
</code></pre><p>数组代码看得累了，从后面的看起吧~</p>
<pre><code><span class="number">1269</span> _.noConflict = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  root._ = previousUnderscore;
  <span class="keyword">return</span> <span class="keyword">this</span>;
};
</code></pre><p>这个让渡函数其实原理比较简单，就是初始化underscore前 <code>previousUnderscore=window._</code>对原有对象进行储存，如果需要让渡避免冲突，则进行还原同时返回当前underscore对象。再来看看JQuery的实现原理：</p>
<pre><code>noConflict: <span class="function"><span class="keyword">function</span>(<span class="params"> deep </span>) </span>{
  <span class="keyword">if</span> ( <span class="built_in">window</span>.$ === jQuery ) {
    <span class="built_in">window</span>.$ = _$;
  }

  <span class="keyword">if</span> ( deep &amp;&amp; <span class="built_in">window</span>.jQuery === jQuery ) {
    <span class="built_in">window</span>.jQuery = _jQuery;
  }

  <span class="keyword">return</span> jQuery;
}
</code></pre><p>刚开始看的时候犯2了，函数可以用<code>===</code>来比较？不是只能比较简单的数据对象？呵呵，其实这个是通过引用地址来判断的，因为之前初始化的时候<code>window.$=JQuery</code>所以$会指向JQuery的地址，所以可以这样判断。后面一个if考虑到JQuery这个变量名也被占用的时候，也进行让渡，最后返回JQuery对象。可能是考虑多版本的情况吧~</p>
<pre><code><span class="number">1487</span>  _.mixin = <span class="function"><span class="keyword">function</span><span class="params">(obj)</span> </span>{
  _.<span class="keyword">each</span>(_.functions(obj), <span class="function"><span class="keyword">function</span><span class="params">(name)</span> </span>{
    <span class="keyword">var</span> func = _[name] = obj[name];
    _.prototype[name] = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
      <span class="keyword">var</span> args = [<span class="keyword">this</span>._wrapped];
      push.apply(args, arguments);
      <span class="keyword">return</span> result(<span class="keyword">this</span>, func.apply(_, args));
    };
  });
};

<span class="comment">// Add all of the Underscore functions to the wrapper object.</span>
_.mixin(_);
</code></pre><p>这个用于扩展underscore自身的接口函数，通过循环遍历对象来浅拷贝对象属性。这里考虑到函数的实例化，所以一方面将函数作为内部函数使用，同时扩展到prototype属性上。考虑得比较周全。</p>
<pre><code>1469  _.chain =<span class="function"> function(</span>obj<span class="function">)</span> {
  var<span class="instruction"> instance </span>=<span class="function"> _(</span>obj<span class="function">)</span>;
  instance._chain = true;
 <span class="instruction"> return </span>instance;
};
</code></pre><p>这个函数让underscore支持链式调用，链式调用写起来很美观，但是调试略显不方便。结合之前的代码来看，underscore实现链式调用的基本原理是：将参数缓存在内部属性_wrapped中，调用函数时传入该属性值，执行后返回当前this指针。直到执行value函数时返回_wraped中的值。</p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/10/17/underscore-source-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[【译】基于MEAN的全栈开发实例教程1：前言]]></title>
      <link>http://yalishizhude.github.io/2015/10/13/mean-1/</link>
      <guid>http://yalishizhude.github.io/2015/10/13/mean-1/</guid>
      <pubDate>Mon, 12 Oct 2015 16:03:42 GMT</pubDate>
      <description>
      <![CDATA[<blockquote>
<p>原文地址 <a href="https://blog.udemy.com/node-js-tutorial">https://blog.udemy.com/node-js-tutorial</a><br>感谢来自Udemy的Samantha来信分享</p>
</blockquote>
<h1 id="什么是node？">什么是node？</h1><p>Node是一个开源，跨平台的用来执行javascript的运行环境。它建立在google的v8引擎上，而v8引擎正是google chrome浏览器的执行引擎，能够快速的将javascript代码转为原生的机器码。<br>在Node诞生之前，javascript只能在浏览器执行。在2009年，Ryan Dahl使用开源的google v8 javascript引擎来构建node，使它成为一个独立于浏览器之外的javascript运行环境。这使得javascript开发者能够在服务端使用javascript来构建大部分的web apis。</p>
<blockquote>
<p>题外话：我觉得有两个技术的普及让web前端的有了较大的发展。一是混合应用的出现，包括移动端的混合应用如phone gap、ionic等框架和PC端的混合应用如hex、酷狗音乐等，这一技术的诞生让前端工作从简单的类似制作ppt一般地展现页面效果的工作升级成了开发应用程序的级别；二是node.js的出现，让js可以运用于服务端开发，让前端工程师能低门槛地转成js全栈，通过node.js开发后端又可以与数据库连接，让js开发人员可以参与到web的前端、后端、数据库整个系统，从而为js工程师提供了一条晋升到web架构师的有利通道，为js工程师插上了一双翅膀。</p>
</blockquote>]]>
      
      </description>
      <content:encoded><![CDATA[<blockquote>
<p>原文地址 <a href="https://blog.udemy.com/node-js-tutorial" target="_blank" rel="external">https://blog.udemy.com/node-js-tutorial</a><br>感谢来自Udemy的Samantha来信分享</p>
</blockquote>
<h1 id="什么是node？">什么是node？</h1><p>Node是一个开源，跨平台的用来执行javascript的运行环境。它建立在google的v8引擎上，而v8引擎正是google chrome浏览器的执行引擎，能够快速的将javascript代码转为原生的机器码。<br>在Node诞生之前，javascript只能在浏览器执行。在2009年，Ryan Dahl使用开源的google v8 javascript引擎来构建node，使它成为一个独立于浏览器之外的javascript运行环境。这使得javascript开发者能够在服务端使用javascript来构建大部分的web apis。</p>
<blockquote>
<p>题外话：我觉得有两个技术的普及让web前端的有了较大的发展。一是混合应用的出现，包括移动端的混合应用如phone gap、ionic等框架和PC端的混合应用如hex、酷狗音乐等，这一技术的诞生让前端工作从简单的类似制作ppt一般地展现页面效果的工作升级成了开发应用程序的级别；二是node.js的出现，让js可以运用于服务端开发，让前端工程师能低门槛地转成js全栈，通过node.js开发后端又可以与数据库连接，让js开发人员可以参与到web的前端、后端、数据库整个系统，从而为js工程师提供了一条晋升到web架构师的有利通道，为js工程师插上了一双翅膀。</p>
</blockquote>
<a id="more"></a>
<h1 id="就业市场">就业市场</h1><p>近年node非常地受欢迎并且很多大公司（例如IBM，微软，雅虎，LinkedIn，PayPal），已经开始采用它了。<br>正如你在下面来自于indeed.com的就业趋势图中所见，市场对于node.js开发者的需求正在快速增长。<br><img src="/2015/10/13/mean-1/job.png" alt="job.png" title=""><br>虽然在数量方面，node开发者的市场需求量不如Ruby on Rails以及很多其它框架那样，但是我认为这种情况很快会改变。<br>2013年，从一些官方博客中得知，PayPal从Java转向了node.js，LinkedIn也从Rails转向了node。</p>
<h1 id="我喜欢node的原因">我喜欢node的原因</h1><p>我很早就采用了ASP.NET MVC框架，并且使用它进行了数年的web应用开发。关于ASP.NET MVC有一件事让我很不爽的就是，在语言的编程风格和习惯上，从服务端到客户端会有较大的转变。然而C#和javascript都是类似C语言风格的编程语言，当然用C#来编程还是和javascript有很大的不同。这就是为什么很多ASP.NETweb开发者通常只擅长两种语言中的一种而不是全部擅长，所以他们会将自己分类成“后端”或“前端”开发者。同样的情况发生在Ruby on Rails,PHP,Python 等开发者身上。<br>采用node的话，你可以在服务端和客户端同时使用javascript。这意味着更简洁和更一致的代码库以及更少的转换和映射。当然一个好的javascript开发者能同时编写服务端和客户端的代码将是也是非常牛叉的。</p>
<h1 id="什么时候使用node">什么时候使用node</h1><p>node不是一个银弹。它是专为I/O密集型操作和快速构建可扩展性的实时网络应用而设计的。比如说一些在线游戏，协作工具，聊天系统等。通过node，你可以用最少的系统资源来服务大量的客户端，这就是为什么它为高可扩展性而设计。<br>对于搭建在类似于MongoDB的文档数据库的API服务器，node也是一个非常不错的选择。你将文档数据以json对象的格式存储在mongo中，然后通过RESTful API的来操作它们。当从数据库读写数据时，并不需要将JSON和其它类型进行转换。在本教程中，我们将构建一个node 应用通过以上提到的这种方式。<br>根结node的结构特点，它应该避免用于CPU密集型操作。本教程中我将从实例开始介绍node而不是从架构深入讲解node以及为什么它不适用与CPU密集型应用。这些深入讲解的部分我将很快发布在Udemy上。如果你有兴趣，请提交到我的<a href="http://programmingwithmosh.com/node-js-course-coming-soon/" target="_blank" rel="external">邮箱</a>。</p>
<h1 id="mean全栈开发">mean全栈开发</h1><p>构建node应用有很多选择，但mean全栈式框架最近变得非常流行。mean代表的是：</p>
<ul>
<li>MongoDB：我盟用来存储数据的数据库引擎。</li>
<li>Express.js：服务器端用来构建web应用程序的框架，类似于ASP.NET MVC或Rails。</li>
<li>Angular：用来构建web应用的前端框架</li>
<li>Node.js：javascript运行环境。<br>通过mean，你可以将文档数据以json对象的格式存储在mongo中，然后通过基于node和express搭建的RESTful API服务器的来操作它们。通过Angular构建客户端来操作这些API并渲染视图给用户。这意味着你在你的代码中，你将使用单一的统一的语言（javascript），结果就是让代码更加具有一致性和可维护性。另外的好处就是，你将花费更少的时间来处理JSON和其它格式之间的转换。所有这些将导致更好的性能和更高的开发效率。<br>如果你从未使用过MongoDB或者Angular，完全不用担心。在本教程中我将将会你这些技术的基础知识。<br>好了，有了足够的理论支持。是时候用mean来始构建一个应用了。</li>
</ul>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/10/13/mean-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[js高手进阶之路：underscore源码经典（二）]]></title>
      <link>http://yalishizhude.github.io/2015/10/12/underscore-source-2/</link>
      <guid>http://yalishizhude.github.io/2015/10/12/underscore-source-2/</guid>
      <pubDate>Mon, 12 Oct 2015 13:14:55 GMT</pubDate>
      <description>
      <![CDATA[<p>先看一下两个比较重要的内部函数<br>]]>
      
      </description>
      <content:encoded><![CDATA[<p>先看一下两个比较重要的内部函数<br><a id="more"></a></p>
<pre><code><span class="number">63</span> var optimizeCb = <span class="function"><span class="keyword">function</span><span class="params">(func, context, argCount)</span></span> {
    <span class="keyword">if</span> (context === void <span class="number">0</span>) <span class="keyword">return</span> func;
    switch (argCount == null ? <span class="number">3</span> : argCount) {
      <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(value)</span></span> {
        <span class="keyword">return</span> func.<span class="keyword">call</span>(context, <span class="keyword">value</span>);
      };
      <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(value, other)</span></span> {
        <span class="keyword">return</span> func.<span class="keyword">call</span>(context, <span class="keyword">value</span>, other);
      };
      <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(value, index, collection)</span></span> {
        <span class="keyword">return</span> func.<span class="keyword">call</span>(context, <span class="keyword">value</span>, <span class="built_in">index</span>, collection);
      };
      <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(accumulator, value, index, collection)</span></span> {
        <span class="keyword">return</span> func.<span class="keyword">call</span>(context, accumulator, <span class="keyword">value</span>, <span class="built_in">index</span>, collection);
      };
    }
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span> {
      <span class="keyword">return</span> func.apply(context, arguments);
    };
  };
</code></pre><p>这个函数是underscore内部很重要的函数，主要用来执行函数并改变所执行函数的作用域，最后加了一个argCount参数来指定参数个数，对参数个数小于等于4的情况进行分类处理。对不同参数的解释大概是：<br>1的情况一般是用在接受单值的情况，比如times,sortedIndex之类的函数。<br>2的情况据说是给比如jQuery,zepto事件绑定，代理什么的，但是在源代码中没有看到被调用。<br>3的情况用于迭代器函数，比如foreach,map,pick等。<br>4的情况用reduce和reduceRight函数。</p>
<pre><code><span class="number">87</span> <span class="keyword">var</span> cb = function(<span class="keyword">value</span>, context, argCount) {
    <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="keyword">null</span>) <span class="keyword">return</span> _.identity;
    <span class="keyword">if</span> (_.isFunction(<span class="keyword">value</span>)) <span class="keyword">return</span> optimizeCb(<span class="keyword">value</span>, context, argCount);
    <span class="keyword">if</span> (_.isObject(<span class="keyword">value</span>)) <span class="keyword">return</span> _.matcher(<span class="keyword">value</span>);
    <span class="keyword">return</span> _.property(<span class="keyword">value</span>);
  };
</code></pre><p>这也是一个比较常用的内部函数，只是对参数进行了判断：如果是函数则返回上面说到的回调函数；如果是对象则返回一个能判断对象是否相等的函数；默认返回一个获取对象属性的函数。</p>
<pre><code><span class="number">140</span> <span class="number">_</span>.<span class="keyword">each</span> = <span class="number">_</span>.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, <span class="keyword">length</span>;
    <span class="keyword">if</span> (isArrayLike(obj)) {
      <span class="keyword">for</span> (i = <span class="number">0</span>, <span class="keyword">length</span> = obj.<span class="keyword">length</span>; i &lt; <span class="keyword">length</span>; i++) {
        iteratee(obj[i], i, obj);
      }
    } <span class="keyword">else</span> {
      var <span class="keyword">keys</span> = <span class="number">_</span>.<span class="keyword">keys</span>(obj);
      <span class="keyword">for</span> (i = <span class="number">0</span>, <span class="keyword">length</span> = <span class="keyword">keys</span>.<span class="keyword">length</span>; i &lt; <span class="keyword">length</span>; i++) {
        iteratee(obj[<span class="keyword">keys</span>[i]], <span class="keyword">keys</span>[i], obj);
      }
    }
    <span class="keyword">return</span> obj;
  };

  <span class="regexp">//</span> Return the results of applying the iteratee to <span class="keyword">each</span> element.
  <span class="number">_</span>.<span class="keyword">map</span> = <span class="number">_</span>.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var <span class="keyword">keys</span> = !isArrayLike(obj) &amp;&amp; <span class="number">_</span>.<span class="keyword">keys</span>(obj),
        <span class="keyword">length</span> = (<span class="keyword">keys</span> || obj).<span class="keyword">length</span>,
        results = Array(<span class="keyword">length</span>);
    <span class="keyword">for</span> (var <span class="keyword">index</span> = <span class="number">0</span>; <span class="keyword">index</span> &lt; <span class="keyword">length</span>; <span class="keyword">index</span>++) {
      var currentKey = <span class="keyword">keys</span> ? <span class="keyword">keys</span>[<span class="keyword">index</span>] : <span class="keyword">index</span>;
      results[<span class="keyword">index</span>] = iteratee(obj[currentKey], currentKey, obj);
    }
    <span class="keyword">return</span> results;
  };
</code></pre><p>从代码上看，each函数是用来遍历操作数组/对象，map用来处理数组/对象后并以数组的形式返回结果。至于forEach和collect在API文档中看不到，应该是为了兼容以前老版本做的别名处理。</p>
<pre><code><span class="number">170</span> function createReduce(dir) {
    // <span class="type">Optimized</span> <span class="keyword">iterator</span> function <span class="keyword">as</span> <span class="keyword">using</span> arguments.length
    // <span class="keyword">in</span> the main function will deoptimize the, see <span class="comment">#1991.</span>
    function <span class="keyword">iterator</span>(obj, iteratee, memo, keys, index, length) {
      <span class="keyword">for</span> (; index &gt;= <span class="number">0</span> &amp;&amp; index &lt; length; index += dir) {
        <span class="keyword">var</span> currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      <span class="keyword">return</span> memo;
    }

    <span class="keyword">return</span> function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, <span class="number">4</span>);
      <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),
          length = (keys || obj).length,
          index = dir &gt; <span class="number">0</span> ? <span class="number">0</span> : length - <span class="number">1</span>;
      // <span class="type">Determine</span> the initial value <span class="keyword">if</span> none <span class="keyword">is</span> provided.
      <span class="keyword">if</span> (arguments.length &lt; <span class="number">3</span>) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      <span class="keyword">return</span> <span class="keyword">iterator</span>(obj, iteratee, memo, keys, index, length);
    };
  }
</code></pre><p>这个是reduce和reduceRight调用的内部函数，将memo这个变量作为入参传递给iterator函数，调用自定义的iteratee函数进行循环处理，每次处理完的结果都赋值给memo变量，最后返回memo变量的结果。这里有两个问题</p>
<ul>
<li>为什么这里不按照常理逻辑来写代码而要用闭包呢？闭包大致有这么几个作用：避免命名冲突；私有化变量；变量持久化。这里的作用主要就是变量（函数）持久化，好处就是重复调用的时候不需要再重新创建函数，从而提升执行速度。</li>
<li><p>为什么要用两层闭包呢？第一层闭包持久化iterator函数，调用reduce和reduceRight函数避免重复新建函数。第二层闭包保存keys,index,length这些变量。</p>
<p>  263 _.invoke = function(obj, method) {</p>
<pre><code><span class="keyword">var</span> args = slice.call(arguments, <span class="number">2</span>);
<span class="keyword">var</span> isFunc = _.isFunction(<span class="keyword">method</span>);
<span class="keyword">return</span> _.map(obj, function(value) {
  <span class="keyword">var</span> func = isFunc ? <span class="keyword">method</span> : value[<span class="keyword">method</span>];
  <span class="keyword">return</span> func == null ? func : func.apply(value, args);
});
</code></pre><p>  };<br>这里用<code>slice.call(arguments, 2)</code>来获取后面的不定参数，然后用<code>func.apply(value, args)</code>来传入该参数比较有意思。</p>
</li>
</ul>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/10/12/underscore-source-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[js高手进阶之路：underscore源码经典（一）]]></title>
      <link>http://yalishizhude.github.io/2015/09/22/underscore-source/</link>
      <guid>http://yalishizhude.github.io/2015/09/22/underscore-source/</guid>
      <pubDate>Tue, 22 Sep 2015 13:51:10 GMT</pubDate>
      <description>
      <![CDATA[<blockquote>
<p>underscore 源码版本 1.8.2</p>
</blockquote>
<h3 id="起因">起因</h3><p>很多人向我推荐研究js，可以看看一些第三方js类库的源码，而源码之中最好解读也最简短的就是underscore，它也是我平常比较喜欢的一个库，因为它性价比高：体积小、能力强。打开一看，才1000多行，试着读了一下，确实很值得一看，所以对精彩部分做了一下整理。</p>
<h3 id="闭包">闭包</h3><p>整个函数在一个闭包中，避免污染全局变量。通过传入this（其实就是window对象）来改变函数的作用域。和jquery的自执行函数其实是异曲同工之妙。这种传入全局变量的方式一方面有利于代码阅读，另一方面方便压缩。<br>underscore写法：</p>
<pre><code><span class="list">(<span class="keyword">function</span><span class="list">()</span><span class="collection">{
    ...
}</span>.call<span class="list">(<span class="keyword">this</span>)</span>)</span><span class="comment">;</span>
</code></pre><p>jquery写法：</p>
<pre><code><span class="list">(<span class="keyword">function</span><span class="list">(<span class="keyword">window</span>, undefined)</span> <span class="collection">{
    ...
}</span>)</span><span class="list">(<span class="keyword">window</span>)</span><span class="comment">;</span>
</code></pre>]]>
      
      </description>
      <content:encoded><![CDATA[<blockquote>
<p>underscore 源码版本 1.8.2</p>
</blockquote>
<h3 id="起因">起因</h3><p>很多人向我推荐研究js，可以看看一些第三方js类库的源码，而源码之中最好解读也最简短的就是underscore，它也是我平常比较喜欢的一个库，因为它性价比高：体积小、能力强。打开一看，才1000多行，试着读了一下，确实很值得一看，所以对精彩部分做了一下整理。</p>
<h3 id="闭包">闭包</h3><p>整个函数在一个闭包中，避免污染全局变量。通过传入this（其实就是window对象）来改变函数的作用域。和jquery的自执行函数其实是异曲同工之妙。这种传入全局变量的方式一方面有利于代码阅读，另一方面方便压缩。<br>underscore写法：</p>
<pre><code><span class="list">(<span class="keyword">function</span><span class="list">()</span><span class="collection">{
    ...
}</span>.call<span class="list">(<span class="keyword">this</span>)</span>)</span><span class="comment">;</span>
</code></pre><p>jquery写法：</p>
<pre><code><span class="list">(<span class="keyword">function</span><span class="list">(<span class="keyword">window</span>, undefined)</span> <span class="collection">{
    ...
}</span>)</span><span class="list">(<span class="keyword">window</span>)</span><span class="comment">;</span>
</code></pre><a id="more"></a>
<hr>
<h3 id="原型赋值">原型赋值</h3><pre><code><span class="number">18</span> <span class="keyword">var</span> ArrayProto = <span class="keyword">Array</span>.prototype, ObjProto = <span class="keyword">Object</span>.prototype, FuncProto = <span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span>;</span>
</code></pre><p>Array,Object,Function这些本质都是函数，获取函数原型属性prototype也是为了便于压缩。简单解释一下，如果代码中要扩展属性，可能这样写</p>
<pre><code>Object<span class="class">.prototype</span><span class="class">.xxx</span> = ...
</code></pre><p>而这种代码是不可压缩的，<code>Object</code>,<code>prototype</code>这些名字改了浏览器就不认得了。</p>
<p>但是上面的代码中创建了<code>ObjProto</code>之后，源生代码经过压缩之后，<code>ObjProto</code>就可能命名成a变量，那么原来的代码就压缩成</p>
<pre><code><span class="tag">a</span><span class="class">.xxx</span> = ...
</code></pre><p>一个小建议就是凡事一段代码被使用两次以上都建议定义变量(函数)，有利于修改和压缩代码。</p>
<h3 id="格式">格式</h3><pre><code><span class="number">29</span> <span class="keyword">var</span>
nativeIsArray      = <span class="keyword">Array</span>.isArray,
nativeKeys         = <span class="keyword">Object</span>.keys,
nativeBind         = FuncProto.bind,
nativeCreate       = <span class="keyword">Object</span>.create;
</code></pre><p>这种定义的方式省略了多余的var，格式也美观，让我想到了sublime中的一个插件alignment。</p>
<h3 id="数据判断">数据判断</h3><pre><code><span class="number">1194</span> _.isElement = <span class="function"><span class="keyword">function</span><span class="params">(obj)</span> </span>{
    <span class="keyword">return</span> !!(obj &amp;&amp; obj.nodeType === <span class="number">1</span>);
  };
</code></pre><p>判断是否为dom，dom的nodeType属性值为1。这里用<code>!!</code>强转为boolean值</p>
<pre><code><span class="number">1200</span> _.isArray = nativeIsArray || <span class="function"><span class="keyword">function</span><span class="params">(obj)</span> </span>{
    <span class="keyword">return</span> toString.call(obj) === <span class="string">'[object Array]'</span>;
  };
</code></pre><p>判断是否为数组。由于Array.isArray函数是ECMAScript 5新增函数，所以为了兼容之前的版本，在原生判断函数不存在的情况下，后面重写了一个判断函数。用call函数来改变作用域可以避免当obj没有toString函数报错的情况。</p>
<pre><code><span class="number">1205</span> _.isObject = function(obj) {
    var <span class="keyword">type</span> = <span class="keyword">typeof</span> obj;
    <span class="keyword">return</span> <span class="keyword">type</span> === <span class="string">'function</span>' || <span class="keyword">type</span> === <span class="string">'object</span>' &amp;&amp; !!obj;
};
</code></pre><p>判断是否为对象。先用typeof判断数据类型。函数也属于对象，但是由于typeof null也是object，所以用!!obj来区分这种情况。</p>
<pre><code><span class="number">1219</span> <span class="keyword">if</span> (!_.isArguments(<span class="built_in">arguments</span>)) {
_.isArguments = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>{
  <span class="keyword">return</span> _.has(obj, <span class="string">'callee'</span>);
};
}
</code></pre><p>判断是否为arguments,很简单，arguments有个特有属性callee。</p>
<pre><code><span class="number">1239</span> _.isNaN = <span class="function"><span class="keyword">function</span><span class="params">(obj)</span> </span>{
<span class="keyword">return</span> _.isNumber(obj) &amp;&amp; obj !== +obj;
  };
</code></pre><p>NaN这个值有两个特点：1.它是一个数；2.不等于它自己。<br>‘+’放在变量前面一般作用是把后面的变量变成一个数，在这里已经判断为一个数仍加上’+’，是为了把<code>var num = new Number()</code>这种没有值的数字也归为NaN。</p>
<pre><code><span class="number">1244</span>   _.isBoolean = <span class="function"><span class="keyword">function</span><span class="params">(obj)</span> </span>{
<span class="keyword">return</span> obj === <span class="literal">true</span> || obj === <span class="literal">false</span> || toString.call(obj) === <span class="string">'[object Boolean]'</span>;
};
</code></pre><p>是不是以为如果是布尔值不是true就是false？还有第3中情况<code>var b = new Boolean()</code>。b也是布尔值。</p>
<pre><code><span class="number">1254</span>   _.isUndefined = <span class="function"><span class="keyword">function</span><span class="params">(obj)</span> </span>{
<span class="keyword">return</span> obj === <span class="keyword">void</span> <span class="number">0</span>;
};
</code></pre><p>用void 0来表示undefined，非常有意思的小技巧。不过常用方式还是if(xxx)来判断是不是undefined。</p>
<p><code>eq</code>是underscore的一个内置函数，代码太长，不粘贴了。isEmpty调用了这个函数。整个思路由易到难，先用===比较简单数据，然后用toString来判断是否相等，最后用递归处理复杂的Array、Function和Object对象。</p>
<pre><code><span class="number">1091</span> <span class="keyword">if</span> (a === b) <span class="keyword">return</span> a !== <span class="number">0</span> || <span class="number">1</span> / a === <span class="number">1</span> / b;
</code></pre><p>这里为了区分’+0’和’-0’,因为这两个数对计算结果是有影响的。</p>
<pre><code><span class="number">1098</span> var className = toString.<span class="keyword">call</span>(a);
<span class="keyword">if</span> (className !== toString.<span class="keyword">call</span>(b)) <span class="keyword">return</span> <span class="keyword">false</span>;
<span class="keyword">switch</span> (className) {
  <span class="comment">// Strings, numbers, regular expressions, dates, and booleans are compared by value.</span>
  <span class="keyword">case</span> <span class="string">'[object RegExp]'</span>:
  <span class="comment">// RegExps are coerced to strings for comparison (<span class="doctag">Note:</span> '' + /a/i === '/a/i')</span>
  <span class="keyword">case</span> <span class="string">'[object String]'</span>:
    <span class="comment">// Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is</span>
    <span class="comment">// equivalent to `new String("5")`.</span>
    <span class="keyword">return</span> <span class="string">''</span> + a === <span class="string">''</span> + b;
  <span class="keyword">case</span> <span class="string">'[object Number]'</span>:
    <span class="comment">// `NaN`s are equivalent, but non-reflexive.</span>
    <span class="comment">// Object(NaN) is equivalent to NaN</span>
    <span class="keyword">if</span> (+a !== +a) <span class="keyword">return</span> +b !== +b;
    <span class="comment">// An `egal` comparison is performed for other numeric values.</span>
    <span class="keyword">return</span> +a === <span class="number">0</span> ? <span class="number">1</span> <span class="regexp">/ +a === 1 /</span> b : +a === +b;
  <span class="keyword">case</span> <span class="string">'[object Date]'</span>:
  <span class="keyword">case</span> <span class="string">'[object Boolean]'</span>:
    <span class="comment">// Coerce dates and booleans to numeric primitive values. Dates are compared by their</span>
    <span class="comment">// millisecond representations. Note that invalid dates with millisecond representations</span>
    <span class="comment">// of `NaN` are not equivalent.</span>
    <span class="keyword">return</span> +a === +b;
}
</code></pre><p>这里是对简单对象进行判断，分为两类，一类是<code>String</code>和<code>RegExp</code>，这种数据直接<code>toString</code>然后判断。另一类是<code>Number</code>、<code>Date</code>和<code>Boolean</code>，通过转换成数字判断。</p>
<pre><code><span class="number">1150</span> aStack.<span class="keyword">push</span>(a);
bStack.<span class="keyword">push</span>(b);
<span class="keyword">if</span> (areArrays) {
  <span class="keyword">length</span> = a.<span class="keyword">length</span>;
  <span class="keyword">if</span> (<span class="keyword">length</span> !== b.<span class="keyword">length</span>) <span class="keyword">return</span> false;
  <span class="keyword">while</span> (<span class="keyword">length</span>--) {
    <span class="keyword">if</span> (!e<span class="string">q(a[length], b[length], aStack, bStack)</span>) <span class="keyword">return</span> false;
  }
} <span class="keyword">else</span> {
  var <span class="keyword">keys</span> = <span class="number">_</span>.<span class="keyword">keys</span>(a), key;
  <span class="keyword">length</span> = <span class="keyword">keys</span>.<span class="keyword">length</span>;
  <span class="keyword">if</span> (<span class="number">_</span>.<span class="keyword">keys</span>(b).<span class="keyword">length</span> !== <span class="keyword">length</span>) <span class="keyword">return</span> false;
  <span class="keyword">while</span> (<span class="keyword">length</span>--) {
    key = <span class="keyword">keys</span>[<span class="keyword">length</span>];
    <span class="keyword">if</span> (!(<span class="number">_</span>.has(b, key) &amp;&amp; e<span class="string">q(a[key], b[key], aStack, bStack)</span>)) <span class="keyword">return</span> false;
  }
}
aStack.<span class="keyword">pop</span>();
bStack.<span class="keyword">pop</span>();
</code></pre><p>对于数组和对象只能用递归了，同时用aStack和bStack来暂存递归中的子对象。这里一个小技巧的就是先判断数组/属性的长度，如果不相等可以有效地减少递归。</p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/09/22/underscore-source/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[算法、数据结构]]></title>
      <link>http://yalishizhude.github.io/2015/09/16/collection-js-algorithm/</link>
      <guid>http://yalishizhude.github.io/2015/09/16/collection-js-algorithm/</guid>
      <pubDate>Wed, 16 Sep 2015 15:04:58 GMT</pubDate>
      <description>
      <![CDATA[<a id="more"></a>
<h1 id="斐波那契数列">斐波那契数列</h1><h2 id="第n个数：">第n个数：</h2><pre><code><span class="function">function <span class="title">fabonac]]>
      </description>
      <content:encoded><![CDATA[<a id="more"></a>
<h1 id="斐波那契数列">斐波那契数列</h1><h2 id="第n个数：">第n个数：</h2><pre><code><span class="function">function <span class="title">fabonacci</span><span class="params">(n)</span></span>{
    <span class="keyword">return</span> n&gt;<span class="number">2</span>?fabonacci(n-<span class="number">1</span>)+fabonacci(n-<span class="number">2</span>):<span class="number">1</span>;
}
</code></pre>]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/09/16/collection-js-algorithm/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[html基础知识]]></title>
      <link>http://yalishizhude.github.io/2015/09/16/collection-html/</link>
      <guid>http://yalishizhude.github.io/2015/09/16/collection-html/</guid>
      <pubDate>Wed, 16 Sep 2015 15:04:58 GMT</pubDate>
      <description>
      <![CDATA[<a id="more"></a>
<h1 id="doctype类型">doctype类型</h1><h2 id="html5">html5</h2><p>&lt;!DOCTYPE html&gt;<br>不使用dtd</p>
<h2 id="HTML_4-01_Strict"]]>
      </description>
      <content:encoded><![CDATA[<a id="more"></a>
<h1 id="doctype类型">doctype类型</h1><h2 id="html5">html5</h2><p>&lt;!DOCTYPE html&gt;<br>不使用dtd</p>
<h2 id="HTML_4-01_Strict">HTML 4.01 Strict</h2><p>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN” “<a href="http://www.w3.org/TR/html4/strict.dtd&quot;&gt;" target="_blank" rel="external">http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</a><br>不包括展示性的和弃用的元素（比如 font）,不允许框架集（Framesets）。</p>
<h2 id="HTML_4-01_Transitional">HTML 4.01 Transitional</h2><p>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN”<br>“<a href="http://www.w3.org/TR/html4/loose.dtd&quot;&gt;" target="_blank" rel="external">http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</a><br>包括展示性的和弃用的元素（比如 font）,不允许框架集（Framesets）。</p>
<h2 id="HTML_4-01_Frameset">HTML 4.01 Frameset</h2><p>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Frameset//EN”<br>“<a href="http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;" target="_blank" rel="external">http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;</a><br>包括展示性的和弃用的元素（比如 font），允许框架集内容。</p>
<h2 id="XHTML_1-0_Strict">XHTML 1.0 Strict</h2><p>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Strict//EN”<br>“<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;" target="_blank" rel="external">http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</a><br>不包括展示性的和弃用的元素（比如font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。</p>
<h2 id="XHTML_1-0_Transitional">XHTML 1.0 Transitional</h2><p>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN” “<br><a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;" target="_blank" rel="external">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</a><br>包括展示性的和弃用的元素（比如font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。</p>
<h2 id="XHTML_1-0_Frameset">XHTML 1.0 Frameset</h2><p>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Frameset//EN”<br>“<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;" target="_blank" rel="external">http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;</a><br>包括展示性的和弃用的元素（比如font），但允许框架集内容。必须以格式正确的 XML 来编写标记。</p>
<h2 id="XHTML_1-1">XHTML 1.1</h2><p>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.1//EN” “<a href="http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;" target="_blank" rel="external">http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;</a><br>不包括展示性的和弃用的元素（比如font）,不允许框架集（Framesets）,但允许添加模型（例如提供对东亚语系的 ruby 支持）。</p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/09/16/collection-html/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[js基础知识]]></title>
      <link>http://yalishizhude.github.io/2015/09/16/collection-js/</link>
      <guid>http://yalishizhude.github.io/2015/09/16/collection-js/</guid>
      <pubDate>Wed, 16 Sep 2015 15:04:58 GMT</pubDate>
      <description>
      <![CDATA[<a id="more"></a>
<h1 id="什么是原型和原型链">什么是原型和原型链</h1><p>Javascript中，所有数据类型都有一个默认属性：<code>__proto__</code>，这个叫做原型。而该隐藏属性中又包含其它数据对象的<code>__prot]]>
      </description>
      <content:encoded><![CDATA[<a id="more"></a>
<h1 id="什么是原型和原型链">什么是原型和原型链</h1><p>Javascript中，所有数据类型都有一个默认属性：<code>__proto__</code>，这个叫做原型。而该隐藏属性中又包含其它数据对象的<code>__proto__</code>，这种原型的嵌套包含就叫原型链。</p>
<h1 id="prototype属性有什么作用">prototype属性有什么作用</h1><p>本质上，js中的基本数据类型Functoin/Object/Number/Array/boolean都是函数。（用typeof 可以查看）而prototype是函数的专有属性，当该函数被实例化时，prototype属性可以被实例所继承，即</p>
<pre><code><span class="variable"><span class="keyword">var</span> fun</span> = function(){};
<span class="variable"><span class="keyword">var</span> a</span> = new <span class="function"><span class="title">fun</span><span class="params">()</span>;</span>
a.__proto__ === <span class="function"><span class="keyword">fun</span>.prototype; <span class="comment">//true</span></span>
</code></pre><h1 id="改变作用域的方法">改变作用域的方法</h1><ul>
<li>apply 通过传入对象参数改变原函数作用域为参数作用域。 <code>fun.apply(obj, [a,b,c]);</code> 调用fun函数，作用域为obj，参数为a/b/c。</li>
<li>call 同上，不过为不定参数。</li>
<li>new 通过实例化，将构造函数this指针指向实例函数。</li>
<li>bind 传入参数可以改变做用域甚至绑定参数</li>
</ul>
<h1 id="判断数据类型的方法">判断数据类型的方法</h1><ul>
<li>toString.call 准确判断数据类型：Array、String、Object、RegExp、Number、Undefined、Null、Date、Boolean、Function</li>
<li>typeof 粗略判断数据类型：undefined、number、string、boolean、object、function</li>
<li>instanceOf 判断一个函数是否为另一个函数的实例。</li>
<li>Array.isArray ECMAScript 5 新增方法，用来判断参数是否为数组。</li>
<li>isFinite 判断是否为Infinity和null</li>
</ul>
<h1 id="arguments是什么数据类型">arguments是什么数据类型</h1><p>函数内部自动创建的一个类似数组的获取函数实参的隐藏对象。</p>
<h1 id="caller和callee有什么区别">caller和callee有什么区别</h1><p><code>caller</code><br>函数原型函数，返回该函数的调用函数。当该函数为顶层调用时，返回null<br><code>callee</code><br>arguments的默认属性，<code>arguments.callee</code>用来指向函数本身，常用在匿名函数和递归函数中。<code>arguments.callee.length</code>可以用获取函数形参长度。</p>
<h1 id="==_和_===_有什么区别">== 和 === 有什么区别</h1><ul>
<li>‘1’ == 1 –&gt; true</li>
<li>‘1’ === 1 –&gt; false</li>
<li>null == undefined –&gt; true</li>
<li>null === undefined –&gt; false</li>
<li>NaN == NaN –&gt; false</li>
<li>NaN === NaN –&gt; false</li>
<li>var a = b = {}; a === b –&gt;true</li>
<li>var a = {}; var b = {}; a === b –&gt; false<br><code>==</code> 先将两边值转换为同一类型的对象再进行 <code>===</code>比较<br><code>===</code> 只用于浅拷贝的对象进行比较，不进行对象内容进行比较。只要引用地址不一致，即使内容一致也比较不出来。可以用来比较函数、数组等复杂对象，只是实用性不大。</li>
</ul>
<h1 id="什么是变量提升">什么是变量提升</h1><p>变量在一个范围内声明的时候，javascript引擎会将这个声明移到范围顶部。</p>
<pre><code><span class="keyword">var</span> v=<span class="string">'Hello World'</span>;
(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="built_in">console</span>.log(v);
    <span class="keyword">var</span> v=<span class="string">'I love you'</span>;
})();<span class="comment">//undefined</span>
</code></pre><p>这段代码等价于</p>
<pre><code><span class="keyword">var</span> v=<span class="string">'Hello World'</span>;
(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="keyword">var</span> v;
    <span class="built_in">console</span>.log(v);
    v=<span class="string">'I love you'</span>;
})();
</code></pre><p>同样，匿名函数也受命名提升的影响</p>
<pre><code><span class="list">(<span class="keyword">function</span><span class="list">()</span><span class="collection">{
    foo<span class="list">()</span><span class="comment">;</span>
    function foo<span class="list">()</span><span class="collection">{
        console.log<span class="list">(<span class="string">"我来自 foo"</span>)</span><span class="comment">;</span>
    }</span>
}</span>)</span><span class="list">()</span><span class="comment">; //我来自 foo</span>

<span class="list">(<span class="keyword">function</span><span class="list">()</span><span class="collection">{
    foo<span class="list">()</span><span class="comment">;</span>
    var foo = function<span class="list">()</span><span class="collection">{
        console.log<span class="list">(<span class="string">"我来自 foo"</span>)</span><span class="comment">;</span>
    }</span>
}</span>)</span><span class="list">()</span><span class="comment">;//TypeError: foo is not a function</span>
</code></pre><p>js中有函数作用域但是没有块级作用域。</p>
<pre><code>var x = <span class="number">1</span>;
console.<span class="built_in">log</span><span class="params">(x)</span>; <span class="comment">// 1</span>
<span class="keyword">if</span> <span class="params">(<span class="literal">true</span>)</span> {
    var x = <span class="number">2</span>;
    console.<span class="built_in">log</span><span class="params">(x)</span>; <span class="comment">//2</span>
}
console.<span class="built_in">log</span><span class="params">(x)</span>;<span class="comment">// 2</span>
</code></pre><p><a href="http://www.jb51.net/article/30719.htm" target="_blank" rel="external">详细介绍</a></p>
<h1 id="获取所有dom的方法">获取所有dom的方法</h1><pre><code>document.<span class="function"><span class="title">getElementsByTagName</span><span class="params">( <span class="string">'*'</span> )</span></span>
</code></pre>]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/09/16/collection-js/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[WEB基础知识整理]]></title>
      <link>http://yalishizhude.github.io/2015/09/16/collection/</link>
      <guid>http://yalishizhude.github.io/2015/09/16/collection/</guid>
      <pubDate>Wed, 16 Sep 2015 15:04:58 GMT</pubDate>
      <description>
      <![CDATA[<a id="more"></a>
<ul>
<li><p><a href="/2015/09/16/collection-html">html基础知识</a></p>
</li>
<li><p><a href="/2015/09/16/collection-css">css基础]]>
      </description>
      <content:encoded><![CDATA[<a id="more"></a>
<ul>
<li><p><a href="/2015/09/16/collection-html">html基础知识</a></p>
</li>
<li><p><a href="/2015/09/16/collection-css">css基础知识</a></p>
</li>
<li><p><a href="/2015/09/16/collection-js">js基础知识</a></p>
</li>
<li><p><a href="/2015/09/16/collection-js-algorithm">算法/数据结构</a></p>
</li>
<li><p><a href="/2015/09/16/collection-tool">常用工具技巧</a></p>
</li>
</ul>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/09/16/collection/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[css基础知识]]></title>
      <link>http://yalishizhude.github.io/2015/09/16/collection-css/</link>
      <guid>http://yalishizhude.github.io/2015/09/16/collection-css/</guid>
      <pubDate>Wed, 16 Sep 2015 15:04:58 GMT</pubDate>
      <description>
      <![CDATA[<a id="more"></a>
<h1 id="浏览器兼容性问题解决方法">浏览器兼容性问题解决方法</h1><p>css hack<br>样式文件</p>
<blockquote>
<p>通用 height: 100px;<br>IE6 ： _height: 100px;<]]>
      </description>
      <content:encoded><![CDATA[<a id="more"></a>
<h1 id="浏览器兼容性问题解决方法">浏览器兼容性问题解决方法</h1><p>css hack<br>样式文件</p>
<blockquote>
<p>通用 height: 100px;<br>IE6 ： _height: 100px;<br>IE7 ： <em>+height: 100px;<br>IE6、IE7 ： </em>height: 100px;<br>IE7、FF ： height: 100px !important;</p>
</blockquote>
<p>引用注释</p>
<blockquote>
<!--[if !IE]><!--> 除IE外都可识别 <!--<![endif]-->
<!--[if IE]> 所有的IE可识别 <![endif]-->
<!--[if IE 5]> 仅IE5.0与IE5.5可以识别 <![endif]-->
<!--[if gt IE 5.0]> IE5.0以及IE5.0以上版本都可以识别 <![endif]-->
<!--[if gte IE 6]> IE6以及IE6以上版本可识别 <![endif]-->
<!--[if lt IE 7]> IE7以及IE7以下版本可识别 <![endif]-->
</blockquote>
<h1 id="css3常用属性">css3常用属性</h1><h2 id="border-radius">border-radius</h2><p>圆角属性</p>
<h2 id="box-shadow">box-shadow</h2><p>用来制作阴影、模糊效果、以及内边框</p>
<h2 id="background-size">background-size</h2><p>设置背景图片大小</p>
<h2 id="transition">transition</h2><p>制作简单动画，通过改变特定属性</p>
<h2 id="transform">transform</h2><p>样式变换，缩放、旋转、平移</p>
<h1 id="清除浮动的方法">清除浮动的方法</h1><h2 id="clear:both">clear:both</h2><p>浮动元素后建立空元素来清除浮动。非IE浏览器常用before和after伪类来实现。</p>
<h2 id="overflow:auto">overflow:auto</h2><p>空标签元素清除浮动而不得不增加无意代码的弊端,,使用zoom:1用于兼容IE</p>
<h1 id="隐藏标签的方法">隐藏标签的方法</h1><ul>
<li>display:none 完全隐藏</li>
<li>visibility:hidden 隐藏但保留占位空间</li>
</ul>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/09/16/collection-css/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[工具技巧]]></title>
      <link>http://yalishizhude.github.io/2015/09/16/collection-tool/</link>
      <guid>http://yalishizhude.github.io/2015/09/16/collection-tool/</guid>
      <pubDate>Wed, 16 Sep 2015 15:04:58 GMT</pubDate>
      <description>
      <![CDATA[<a id="more"></a>
<h1 id="chrome调试工具">chrome调试工具</h1><h2 id="ctrl+shift+f">ctrl+shift+f</h2><p>搜索所有文件内容，速度很慢，不建议使用</p>
<h2 id="ctrl+p_或_ctrl]]>
      </description>
      <content:encoded><![CDATA[<a id="more"></a>
<h1 id="chrome调试工具">chrome调试工具</h1><h2 id="ctrl+shift+f">ctrl+shift+f</h2><p>搜索所有文件内容，速度很慢，不建议使用</p>
<h2 id="ctrl+p_或_ctrl+o">ctrl+p 或 ctrl+o</h2><p>按文件名全量搜索文件</p>
<h2 id="ctrl+shift+p_或_ctrl+shift+o">ctrl+shift+p 或 ctrl+shift+o</h2><p>在当前打开的js文件中搜索函数名称</p>
<h2 id="ctrl+shift+o_或_ctrl+shift+o">ctrl+shift+o 或 ctrl+shift+o</h2><p>在当前打开的css文件中按选择器搜索定义的样式</p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/09/16/collection-tool/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[git学习总结]]></title>
      <link>http://yalishizhude.github.io/2015/09/16/git/</link>
      <guid>http://yalishizhude.github.io/2015/09/16/git/</guid>
      <pubDate>Wed, 16 Sep 2015 12:38:47 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="从svn到git">从svn到git</h2><p>两者都是优秀的版本管理工具（giter请不要鄙视svner）</p>
<ul>
<li>svn上手非常容易，操作简单</li>
<li>git功能强大，但是要熟练使用分支不算容易</li>
</ul>
<p>git因为是分布式的，所以其核心就是分支（只有master分支情况下和svn差不多？），分支的意义在于，可以将项目代码按照功能、模块拆分成不同的分支。比如这个产品要加一个支付功能和一个登陆功能，可以创建两个分支，交给不同的开发人员并行开发。登陆功能先开发完，测试无误后合并改分支到master分支，master分支部署上线。支付功能虽然没有开发完成，但是在另一条分支上，所以产品上线和功能开发完全不受影响。这才是分布式开发的高效模式。</p>
<p>被git坑了一个星期之后决心把官方文档看一下，结合实践经验进行了整理。</p>
<hr>]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="从svn到git">从svn到git</h2><p>两者都是优秀的版本管理工具（giter请不要鄙视svner）</p>
<ul>
<li>svn上手非常容易，操作简单</li>
<li>git功能强大，但是要熟练使用分支不算容易</li>
</ul>
<p>git因为是分布式的，所以其核心就是分支（只有master分支情况下和svn差不多？），分支的意义在于，可以将项目代码按照功能、模块拆分成不同的分支。比如这个产品要加一个支付功能和一个登陆功能，可以创建两个分支，交给不同的开发人员并行开发。登陆功能先开发完，测试无误后合并改分支到master分支，master分支部署上线。支付功能虽然没有开发完成，但是在另一条分支上，所以产品上线和功能开发完全不受影响。这才是分布式开发的高效模式。</p>
<p>被git坑了一个星期之后决心把官方文档看一下，结合实践经验进行了整理。</p>
<hr>
<a id="more"></a>
<h2 id="新手常见问题">新手常见问题</h2><ol>
<li><p>如何查看有哪些分支？<br><code>git branch -a</code></p>
</li>
<li><p>如何强制检出/切换分支或分支指定文件<br><code>git checkout &lt;branch&gt; [file] [-f]</code><br>强制更新，以branch版本的代码为主</p>
</li>
<li><p>提交代码出现冲突冲突怎么办？<br><code>hint: Updates were rejected because the tip of your current branch is behind</code><br><code>hint: its remote counterpart. Integrate the remote changes (e.g.</code><br><code>hint: &#39;git pull ...&#39;) before pushing again.</code><br><code>hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.</code><br>先切换分支，然后拉取分支上最新的代码覆盖到本地<br><code>git pull</code><br>添加或者提交代码，解决冲突之后<br><code>git push</code></p>
</li>
<li><p>如何新建分支<br><code>git checkout -b &lt;branch_name&gt;</code><br>本地建立 branch 並立即切換到新分支<br><code>git branch -m &lt;new_name&gt;</code><br>修改分支名称  </p>
</li>
<li><p>从远程仓库拉取代码到本地仓库，并建立跟踪关系<br><code>git clone http://xxx.git</code><br>或者<br><code>get clone git@xxx.git</code><br>然后<br><code>git checkout -b &lt;本地新分支名&gt; &lt;对应的远程分支名&gt;</code></p>
</li>
<li><p>远程仓库新建了一个分支，如何更新远程分支信息<br><code>git fetch &lt;remote base&gt;</code></p>
</li>
<li><p>如何在远程仓库新建一个分支<br><code>git branch &lt;branch name&gt;</code><br>新建一个本地分支，按照正常流程提交完代码后，推送到远程<br><code>git push &lt;remote base&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code></p>
</li>
</ol>
<h2 id="实用指令">实用指令</h2><h3 id="reset">reset</h3><p><code>git reset [file]</code><br>取消暂存</p>
<h3 id="remote">remote</h3><p>查看远程仓库名</p>
<p><code>git remote -v</code><br>查看远程仓库url</p>
<p><code>git remote add &lt;basename&gt; &lt;url&gt;</code><br>新增远程仓库</p>
<p><code>git remote show &lt;basename&gt;</code><br>查看远程仓库详细信息</p>
<p><code>git remote rename &lt;old basename&gt; &lt;new basename&gt;</code><br>重命名远程仓库</p>
<h3 id="pull">pull</h3><p>相当于fetch和merge</p>
<h3 id="push">push</h3><p><code>git push [remote_branch] [local_branch]</code><br>推送本地仓库代码到远程仓库，相当于svn的commit</p>
<p><code>git push &lt;remote base&gt; [tag name]</code><br>推送本地标签到远程仓库</p>
<p><code>git push &lt;remote base&gt; &lt;remote branch&gt;:&lt;local branch&gt;</code><br>将本地分支推送到指定的远程分支</p>
<p><code>git push &lt;remote base&gt; --delete &lt;remote branch&gt;</code><br>删除远程分支</p>
<h3 id="tag">tag</h3><p>查看标签（用来标记标志性的稳定版本信息）</p>
<p><code>git tag -l &#39;[expression]&#39;</code><br>查看那符合正则表达式的</p>
<p><code>git tag -a &lt;tag name&gt; -m &lt;comment&gt;</code><br>添加带注释的标签</p>
<p><code>git tag -a &lt;tag name&gt; &lt;md5&gt;</code><br>对某个版本打标签</p>
<p><code>git tag [tag name]</code><br>如果没有标签名，则为查看所有标签。带标签名则为新建标签</p>
<h3 id="merge">merge</h3><p><code>git merge &lt;branch name&gt;</code><br>将其他分支合并到本分支</p>
<h3 id="commit">commit</h3><p><code>git commit -a -m &#39;xx&#39;</code><br>暂存并提交</p>
<h3 id="branch">branch</h3><p><code>git branch</code><br>查看本地仓库分支</p>
<p><code>git branch -v</code><br>查看本地仓库分支最后一次提交情况</p>
<p><code>git branch -vv</code><br>查看分支跟踪情况</p>
<p><code>git branch &lt;branch name&gt;</code><br>新建分支</p>
<p><code>git branch -d &lt;branch name&gt;</code><br>删除分支</p>
<p><code>git branch [--merged | --no-merged]</code><br>查看已合并|未合并的本地仓库分支</p>
<p><code>git branch -u &lt;remote base&gt;/&lt;remote branch&gt;</code><br>修改当前跟踪分支</p>
<h3 id="commit-1">commit</h3><p><code>git commit -a -m &#39;xx&#39;</code><br>提交并且暂存暂存的方法</p>
<h3 id="checkout">checkout</h3><p><code>git checkout -- [file]</code><br>恢复文件</p>
<p><code>git checkout -b [branchname] [tagname]</code><br>在特定的版本上创建一个新的分支并切换到此分支</p>
<p><code>git checkout -b [local branch] [remote base]/[remote branch]</code><br>将远程分支检出到本地分支</p>
<p><code>git checkout --track &lt;remote base&gt;/&lt;remote branch&gt;</code><br>让当前分支跟踪远程分支</p>
<p><code>git checkout --track &lt;remote base&gt;/&lt;remote branch&gt;</code><br><code>git checkout -b &lt;local branch&gt; &lt;remote base&gt;/&lt;remote branch&gt;</code><br>让当前分支跟踪到远程分支。两条命令作用基本一致，不同的是第二条命令可以重命名检出的分支。</p>
<h3 id="rebase">rebase</h3><p><code>git rebase [basebranch]</code><br>变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p>
<h2 id="小技巧">小技巧</h2><h3 id="查看配置">查看配置</h3><p><code>git config -1</code></p>
<h3 id="设置git_push_默认">设置git push 默认</h3><p><code>git config --global push.default current</code></p>
<h3 id="设置别名">设置别名</h3><p><code>git config --global alias.&lt;name&gt; &lt;commend&gt;</code><br>我的设置：<br><code>git config --global alias.st status</code><br><code>git config --global alias.cm &quot;commit -m&quot;</code><br><code>git config --global alias.ph &quot;push origin &lt;local_repository&gt;:&lt;remote_repository&gt;&quot;</code></p>
<h3 id="保存用户名和密码">保存用户名和密码</h3><h4 id="对于http(s)协议，可以用下面命令临时缓存">对于http(s)协议，可以用下面命令临时缓存</h4><p><code>git config --global credential.helper cache</code><br>开启linux缓存<br><code>git config --global credential.helper wincred</code><br>开启windows缓存</p>
<h4 id="对于ssh协议，可以用ssh_key，具体教程网上很多">对于ssh协议，可以用ssh  key，具体教程网上很多</h4><h3 id="忽略文件">忽略文件</h3><p>默认方法是在当前项目目录下创建一个.gitignore文件，如果需要忽略的文件已经添加到版本库中，请先移除<br><code>git rm --cached [file]</code><br>不删除文件，只移除追踪。</p>
<p><a href="http://git-scm.com/book/zh/v2" target="_blank" rel="external">权威教程</a></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/09/16/git/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Angular开发者指南(1) -- Angular介绍]]></title>
      <link>http://yalishizhude.github.io/2015/09/10/angular-introduction/</link>
      <guid>http://yalishizhude.github.io/2015/09/10/angular-introduction/</guid>
      <pubDate>Wed, 09 Sep 2015 17:40:38 GMT</pubDate>
      <description>
      <![CDATA[<h1 id="Angular是什么?">Angular是什么?</h1><p>AngularJS是一种为动态web应用设计的框架。它使用HTML作为模板语言，并且扩展了HTML的语法，让开发者能够更清晰、更简洁地开发应用组件。Angular的动态绑定和依赖注入将为开发者节省大量代码。所有这些在浏览器端的特性，也使得它可以与任何服务端技术完美搭配使用。<br>]]>
      
      </description>
      <content:encoded><![CDATA[<h1 id="Angular是什么?">Angular是什么?</h1><p>AngularJS是一种为动态web应用设计的框架。它使用HTML作为模板语言，并且扩展了HTML的语法，让开发者能够更清晰、更简洁地开发应用组件。Angular的动态绑定和依赖注入将为开发者节省大量代码。所有这些在浏览器端的特性，也使得它可以与任何服务端技术完美搭配使用。<br><a id="more"></a><br>Angular将使HTML成为设计应用程序的语言。对于静态文档来说，HTML是一种伟大的声明式语言。但是却并不适合于创建应用程序。所以当我们想用它来创建web应用的时候，就像是在欺骗浏览器，把它变成我们想要的应用程序。</p>
<p>这种动态应用程序和静态文档之间的矛盾通常用一下方法解决：</p>
<p>库 - 用于开发web应用的有效的函数集合。主要由你编写的代码来进行合适的调用，例如：JQuery。</p>
<p>框架 - 作为web应用的特别补充，使得你的代码只需要编写细节部分的代码。当应用需要使用某些功能时，框架负责调用你的代码。例如：durandal，ember等。<br>Angular采取了另一个方法。它试图通过创建新的HTML结构来最小化以文档为中心的HTML和一个应用程序所需功能之间的矛盾。Angular通过一种我们称之为指令的结构，让浏览器学习了新的语法。如下例所示：</p>
<ul>
<li>数据绑定，例如{ {} }。</li>
<li>用repeating/hiding DOM碎片页来对DOM结构进行控制。</li>
<li>支持表单和表单校验。</li>
<li>为DOM元素附加新的行为，例如DOM事件处理。</li>
<li>将HTML拆分成可复用的组件。</li>
</ul>
<h2 id="一个完整的客户端解决方案">一个完整的客户端解决方案</h2><p>在创建web应用客户端这个难题中，Angular并不只是一个局部的解决方法。它包括了所有的那些你曾经写过的、并且在其他定义明确的结构中使用过的DOM和AJAX之间交互的代码。这使得Angular成为了一个以怎样创建一个CRUD(create read update delete)应用程序为依据的框架。虽然它以此为据，但是仍然试图保证这只是一个起点。你仍然可以轻松地改变它。Angular提供了以下内容：</p>
<ul>
<li>创建一个CRUD应用所需要的一切东西：数据绑定，基本模板指令，表单校验，路由，深层连接，可复用组件，依赖注入。</li>
<li>可测试能力：单元测试，端对端测试，假数据，测试脚手架</li>
<li>带有目录结构和测试脚本的seed应用作为项目起点</li>
</ul>
<h2 id="Angular的长处">Angular的长处</h2><p>Angular通过为开发者提供了一个更高级别的抽象，简化了应用程序开发。像任何抽象一样，它是以牺牲灵活性为代价的。换句话说，不是每个应用程序都适合使用Angular。Angular是为CRUD应用程序的而创建的。幸运的是，CRUD应用代表多数Web应用程序。要了解Angular擅长什么，所以首先要了解哪些应用是不适合Angular。</p>
<p>游戏和图形编辑器都是密集和复杂的DOM操作的应用实例。这些类型的应用程序都不同于CRUD类型的应用程序，因此可能不太适合使用Angular。在这些情况下，它可能更适合使用抽象级别较低的库，如jQuery。</p>
<h1 id="Angular的禅道">Angular的禅道</h1><p>Angular的信念是，在编写UI和软件组件时，声明式代码更优于命令式代码，然而在编写业务逻辑时命令式代码更有优势。</p>
<ul>
<li><p>从应用逻辑中将DOM操作解耦是一种非常好的处理方式。这极大的提升了代码的可测试性。</p>
</li>
<li><p>认为测试代码和编写代码同等重要是一种非常好的观念。代码的结构极大地影响了测试难度。</p>
</li>
<li><p>把客户端从服务端进行解耦也是一种相当好的方式。使得双方的开发者能够并行开发，并且代码能够重用</p>
</li>
<li><p>框架通过创建一个应用程序的整个流程，包括设计UI，编写业务逻辑，进行测试，来有效地引导开发者。</p>
</li>
<li><p>它有利于拆分、简化任务。</p>
</li>
</ul>
<p>Angular可以将你从以下痛苦中解脱：</p>
<ul>
<li><p>注册回调函数：注册大量的回调函数使得你的代码变得结构混乱。移除常见的模板代码例如回调函数是一件有益的事。这将极大地减少你的javascript代码，并且使你的应用程序变得清晰明了。</p>
</li>
<li><p>以编程的方式操作HTML DOM：虽然操作HTML DOM是AJAX应用的基础，但它也是笨拙的、易错的。通过声明当应用程序状态变化时UI的变化方式，你将从低级的DOM操作中解放出来大多数Angular编写的应用程序从来不用编程的方式操作DOM，尽管如果你想要的话也是可以的。</p>
</li>
<li><p>与UI交互数据：CRUD操作构成了AJAX应用程序的大部分任务。操作数据从服务器到一个内部对象，再到一个允许用户修改，需要校验，和显示验证错误的HTML表单，再返回到一个内部模型，然后返回给服务器，造成大量的样板代码。Angular消除了几乎所有的样板代码，让代码描述整个流程而不是实现所有细节。</p>
</li>
<li><p>编写大量的项目初始化代码：通常你需要编写大量的代码来让你一个“Hello World”的AJAX程序工作。通过Angula的那些标签式的依赖注入风格被自动注入到应用程序的服务，你可以很容易地启动你的程序，从而让你更快地开始开发程序功能。还有一个额外的好处，在自动测试中你可以完全控制这个初始化过程。</p>
</li>
</ul>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/09/10/angular-introduction/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[接口调试（中）—— 解决方案构想]]></title>
      <link>http://yalishizhude.github.io/2015/09/08/api-test-2/</link>
      <guid>http://yalishizhude.github.io/2015/09/08/api-test-2/</guid>
      <pubDate>Mon, 07 Sep 2015 16:29:58 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="设想方案：">设想方案：</h2><blockquote>
<p>缩写：<br>前端 - FE（front end）<br>本地 - L（local）<br>测试 - T（test）<br>服务器 - S（server）<br>后端 - BE（back end）<br>接口 - API（application programming interface）<br>开发 - D（development）</p>
</blockquote>]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="设想方案：">设想方案：</h2><blockquote>
<p>缩写：<br>前端 - FE（front end）<br>本地 - L（local）<br>测试 - T（test）<br>服务器 - S（server）<br>后端 - BE（back end）<br>接口 - API（application programming interface）<br>开发 - D（development）</p>
</blockquote>
<a id="more"></a>
<pre><code>FE L S <span class="variable">&lt;——&gt;</span> FE T S <span class="variable">&lt;——&gt;</span> API S <span class="variable">&lt;——&gt;</span> BE T S <span class="variable">&lt;——&gt;</span> BE L S
                                    ^
                                    |<span class="string">
                                     ——&gt; BE D S</span>
</code></pre><h3 id="（API_S）接口服务器说明：">（API S）接口服务器说明：</h3><ul>
<li>由前端主导，前后端在测试服务器上共同编写接口，主要提供接口数据的json定义和文字说明。</li>
<li>根据接口文档生成前端调试代码、数据和后端调试代码，分别部署于前端测试服务器和后端测试服务器。</li>
<li>如果出现接口修改等情况，重新生成接口文档和调试代码，并部署重启测试服务器</li>
</ul>
<h3 id="（FE_T_S）前端测试服务器说明：">（FE T S）前端测试服务器说明：</h3><ul>
<li>为前端提供假数据。</li>
<li>它不查询数据库，也不处理复杂的业务逻辑。</li>
<li>只根据根定义的接口校验请求路径和参数，同时来返回假数据。当前端参数不符合接口定义时，抛出异常。</li>
</ul>
<h3 id="（BE_T_S）后端测试服务器说明：">（BE T S）后端测试服务器说明：</h3><ul>
<li>发送请求给后端本地服务器。后端人员开发完成接口后，通过后端测试服务器操作，手动发送请求进行联调。</li>
<li>校验请求返回结果。当返回结果与接口定义不一致时抛出异常。<br>定时任务测试开发环境接口。确保开发环境的接口跟本地调试接口一致。</li>
</ul>
<h3 id="意义：">意义：</h3><ul>
<li>避免了前后端接口调试的痛苦过程，开发人员只需和自己的测试服务器进行联调即可。在接口配置不变的情况下，与测试服务器的调试成功后，前后端部署代码即可保证与调试结果一致。</li>
<li>接口服务器是关键，生成的代码必须保证前后端测试结果一致性，这里考虑用swagger。</li>
<li>测试服务器根据技术架构来决定，如jsp的话，前端测试服务器考虑用tomcat服务器，只含接口无业务逻辑。跨域问题用代理服务器解决。后端测试服务器甚至可以省略，只需要java的测试代码就行。</li>
</ul>
<p><em>阅读连接</em><br><a href="http://yalishizhude.github.io/2015/09/01/api-test-1/">接口调试（上）—— 前后端分离之痛</a></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/09/08/api-test-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[接口调试（上）—— 前后端分离之痛]]></title>
      <link>http://yalishizhude.github.io/2015/09/01/api-test-1/</link>
      <guid>http://yalishizhude.github.io/2015/09/01/api-test-1/</guid>
      <pubDate>Tue, 01 Sep 2015 15:22:34 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="楔子">楔子</h2><p>“你把代码提交一下，我更新一下试试”<br>。。。<br>“你再更新一下，看看可以了不？什么，结果没出来？连我这边试一下”<br>。。。<br>“擦，你这个参数值大小写错了”<br>前后端联调中经常发生类似的对话。<br>]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="楔子">楔子</h2><p>“你把代码提交一下，我更新一下试试”<br>。。。<br>“你再更新一下，看看可以了不？什么，结果没出来？连我这边试一下”<br>。。。<br>“擦，你这个参数值大小写错了”<br>前后端联调中经常发生类似的对话。<br><a id="more"></a></p>
<h2 id="趋势">趋势</h2><p>web技术发展到了今天，全栈开发的模式逐渐被前后端分离的开发模式所取代。<br>从市场角度来说前端知识的快速增长，使得全栈开发人员需要掌握更多的技能和知识，也需要投入更多的精力。从而优秀的全栈变得更少，更难满足市场的需求。前后端分离让前端技术变得更专业化，也减轻后端开发压力。<br>从技术上来说，低耦合，模块化是代码开发的理想状态，前后端分离更有利于这一目标的实现，为以后的维护降低了成本。<br>从行业上来说，一般一个行业，发展越成熟，分工就越精细。<br>js全栈也是我所看好的，用一种语言解决前后端开发，降低了开发人员门槛。有兴趣可以看一下这些优秀的项目</p>
<ul>
<li><a href="https://github.com/meteor/meteor" target="_blank" rel="external">meteor</a></li>
<li><a href="https://github.com/meanjs/mean" target="_blank" rel="external">meanjs</a></li>
</ul>
<h2 id="问题">问题</h2><p>前后端分离似乎很美好，让前后端开发人员专注自己的技术和业务知识，但产品最终要上线，最终是要合在一起的，要保证前后端开发的代码能完美的契合，只能进行接口调试了。<br>怎么能保证两边开发的东西能接合在一起呢？嗯，是有接口文档这么个东西。之所以说“有这么个东西”，是因为它仅仅是一个文档，常常出现更新不及时、双方都与文档出现偏差的现象。<br>有没有办法解决接口的问题？看完了破狼<a href="http://www.cnblogs.com/whitewolf/p/4686154.html" target="_blank" rel="external">关于swagger的介绍</a>，以及<a href="http://baike.baidu.com/link?url=4mWjIAhtru1TH5QHkXpBzB3vRWPb7uJFTDwavQdaZxGqoUXQ0-yy6I95Z3hZ0XRyUbyV3VhG1_LPZN5i8L8hg_" target="_blank" rel="external">martin fowler</a>关于契约测试的介绍，解决方法和工具都已具备，所以解决方案应该还是存在的。</p>
<p><em>阅读链接</em></p>
<p><a href="http://yalishizhude.github.io/2015/09/01/api-test-2/">接口调试（中）—— 解决方案构想</a></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/09/01/api-test-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[前端开发人员为什么应该拿高薪]]></title>
      <link>http://yalishizhude.github.io/2015/08/27/salary/</link>
      <guid>http://yalishizhude.github.io/2015/08/27/salary/</guid>
      <pubDate>Thu, 27 Aug 2015 14:24:31 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="市场需求">市场需求</h2><p>决定产品价格最重要的是供求关系。技术水平重要，但绝没有市场供给关系重要。不能理解的话举个简单例子，空气重要么？重要，人没了空气活不了，但是为什么不值钱？就是因为在市场关系中是供远远大于求的。<br>现在是互联网公司的春天，很多公司如雨后春笋般发展，所以对前端开发的需求很旺盛，都是处在供小于求的情况。随便上招聘网一搜，北上广深这些一线城市不说，二线城市一个月的招聘消息都不少。更别说现在像竞鹿网这种新型招聘网站的出现，更是有利于求职者的。<br>]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="市场需求">市场需求</h2><p>决定产品价格最重要的是供求关系。技术水平重要，但绝没有市场供给关系重要。不能理解的话举个简单例子，空气重要么？重要，人没了空气活不了，但是为什么不值钱？就是因为在市场关系中是供远远大于求的。<br>现在是互联网公司的春天，很多公司如雨后春笋般发展，所以对前端开发的需求很旺盛，都是处在供小于求的情况。随便上招聘网一搜，北上广深这些一线城市不说，二线城市一个月的招聘消息都不少。更别说现在像竞鹿网这种新型招聘网站的出现，更是有利于求职者的。<br><a id="more"></a></p>
<h2 id="工作强度">工作强度</h2><blockquote>
<p>这个字体是不是大一点清楚些？<br>这个颜色不好看，改成红色？<br>这里加个特效…<br>最近流行扁平化设计，网站需要改版…</p>
</blockquote>
<p>这种需求已经碰到太多次了，一个词来形容就就是：频繁。<br>再加上现在混合app的流行，网站页面更新速度快，也为前端代码频繁更新提供了“客观条件”。<br>人的天性更加于纠结那些眼下看得见的东西，所以前端开发者承担了外自客户，内自产品经理、设计师施加的压力。而这种压力传递到服务端很可能就是一条sql语句，一张表的事情。如果能力较强的前端工程师可能还承担了代码压缩管理等其它附加任务。</p>
<h2 id="重要性">重要性</h2><p>前端的代码都是直面客户的，客户即是公司的上帝，重要程度不言自明。</p>
<h2 id="复杂性">复杂性</h2><ul>
<li><p>知识点多<br>越学习越发现，要做的一个优秀的前端开发人员确实比较难。<br>首先要掌握的技能知识很多很零散。不信可以看看技能树。前端又可以分为PC端、移动端、混合应用、js后端，然后有丰富的框架等着你选择，碰到的坑又各不一样，比如pc端要考虑浏览器的兼容性问题，移动端要考虑屏幕适配等。<br>光有理论知识还不行，还要实践动手能力，学会使用工具,首先是IDE或者编辑器,然后是各种浏览器或者移动设备，最后还有版本管理、代码压缩等自动化工具。<br>开发出一个网站往往像用几十道工序制作一件手工品，不一样的是，别的手工匠人可以用几年的时间打磨制作，前端开发流程是越快越好。</p>
</li>
<li><p>技术更新快<br>比如Angular和Angular2，学angular的时候我就觉得这真是像学了另一种语言，等到了angular2，前面掌握的angular也就派不上什么大用场了。<br>比如现在学javascript，等到ES6普及，等于又学另一种语言了。<br>这种情势地发展对新入行的开发人员有利，因为知识一更新，老的开发人员也要重新学，大家又都在一条起跑线上了，长江后浪推前浪。</p>
</li>
</ul>
<h2 id="一些行动">一些行动</h2><h3 id="一份好的简历">一份好的简历</h3><p>推荐一个<a href="https://github.com/geekcompany/ResumeSample/blob/master/web.md" target="_blank" rel="external">模板</a>。</p>
<h3 id="多了解市场">多了解市场</h3><p>上上求职网站，搜索一下前端岗位的招聘公司数量、岗位数量、技能要求。和HR聊聊天，了解一下行业内的薪资待遇。不一定真要跳槽，但有时间也可以去参加一些面试，一来是积累面试、交流经验，二来万一真的有更好的机会也说不定。</p>
<h3 id="学会谈判/面试">学会谈判/面试</h3><p>程序员有个通病，因为长时间和机器打交道，所以沟通能力会比较差，尤其在和陌生人打交道的时候。不善于沟通在于你的不了解，不了解市场，不了解面试技巧。想一想你做了1年jquery开发，别人跟你聊jquery的时候难道你还讲不上几句么？<br>比如一些公司惯用伎俩就是问一些工作中基本上用不到的知识点来考倒你，然后说你能力还不够，但是还可以来公司好好培养，然后趁机打压薪水。<br>解决的方法参照上一条。</p>
<h3 id="扩展知识面">扩展知识面</h3><p>了解一门后端语言还是相对而言更有竞争力的。</p>
<h3 id="不要迷信技能树">不要迷信技能树</h3><p>你要记得一个人活在世上的时间是有限的，精力有限的，学了无用的东西就是在浪费时间。把那些时间拿来聚会、谈恋爱、玩乐都好，起码收获了友情、爱情、快乐。人生可以体验的事情还有很多，提升薪水也不光是凭你会几门开发语言，用过多少个js类库。学习方法、思维方式比技能都重要。</p>
<h4 id="学海无涯">学海无涯</h4><p>千万不要以为我学完了xxx和xxx就很牛逼了，这就像读中学的时候老师忽悠你用功学习，以后考上大学就轻松了，考上大学继续有人告诉你好好学习，等你工作就自由了，现在工作了，可以回头想想这些话的可信度。</p>
<h4 id="学而不思则罔，思而不学则殆">学而不思则罔，思而不学则殆</h4><p>学习之前先想想我为什么要学这个东西，要耗费我多少成本（主要是时间成本，也可以叫机会成本），学习了之后能带给我什么好处，我要学到个什么程度。。。</p>
<p><em>推荐阅读</em><br><a href="http://www.zhihu.com/question/19723850" target="_blank" rel="external">好的 Web 前端年薪会有多少？</a><br><a href="http://www.douban.com/note/498091227/" target="_blank" rel="external">程序员如何要薪水以及为什么前端程序员应该拿高薪</a></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/08/27/salary/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[移动端用css实现稍微复杂一点的进度条]]></title>
      <link>http://yalishizhude.github.io/2015/08/27/css-progress/</link>
      <guid>http://yalishizhude.github.io/2015/08/27/css-progress/</guid>
      <pubDate>Thu, 27 Aug 2015 12:21:49 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="需求">需求</h2><p>最简单的进度条实现方式：两个div嵌套，父层div背景填充底色，子层div背景填充高亮颜色，然后改变子层的宽度来表示进度条。<br>这次实现的效果稍微复杂一些，除了按宽度显示进度以外，还需要添加以下3个东西：</p>
<ul>
<li>进度条需要有节点，节点的样式根据进度进行变化</li>
<li>当前节点上方需要配置图片，图片位置需要根据进度进行变化</li>
<li>当前节点上方需要配置文字，文字位置根据图片位置而变化</li>
</ul>
<p>点击查看效果（略有修改，请把大圆球想象成图片）<br><a href="http://runjs.cn/code/q7tnucdj">http://runjs.cn/code/q7tnucdj</a></p>]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="需求">需求</h2><p>最简单的进度条实现方式：两个div嵌套，父层div背景填充底色，子层div背景填充高亮颜色，然后改变子层的宽度来表示进度条。<br>这次实现的效果稍微复杂一些，除了按宽度显示进度以外，还需要添加以下3个东西：</p>
<ul>
<li>进度条需要有节点，节点的样式根据进度进行变化</li>
<li>当前节点上方需要配置图片，图片位置需要根据进度进行变化</li>
<li>当前节点上方需要配置文字，文字位置根据图片位置而变化</li>
</ul>
<p>点击查看效果（略有修改，请把大圆球想象成图片）<br><a href="http://runjs.cn/code/q7tnucdj" target="_blank" rel="external">http://runjs.cn/code/q7tnucdj</a></p>
<a id="more"></a>
<h2 id="进度条及节点实现">进度条及节点实现</h2><h3 id="横线">横线</h3><p>看到这么多有规律的圆点和横线，第一眼想到的就是ul-li标签了。ul可以用来当整个进度条的背景，li是用来做圆点还是横线呢？当然是横线，不然红色的高亮横线用什么填充？新建dom元素？nonono~</p>
<h3 id="圆点">圆点</h3><p>那这样圆点怎么实现，而且这个圆点有个复杂的地方：外面套了一层圆环。两个有用的css伪类可以帮助我——before和after。简单的理解它的作用就是在元素中创建dom并给它添加样式。<br>这里两个伪类都要用到来实现圆环效果。一个做底部的圆环，另一个做顶部的圆点。这里用before做圆点，after做圆环，因为默认第一个节点是高亮的。问题来了：这样的话第一个节点没有圆环，最后一个节点没有圆点。<br>解决的方法当然很简单，多加两个li标签就行了。</p>
<h2 id="图片位置变化实现">图片位置变化实现</h2><p>因为li标签按百分比显示/高亮，所以计算图片的位置并不难，用绝对定位可以轻松搞定</p>
<h2 id="文字位置变化实现">文字位置变化实现</h2><p>这个也没有什么难度，关键是注意图片的在移动过程中会遮挡文字，所以需要动态改变图片的左右位置，通过float属性的left和right值即可轻松实现。</p>
<h2 id="html代码">html代码</h2><pre><code><span class="tag">&lt;<span class="title">html</span>&gt;</span>
    <span class="tag">&lt;<span class="title">body</span>&gt;</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"ans-head"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">i</span> <span class="attribute">class</span>=<span class="value">"person"</span>&gt;</span><span class="tag">&lt;/<span class="title">i</span>&gt;</span>
            <span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"progress"</span>&gt;</span>
                <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
                <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"step-5 active"</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
                <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"step-5 active"</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
                <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"step-5"</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
                <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"step-5"</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
                <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"step-5"</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
                <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
            <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"right-title"</span> &gt;</span>这里是标题文字<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</code></pre><h2 id="css代码">css代码</h2><pre><code><span class="tag">html</span>,<span class="tag">body</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">320px</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">100%</span></span></span>;
    <span class="rule"><span class="attribute">padding</span>:<span class="value"><span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">margin</span>:<span class="value"><span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">20px</span></span></span>;
}</span>
<span class="class">.ans-head</span> <span class="rules">{
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">2.5rem</span></span></span>;
  <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">2.5rem</span></span></span>;
  <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span> <span class="number">1rem</span></span></span>;
}</span>
<span class="class">.ans-head</span> <span class="class">.left-title</span> <span class="rules">{
  <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">0.6rem</span></span></span>;
  <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>;
  <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#929295</span></span></span>;
}</span>
<span class="class">.ans-head</span> <span class="class">.right-title</span> <span class="rules">{
  <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">0.6rem</span></span></span>;
  <span class="rule"><span class="attribute">float</span>:<span class="value"> right</span></span>;
  <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#929295</span></span></span>;
}</span>
<span class="class">.ans-head</span> <span class="tag">i</span> <span class="rules">{
  <span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">100%</span></span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">1.5rem</span></span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">1.5rem</span></span></span>;
  <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">1.5rem</span></span></span>;
  <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;
  <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
  <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0.5rem</span></span></span>;
  <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">0.5rem</span></span></span>;
  <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">5.6rem</span></span></span>;
  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> red</span></span>;
}</span>
<span class="class">.ans-head</span> <span class="tag">ul</span><span class="class">.progress</span> <span class="rules">{
  <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
  <span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="number">2.4rem</span></span></span>;
  <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">0.1rem</span></span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">14rem</span></span></span>;
  <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">1rem</span></span></span>;
  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#d4d4d5</span></span></span>;
  <span class="rule"><span class="attribute">overflow</span>:<span class="value"> visible</span></span>;
}</span>
<span class="class">.ans-head</span> <span class="tag">ul</span><span class="class">.progress</span> <span class="tag">li</span> <span class="rules">{
  <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>;
  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#d4d4d5</span></span></span>;
  <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;
  <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">0.1rem</span></span></span>;
  <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">0</span></span></span>;
}</span>
<span class="class">.ans-head</span> <span class="tag">ul</span><span class="class">.progress</span> <span class="tag">li</span><span class="class">.step-2</span> <span class="rules">{
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">50%</span></span></span>;
}</span>
<span class="class">.ans-head</span> <span class="tag">ul</span><span class="class">.progress</span> <span class="tag">li</span><span class="class">.step-3</span> <span class="rules">{
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">33.3%</span></span></span>;
}</span>
<span class="class">.ans-head</span> <span class="tag">ul</span><span class="class">.progress</span> <span class="tag">li</span><span class="class">.step-4</span> <span class="rules">{
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">25%</span></span></span>;
}</span>
<span class="class">.ans-head</span> <span class="tag">ul</span><span class="class">.progress</span> <span class="tag">li</span><span class="class">.step-5</span> <span class="rules">{
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">20%</span></span></span>;
}</span>
<span class="class">.ans-head</span> <span class="tag">ul</span><span class="class">.progress</span> <span class="tag">li</span><span class="class">.step-6</span> <span class="rules">{
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">16.6%</span></span></span>;
}</span>
<span class="class">.ans-head</span> <span class="tag">ul</span><span class="class">.progress</span> <span class="tag">li</span><span class="class">.active</span> <span class="rules">{
  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#ff0000</span></span></span>;
}</span>
<span class="class">.ans-head</span> <span class="tag">ul</span><span class="class">.progress</span> <span class="rule"><span class="attribute">li</span>:<span class="value">before {
  display: inline-block</span></span>;
  <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">0.5rem</span></span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">0.5rem</span></span></span>;
  <span class="rule"><span class="attribute">left</span>:<span class="value"> -<span class="number">0.25rem</span></span></span>;
  <span class="rule"><span class="attribute">top</span>:<span class="value"> -<span class="number">0.25rem</span></span></span>;
  <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">0.5rem</span></span></span>;
  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#f0eff4</span></span></span>;
  <span class="rule"><span class="attribute">content</span>:<span class="value"> <span class="string">''</span></span></span>;
}
<span class="class">.ans-head</span> <span class="tag">ul</span><span class="class">.progress</span> <span class="rule"><span class="attribute">li</span>:<span class="value">after {
  content: <span class="string">''</span></span></span>;
  <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
  <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">0.2rem</span></span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">0.2rem</span></span></span>;
  <span class="rule"><span class="attribute">right</span>:<span class="value"> -<span class="number">0.1rem</span></span></span>;
  <span class="rule"><span class="attribute">top</span>:<span class="value"> -<span class="number">0.1rem</span></span></span>;
  <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">0.3rem</span></span></span>;
  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#d5d5d5</span></span></span>;
  <span class="rule"><span class="attribute">z-index</span>:<span class="value"> <span class="number">1</span></span></span>;
}
<span class="class">.ans-head</span> <span class="tag">ul</span><span class="class">.progress</span> <span class="rule"><span class="attribute">li</span>:<span class="value">first-child:after {
  content: <span class="string">''</span></span></span>;
  <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
  <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">0.2rem</span></span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">0.2rem</span></span></span>;
  <span class="rule"><span class="attribute">right</span>:<span class="value"> -<span class="number">0.1rem</span></span></span>;
  <span class="rule"><span class="attribute">top</span>:<span class="value"> -<span class="number">0.1rem</span></span></span>;
  <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">0.3rem</span></span></span>;
  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#ff0000</span></span></span>;
  <span class="rule"><span class="attribute">z-index</span>:<span class="value"> <span class="number">1</span></span></span>;
}
<span class="class">.ans-head</span> <span class="tag">ul</span><span class="class">.progress</span> <span class="rule"><span class="attribute">li.active</span>:<span class="value">after {
  content: <span class="string">''</span></span></span>;
  <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
  <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">0.2rem</span></span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">0.2rem</span></span></span>;
  <span class="rule"><span class="attribute">right</span>:<span class="value"> -<span class="number">0.1rem</span></span></span>;
  <span class="rule"><span class="attribute">top</span>:<span class="value"> -<span class="number">0.1rem</span></span></span>;
  <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">0.3rem</span></span></span>;
  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#ff0000</span></span></span>;
  <span class="rule"><span class="attribute">z-index</span>:<span class="value"> <span class="number">1</span></span></span>;
}
</code></pre><h2 id="总结">总结</h2><ol>
<li>移动端在html中设置font-size之后，再用rem来设置字体和边距、元素大小可以较好的做到适配不同大小的屏幕。</li>
<li>圆环和箭头一般的实现思路都是元素的叠加。</li>
<li>before和after可以有效的减少dom</li>
</ol>
<blockquote>
<p>本篇文章并没有太多新鲜的东西，之所以还是记下来，一是养成了写文章整理记录的习惯，二是因为觉得，相比技能本身，解决问题的思路更重要。就像是很多人认得三千个汉字，但是有的人就可以写出优秀的文章，思维决定行为。</p>
</blockquote>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/08/27/css-progress/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[技术文章收藏]]></title>
      <link>http://yalishizhude.github.io/2015/08/25/favorites/</link>
      <guid>http://yalishizhude.github.io/2015/08/25/favorites/</guid>
      <pubDate>Tue, 25 Aug 2015 14:47:53 GMT</pubDate>
      <description>
      <![CDATA[<a id="more"></a>
<h2 id="前端工具">前端工具</h2><h3 id="Git">Git</h3><ul>
<li><a href="http://www.mamicode.com/info-detail-175353.html" target="_bl]]>
      </description>
      <content:encoded><![CDATA[<a id="more"></a>
<h2 id="前端工具">前端工具</h2><h3 id="Git">Git</h3><ul>
<li><a href="http://www.mamicode.com/info-detail-175353.html" target="_blank" rel="external">使用百度网盘+Git，把版本控制托管到云端</a></li>
</ul>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/08/25/favorites/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[学习jquery之前了解一下requirejs也无妨]]></title>
      <link>http://yalishizhude.github.io/2015/08/22/requirejs/</link>
      <guid>http://yalishizhude.github.io/2015/08/22/requirejs/</guid>
      <pubDate>Sat, 22 Aug 2015 01:35:51 GMT</pubDate>
      <description>
      <![CDATA[<p>jquery算是最先了解的一个js库，算是一种工具库，提供了很多实用的工具函数，也为其它很多插件提供了开发基础，但是用了这么久，我看不出其中有什么核心的思想性的东西。<br>requirejs的核心思想用一个单词可以概括：AMD。它只做了一件事：模块化。而且这件事做得还挺好：通过简单的配置、调用方式，加速、优化了代码。结合我在项目中的一些使用经验，从以下几个方面总结了一下requirejs的特点。</p>
<hr>]]>
      
      </description>
      <content:encoded><![CDATA[<p>jquery算是最先了解的一个js库，算是一种工具库，提供了很多实用的工具函数，也为其它很多插件提供了开发基础，但是用了这么久，我看不出其中有什么核心的思想性的东西。<br>requirejs的核心思想用一个单词可以概括：AMD。它只做了一件事：模块化。而且这件事做得还挺好：通过简单的配置、调用方式，加速、优化了代码。结合我在项目中的一些使用经验，从以下几个方面总结了一下requirejs的特点。</p>
<hr>
<a id="more"></a>
<h3 id="配置">配置</h3><pre><code><span class="tag">&lt;<span class="title">script</span> <span class="attribute">data-main</span>=<span class="value">"main.js"</span> <span class="attribute">src</span>=<span class="value">"frame/js/require.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p>首先需要像这样在页面上引用requirejs。它和jquery这种类库的不同之处是，它并不是引用了之后就可以使用，它需要一个简单的配置文件来定义那些不符合requirejs格式的模块以及它们之间的依赖关系。这里main.js就是它的配置文件。打开来是这样的结构</p>
<pre><code>requirejs.config({
        baseUrl: <span class="string">"frame"</span>,//模块查找的根路径
        paths: {
            <span class="string">"zepto"</span>: <span class="string">"js/zepto"</span>,
            <span class="string">"frozen"</span>: <span class="string">"js/frozen"</span>,
            <span class="string">"underscore"</span>: <span class="string">"js/underscore"</span>,
            <span class="string">"text"</span>: <span class="string">"js/text"</span>,
            <span class="string">"css"</span>: <span class="string">"js/css"</span>,
            <span class="string">"route"</span>: <span class="string">"../js/route"</span>
        },
        shim: {
            <span class="string">"zepto"</span>: {
                exports: <span class="string">"$"</span>
            },
            <span class="string">"underscore"</span>: {
                exports: <span class="string">"_"</span>
            },
            <span class="string">"frozen"</span>: {
                deps: [<span class="string">"zepto"</span>]
            }
        }
    });
</code></pre><p>paths是预定义的一些模块，比如frame/js/zepto.js定义为zepto模块。<br>shim很重要，处理了导出名称和依赖关系。第1个zepto模块的全局变量名称为’$’（这个就好比JQuery.js我们叫做jquery，实际用的时候我们用$作为变量），第3个frozen模块表示当它被加载的时候，需要先加载zepto模块。</p>
<h3 id="调用">调用</h3><p>常用的调用方式一般是执行一个define函数</p>
<ul>
<li>第1个参数是依赖的模块，可以是在path定义的公用模块，也可以是自定义的代码，不过自定义的代码需要注明引用路径，例如<code>../js/util.js</code>这种</li>
<li>第2个参数是自定义模块，传入的是一个匿名函数，函数参数顺序和模块顺序一一对应，最后return的对象或函数即为对外暴露的接口。对详细的使用方法有兴趣的可以看<a href="http://javascript.ruanyifeng.com/tool/requirejs.html" target="_blank" rel="external">这篇文章</a></li>
<li>第3个是模块加载报错的处理函数（一般可以省略）。</li>
</ul>
<p>需要注意的是，这里的模块加载是<em>异步</em>的，也就是说同时加载zepto和route这两个模块，但是只等两个模块加载完成之后才执行后面的模块代码。想详细了解的话可以看<a href="http://www.douban.com/note/283566440/" target="_blank" rel="external">这篇文章</a>。<br>这种异步加载模块的方式很像我之前一篇文章<a href="http://yalishizhude.github.io/2015/08/18/js-async/#comments">浅谈js中多并发的一些处理方法</a>提到的场景，个人比较推崇这种高效的方式，不像CMD按顺序依次加载影响性能。</p>
<pre><code>define([<span class="string">'zepto'</span>, <span class="string">'route'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$, state</span>) </span>{
    <span class="keyword">return</span> {
        init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            $(<span class="string">'.logo-wrap'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
                state.go(<span class="string">'photo'</span>);
            });
        }
    };
});
</code></pre><h3 id="进阶or技巧">进阶or技巧</h3><ul>
<li>package</li>
</ul>
<p>包就是讲模块再次组合封装起来。目前项目中没有用到，感觉在很大型的项目才有使用必要。</p>
<ul>
<li>CDN</li>
</ul>
<p>如果我们想引用cdn上的代码，可以在配置文件中的paths属性中这么写</p>
<pre><code><span class="string">"zepto"</span>: [<span class="string">'http://apps.bdimg.com/libs/zepto/1.1.4/zepto.min'</span>,<span class="string">"js/zepto"</span>]
</code></pre><p>第一个值为cdn中的路径，当加载失败时从第2个本地路径加载。</p>
<p>想知道cdn是什么有什么用，可以看我之前写的<a href="http://yalishizhude.github.io/2015/07/04/cdn/">CDN简介</a></p>
<ul>
<li>插件</li>
</ul>
<p>如果认为requirejs只能管理js代码那就想得太简单了。<br>配上text插件即可把html文件当做模块引入。用处就是可以当做碎片页来处理，类似jquery中的load函数，不过好处就是这个html文件可以被缓存，而不是像jquery每load一次就发起一次ajax请求。<br>配上<a href="https://github.com/guybedford/require-css" target="_blank" rel="external">require-css插件</a>即可管理css代码。不过并不建议这样做，个人觉得还是老老实实在head中通过link标签来引入有利于页面快速加载。</p>
<h3 id="使用意义">使用意义</h3><ul>
<li>各个功能可以协同开发</li>
<li>公用代码形成模块后方便调用</li>
<li>避免各个模块冲突</li>
<li>可以良好地处理依赖关系</li>
</ul>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/08/22/requirejs/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[浅谈js中多并发的一些处理方法]]></title>
      <link>http://yalishizhude.github.io/2015/08/18/js-async/</link>
      <guid>http://yalishizhude.github.io/2015/08/18/js-async/</guid>
      <pubDate>Mon, 17 Aug 2015 17:35:10 GMT</pubDate>
      <description>
      <![CDATA[<p>经常在写代码的时候碰到这样的场景：页面初始化时显示loading页，同时启动多个ajax并发请求获取数据，当每个ajax请求返回时结束loading。<br>举个例子，一个下订单的页面，要查询常用地址信息、商品信息、地市信息…而这些请求都是异步的，希望等到所有数据加载完成后再允许用户操作。<br>要实现这个场景容易碰到的一个问题就是多并发怎么控制？下面是一些解决方法和思路：</p>
<hr>]]>
      
      </description>
      <content:encoded><![CDATA[<p>经常在写代码的时候碰到这样的场景：页面初始化时显示loading页，同时启动多个ajax并发请求获取数据，当每个ajax请求返回时结束loading。<br>举个例子，一个下订单的页面，要查询常用地址信息、商品信息、地市信息…而这些请求都是异步的，希望等到所有数据加载完成后再允许用户操作。<br>要实现这个场景容易碰到的一个问题就是多并发怎么控制？下面是一些解决方法和思路：</p>
<hr>
<a id="more"></a>
<h2 id="并行改为串行">并行改为串行</h2><p>如果业务逻辑本身是串行的，但是提供的请求方式又是异步的，可以考虑此方法。<br>但本场景显然不是这种情况，这样做大大降低了页面性能，延长了加载速度。</p>
<h3 id="回调">回调</h3><p>只适合并发数少的情况，多层嵌套回调会让代码的可读性大大降低</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">async1</span><span class="params">()</span>{</span>
    <span class="comment">//do sth...</span>
}
<span class="function"><span class="keyword">function</span> <span class="title">async2</span><span class="params">()</span>{</span>
    <span class="comment">//do sth...</span>
    async1<span class="params">()</span>;
}
async2<span class="params">()</span>;
</code></pre><h3 id="ajax改为同步">ajax改为同步</h3><p>如在jquery中将async参数设置为false</p>
<pre><code>$.ajax({
    url:<span class="string">"/jquery/test1.txt"</span>,
    <span class="keyword">async</span>:<span class="literal">false</span>
});
</code></pre><h2 id="设置结束标识">设置结束标识</h2><p>简单一点的可以设置计数器，每完成一个异步函数加1，或者设置一个数组，每执行完一个异步函数更新数组。</p>
<h2 id="回调计数">回调计数</h2><pre><code>var cnt = <span class="number">0</span>;
<span class="function"><span class="keyword">function</span> <span class="title">async1</span><span class="params">()</span>{</span>
    <span class="comment">//do sth...</span>
    callback<span class="params">()</span>;
}
<span class="function"><span class="keyword">function</span> <span class="title">async2</span><span class="params">()</span>{</span>
    <span class="comment">//do sth...</span>
    callback<span class="params">()</span>;
}
<span class="function"><span class="keyword">function</span> <span class="title">callback</span><span class="params">()</span>{</span>
    cnt++;
    <span class="keyword">if</span><span class="params">(<span class="number">2</span>==cnt)</span> console.<span class="built_in">log</span><span class="params">('都已执行完毕')</span>;
}
</code></pre><h3 id="循环阻塞">循环阻塞</h3><pre><code><span class="keyword">var</span> cnt = <span class="number">0</span>;
<span class="function"><span class="keyword">function</span> <span class="title">async1</span><span class="params">()</span></span>{
    <span class="comment">//do sth...</span>
    cnt++;
}
<span class="function"><span class="keyword">function</span> <span class="title">async2</span><span class="params">()</span></span>{
    <span class="comment">//do sth...</span>
    cnt++;
}
<span class="keyword">while</span>(<span class="number">2</span>&gt;cnt){}
</code></pre><h3 id="循环非阻塞">循环非阻塞</h3><p>不建议过多使用，以免影响性能</p>
<pre><code><span class="keyword">var</span> cnt = <span class="number">0</span>;

<span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>{
    <span class="comment">//do sth...</span>
    cnt++;
}
<span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>{
    <span class="comment">//do sth...</span>
    cnt++;
}
<span class="keyword">var</span> interval = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="keyword">if</span>(<span class="number">2</span>===cnt){
        <span class="built_in">console</span>.log(<span class="string">'已执行完成'</span>);
        clearInterval(interval)
    }
}, <span class="number">0</span>);
</code></pre><h2 id="第三方框架实现">第三方框架实现</h2><h3 id="jquery">jquery</h3><p>目前我在项目中采用的方式</p>
<pre><code><span class="keyword">var</span> d1 = $.Deferred();
<span class="keyword">var</span> d2 = $.Deferred();

<span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>{
    d1.resolve( <span class="string">"Fish"</span> );
}

<span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>{
    d2.resolve( <span class="string">"Pizza"</span> );
}

$.when( d1, d2 ).done(<span class="function"><span class="keyword">function</span> (<span class="params"> v1, v2 </span>) </span>{
    <span class="built_in">console</span>.log( v1 + v2 + <span class="string">'已完成'</span>);
});
</code></pre><h3 id="angular">angular</h3><p>具体代码不写了，可以参考API文档中关于<a href="http://docs.angularjs.cn/api/ng/type/$rootScope.Scope#$watch" target="_blank" rel="external">$watch</a>的说明，$q服务也可以实现promise。</p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/08/18/js-async/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[优雅的underscore]]></title>
      <link>http://yalishizhude.github.io/2015/08/02/beatiful-underscore/</link>
      <guid>http://yalishizhude.github.io/2015/08/02/beatiful-underscore/</guid>
      <pubDate>Sun, 02 Aug 2015 14:56:05 GMT</pubDate>
      <description>
      <![CDATA[<p><em>Less write,less bug.</em></p>
<p><em>Don’t repeat it.</em></p>
<p>这是我写代码奉行的原则，而underscore.js很好地体现了上面两句话的精髓。</p>
<p>之前学习angular的时候了解到了同类型的类库有backbone，然后一看backbone的介绍顿时莫名其妙了：轻度依赖jquery，重度依赖underscore。jquery不是最流行的js类库么？竟然重度依赖个没听说过的underscore，打开underscore官网，介绍别具一格：</p>
<blockquote>
<p>他解决了这个问题：“如果我面对一个空白的 HTML 页面，并希望立即开始工作，我需要什么？” 他弥补了 jQuery 没有实现的功能，同时又是 Backbone 必不可少的部分。</p>
</blockquote>
<p>“弥补了”、“必不可少”这牛皮吹得有点过了吧，于是了解使用了一下，发现确实是个好工具，于是把常用的几个函数做了一下整理。</p>]]>
      
      </description>
      <content:encoded><![CDATA[<p><em>Less write,less bug.</em></p>
<p><em>Don’t repeat it.</em></p>
<p>这是我写代码奉行的原则，而underscore.js很好地体现了上面两句话的精髓。</p>
<p>之前学习angular的时候了解到了同类型的类库有backbone，然后一看backbone的介绍顿时莫名其妙了：轻度依赖jquery，重度依赖underscore。jquery不是最流行的js类库么？竟然重度依赖个没听说过的underscore，打开underscore官网，介绍别具一格：</p>
<blockquote>
<p>他解决了这个问题：“如果我面对一个空白的 HTML 页面，并希望立即开始工作，我需要什么？” 他弥补了 jQuery 没有实现的功能，同时又是 Backbone 必不可少的部分。</p>
</blockquote>
<p>“弥补了”、“必不可少”这牛皮吹得有点过了吧，于是了解使用了一下，发现确实是个好工具，于是把常用的几个函数做了一下整理。</p>
<a id="more"></a>
<hr>
<h2 id="函数">函数</h2><h3 id="template">template</h3><p>经常看到这样的代码</p>
<pre><code>var str = '&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"'+obj.className+'"</span> <span class="property">id</span>=<span class="string">"'+obj.id+'"</span>&gt;'+obj.<span class="property">name</span>+'&lt;/<span class="keyword">div</span>&gt;';
</code></pre><p>在javascript中拼凑html字符串是一件很蛋疼的事情，尤其是穿插json变量的时候，现在有了template函数：</p>
<pre><code><span class="keyword">var</span> temp = _.<span class="keyword">template</span>('&lt;<span class="keyword">div</span> class=<span class="string">"&lt;%=className%&gt;"</span> id=<span class="string">"&lt;%=id%&gt;"</span>&gt;&lt;%=name%&gt;&lt;/<span class="keyword">div</span>&gt;');
<span class="keyword">var</span> str = temp(obj);
</code></pre><p>像不像ejs？jsp？underscore！如果对<code>templateSettings</code>进行设置，可以变成改变模板变量的匹配规则，比如angular爱好者可以通过下面的函数改成花括号</p>
<pre><code>_.templateSettings = <span class="special">{</span>
  interpolate: /<span class="command">\{</span><span class="command">\{</span>(.+?)<span class="command">\}</span><span class="command">\}</span>/g
<span class="special">}</span>;
</code></pre><h3 id="_-now()">_.now()</h3><p>以前是不是这么取时间戳？</p>
<pre><code><span class="built_in">var</span> <span class="built_in">date</span> = <span class="literal">new</span> <span class="built_in">Date</span>();
<span class="built_in">var</span> seconds = <span class="built_in">date</span><span class="built_in">.</span>getTimes();
</code></pre><p>现在可以这么简单</p>
<pre><code><span class="variable"><span class="keyword">var</span> seconds</span> = _.now();
</code></pre><h3 id="uniqueId">uniqueId</h3><p>给多个元素创建id以前这么写</p>
<pre><code>var dom = document.createElement(<span class="string">'div'</span>);
<span class="keyword">for</span>(var <span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;arr.<span class="built_in">length</span>;<span class="built_in">i</span>++)<span class="cell">{
    dom.id = <span class="string">'xxx'</span>+i;
}</span>
</code></pre><p>有时候id容易重复，如果比如数组重复执行或者和其它逻辑冲突，现在这么写100%不会冲突</p>
<pre><code>var dom = document.createElement(<span class="string">'div'</span>);
<span class="keyword">for</span>(var <span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;arr.<span class="built_in">length</span>;<span class="built_in">i</span>++)<span class="cell">{
    dom.id = _.uniqueId(<span class="string">'xxx'</span>);
}</span>
</code></pre><h3 id="random">random</h3><p>我要随机数，而且是整数</p>
<pre><code><span class="function"><span class="title">parseInt</span><span class="params">(Math.random()</span></span>*<span class="number">100</span>)
</code></pre><p>如果改一下，要1到100的整数？用三目运算？函数？还是underscore吧~</p>
<pre><code>_.<span class="function"><span class="title">random</span><span class="params">(<span class="number">1</span>,<span class="number">100</span>)</span></span>
</code></pre><h3 id="delay">delay</h3><p>js并行写法</p>
<pre><code>setTimeout<span class="list">(<span class="keyword">function</span><span class="list">()</span>{
    console.log<span class="list">(<span class="keyword">obj</span>.id)</span><span class="comment">;</span>
}, <span class="number">0</span>)</span><span class="comment">;</span>
</code></pre><p>用underscore并行</p>
<pre><code>_.<span class="command">delay</span>(function(){
    console.<span class="command">log</span>(obj.<span class="property">id</span>);
}, <span class="number">0</span>, obj.<span class="property">id</span>);
</code></pre><p>参数传递很方便        </p>
<h2 id="对象">对象</h2><h3 id="isEqual">isEqual</h3><pre><code><span class="variable"><span class="keyword">var</span> obj</span> = {id:<span class="number">1</span>, name:'tom'};
<span class="variable"><span class="keyword">var</span> _obj</span> = {id:<span class="number">1</span>, name:'tom'};

<span class="variable"><span class="keyword">var</span> arr</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];
<span class="variable"><span class="keyword">var</span> _arr</span> = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>];
</code></pre><p>这两个对象怎么比较是否相等？函数？循环遍历？</p>
<pre><code>_.<span class="function"><span class="title">isEqual</span><span class="params">(obj, _obj)</span></span> ==&gt; true
_.<span class="function"><span class="title">isEqual</span><span class="params">(arr, _arr)</span></span> ==&gt; false
</code></pre><p>轻轻松松3秒钟~</p>
<h3 id="pick/omit">pick/omit</h3><p>服务器返回的结果可能是这样的</p>
<pre><code><span class="label">var</span> old = {k1: <span class="literal">v1</span>, k2: <span class="literal">v2</span>, k3: <span class="literal">v3</span>, k4: <span class="literal">v4</span>, k5: <span class="literal">v5</span>}<span class="comment">;</span>
</code></pre><p>我们需要的可能是这样的</p>
<pre><code>var <span class="keyword">new</span> = {<span class="string">k1:</span> old.k1, <span class="string">k3:</span> old.k3};
</code></pre><p>每个属性抄一遍多麻烦~轮到pick/omit这一对好基友上场了</p>
<pre><code><span class="keyword">var</span> new1 = _.pick(<span class="keyword">old</span>, <span class="string">'k1'</span>, <span class="string">'k3'</span>);
<span class="keyword">var</span> new2 = _.omit(<span class="keyword">old</span>, <span class="string">'k2'</span>, <span class="string">'k4'</span>, <span class="string">'k5'</span>);
</code></pre><p>反正过滤得多就用pick，复制得多就用omit</p>
<h3 id="extend">extend</h3><pre><code>var info = {<span class="string">id:</span><span class="number">1</span>, <span class="string">name:</span><span class="string">'jack'</span>, <span class="string">sex:</span> <span class="string">'male'</span>, <span class="string">age:</span> <span class="string">'22'</span>};
var score = {<span class="string">id:</span><span class="number">1</span>, <span class="string">math:</span><span class="number">88</span>, <span class="string">biology:</span><span class="number">64</span>, <span class="string">chinese:</span> <span class="number">55</span>};
</code></pre><p>要把个人信息和成绩合并怎么办？一个属性一个属性的赋值？no~</p>
<pre><code><span class="variable"><span class="keyword">var</span> student</span> = _.extend(info, score);
</code></pre><h3 id="map">map</h3><p>遍历对象</p>
<pre><code><span class="function"><span class="keyword">function</span><span class="params">(obj)</span></span>{
    <span class="keyword">for</span>(<span class="keyword">var</span> e <span class="keyword">in</span> obj){
        <span class="comment">//...</span>
    }
}
</code></pre><p>用map</p>
<pre><code>_.map(obj,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{value, key}{
    <span class="comment">//...</span>
});
</code></pre><h2 id="数组">数组</h2><h3 id="union">union</h3><p>两个数组要合并，循环去重？一个函数搞定</p>
<pre><code>_.<span class="keyword">union</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">101</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">10</span>], [<span class="number">2</span>, <span class="number">1</span>]);
==&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">101</span>, <span class="number">10</span>]
</code></pre><h3 id="range">range</h3><p>来个整数数组</p>
<pre><code><span class="keyword">var</span> arr = [];
<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)<span class="comment">{
    arr[i] = i+1;
}</span>
</code></pre><p>明明可以一行代码搞定</p>
<pre><code>var arr = _.range(<span class="number">1</span>,<span class="number">100</span>);
</code></pre><h3 id="each">each</h3><p>写了多少便的经典代码：</p>
<pre><code>for<span class="comment">(var i=0;i&lt;arr.length;i++)</span>{
    <span class="comment">//arr[i]...</span>
}
</code></pre><p>改一改吧</p>
<pre><code>_.each(arr, <span class="function"><span class="keyword">function</span><span class="params">(obj, index)</span></span>{
    console.<span class="built_in">log</span>(<span class="built_in">index</span>);
    console.<span class="built_in">log</span>(obj);
});
</code></pre><h3 id="reduce">reduce</h3><p>累加求和用得再多不过了</p>
<pre><code>var count = <span class="number">0</span>;
<span class="keyword">for</span>(var <span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;<span class="built_in">i</span>&lt;arr.<span class="built_in">length</span>;<span class="built_in">i</span>++)<span class="cell">{
    count += arr[i].price;
}</span>
</code></pre><p>多么简洁~</p>
<pre><code><span class="keyword">var</span> count = _.reduce([{name:<span class="string">'x'</span>, price:<span class="number">10</span>}, {name:<span class="string">'y'</span>, price:<span class="number">20</span>}], <span class="function"><span class="keyword">function</span><span class="params">(memo, item)</span></span>{ <span class="keyword">return</span> memo + item.price; }, <span class="number">0</span>);
</code></pre><h3 id="filter/where">filter/where</h3><p>过滤数组元素可以用each来实现，但是filter/where用于过滤更方便</p>
<pre><code>_.filter([-<span class="number">1</span>, <span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], function(num){ <span class="keyword">return</span> num &gt; <span class="number">0</span>; });
==&gt; [<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>]

_.where([{<span class="string">author:</span><span class="string">'zdl'</span>, <span class="string">year:</span><span class="number">2015</span>},{<span class="string">title:</span> <span class="string">"Cymbeline"</span>, <span class="string">author:</span> <span class="string">"Shakespeare"</span>, <span class="string">year:</span> <span class="number">1611</span>}]], {<span class="string">author:</span> <span class="string">"Shakespeare"</span>, <span class="string">year:</span> <span class="number">1611</span>});
==&gt; [{<span class="string">title:</span> <span class="string">"Cymbeline"</span>, <span class="string">author:</span> <span class="string">"Shakespeare"</span>, <span class="string">year:</span> <span class="number">1611</span>}]
</code></pre><h3 id="pluck">pluck</h3><p>用来抽取复杂数组的数据</p>
<pre><code>_.pluck([{<span class="string">name:</span> <span class="string">'moe'</span>, <span class="string">age:</span> <span class="number">40</span>}, {<span class="string">name:</span> <span class="string">'larry'</span>, <span class="string">age:</span> <span class="number">50</span>}, {<span class="string">name:</span> <span class="string">'curly'</span>, <span class="string">age:</span> <span class="number">60</span>}], <span class="string">'name'</span>);
==&gt; [<span class="string">"moe"</span>, <span class="string">"larry"</span>, <span class="string">"curly"</span>]
</code></pre><h3 id="sortBy">sortBy</h3><p>排序太常用了，不传函数的情况下按大小排序，传函数的情况下可以通过计算结果对原数组排序</p>
<pre><code>_.sortBy([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, -<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);
==&gt; [-<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]

_.sortBy([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, -<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], function(num){ <span class="keyword">return</span> num*num})
[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, -<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]
</code></pre><p>更多内容请查看<a href="http://www.bootcss.com/p/underscore" target="_blank" rel="external">API文档</a></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/08/02/beatiful-underscore/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[windows下搭建前端开发IDE（maven + grunt + tomcat + cmd + sublime）]]></title>
      <link>http://yalishizhude.github.io/2015/07/28/makeIDE/</link>
      <guid>http://yalishizhude.github.io/2015/07/28/makeIDE/</guid>
      <pubDate>Tue, 28 Jul 2015 15:51:51 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="那些年用过的IDE">那些年用过的IDE</h2><p>很有幸，在做前端工程师之前我是一名全栈开发人员，所以接触了目前主流的用于jsp开发的IDE：eclipse和IntelliJ。它们的优点就是集成了很多插件，所以够智能。<br>很不幸，eclipse的流畅性极差（经常容易卡死,白瞎了我10G RAM、128G SSD + 256G HD、i3 CPU的笔记本）以及贪得无厌的消耗内存。IntelliJ作为付费产品，其稳定性也是值得吐槽的，经常出现莫名其妙的bug导致项目无法正常部署。<br>而如果需要开发后端代码，断点调试必不可少，除IDE外也无他更好工具，所以谈起IDE都是爱恨交织。<br>]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="那些年用过的IDE">那些年用过的IDE</h2><p>很有幸，在做前端工程师之前我是一名全栈开发人员，所以接触了目前主流的用于jsp开发的IDE：eclipse和IntelliJ。它们的优点就是集成了很多插件，所以够智能。<br>很不幸，eclipse的流畅性极差（经常容易卡死,白瞎了我10G RAM、128G SSD + 256G HD、i3 CPU的笔记本）以及贪得无厌的消耗内存。IntelliJ作为付费产品，其稳定性也是值得吐槽的，经常出现莫名其妙的bug导致项目无法正常部署。<br>而如果需要开发后端代码，断点调试必不可少，除IDE外也无他更好工具，所以谈起IDE都是爱恨交织。<br><a id="more"></a></p>
<h2 id="项目状况">项目状况</h2><p>现在的项目用jsp开发，属于前后端“半分离”状态。<br>从技术上说，用了freemarker模板，这个东西有点像jsp页面，会用到一些java代码，却又可以写在html文件中，所以并没有真正意义上的让前后端分离。<br>从结构上说，整个产品有点像cs架构，分为client端的web项目和server端的web项目，client端负责响应浏览器请求，返回js、css、html等，server端负责与数据库、client端交互。表面上看是一种分离，实际上已是“半分离”状态，因为如果client端想单独调试基本不可能，原因很简单，freemarker填充模板数据失败报错404。个人觉得freemarker还是更加适合于jsp全栈开发，用于前后端分离太尴尬。<br>由于前段开发只需关注client端，所以开始使用Intellij的初衷是通过maven下载打包web项目，启动tomcat服务器并实时更新修改的前端文件。后来被折磨了几次，所以决定自己定制化“IDE”。</p>
<h2 id="关于开发工具（题外话）">关于开发工具（题外话）</h2><p>我觉得最优秀的开发工具需要满足两个特点：</p>
<ol>
<li>定制化<br>每个开发者根据自己的使用习惯和项目需求来选择插件并进行配置。</li>
<li>可扩展<br>开发工具本身提供良好的接口，让各位开发者能参与开发其它插件来不断强化它。<br>令我印象最深的4款编辑器符合这两个特点：<code>emacs、vim、sublime、atom</code>。简单的说一说他们的优缺点吧。</li>
</ol>
<ul>
<li>emacs：当之无愧的神之编辑器，学习曲线是最难的，只有大神才可将其用得淋漓尽致，各种ctrl、alt快捷键在windows键盘下使用相当不适应。</li>
<li>vim：编辑器之神。最大的特点是可以脱离鼠标很舒服地编辑代码，与emacs不一样，它不是ctrl到死的方式使用快捷键，而是用esc来切换模式，配合上强大宏以及多种插件，也是相当顺手的一件工具。使用它还有一个原因：它跨平台。linux服务器自带了vi，掌握了vim，上linux服务器上查看编辑文件再也不用犯愁了。</li>
<li>sublime：插件丰富，开发者活跃，当下流行，正在使用。</li>
<li>atom：后起之秀，界面美观，github强推工具，基本上模仿了sublime，但是流畅性还是做得不够好，如果这方面加强我会毫不犹豫地转投github的怀抱。</li>
</ul>
<h2 id="实现方式">实现方式</h2><p>在windows下想把各种工具集成起来，变成一个傻瓜智能甚至是一键启动的软件，很自然地想到了批处理脚本。所以最终各软件的调用都是依赖cmd命令来实现的。</p>
<h3 id="基本流程">基本流程</h3><ol>
<li>为了实现一键启动，先清除tomcat缓存和项目代码以及maven本地缓存的jar文件。</li>
<li>停止grunt和tomcat，防止重复启动。</li>
<li>mvn命令编译发布项目和下载依赖。</li>
<li>通过grunt拷贝生成的项目到tomcat的webapps目录下，这里用批处理也可以实现。</li>
<li>启动tomcat服务器</li>
<li>启动grunt watch，只要sublime修改完代码后，grunt即会自动拷贝到对应的web目录下。</li>
</ol>
<h3 id="源代码（出于保密，部分文件路径略作修改）">源代码（出于保密，部分文件路径略作修改）</h3><p>批处理脚本</p>
<pre><code><span class="built_in">color</span> <span class="number">0</span>B
<span class="comment">rem 设置tomcat安装路径</span>
<span class="keyword">set</span> "tomcat_path=D:\Program Files\apache-tomcat-<span class="number">7</span>.<span class="number">0</span>.<span class="number">56</span>\"
<span class="comment">rem 设置代码路径</span>
<span class="keyword">set</span> "code_path=E:\branches\hd-<span class="number">2</span>.<span class="number">0</span>.<span class="number">0</span>\client\"
<span class="keyword">echo</span> 停止grunt进程
<span class="winutils">taskkill</span> /F /IM node.exe
<span class="keyword">echo</span> 停止tomcat进程
<span class="function">D:
<span class="title">cd</span> %<span class="title">tomcat_path</span>%
<span class="title">call</span> <span class="title">bin</span>\<span class="title">shutdown.bat</span>
<span class="title">echo</span> 清除缓存
<span class="title">rd</span> /<span class="title">s</span>/<span class="title">q</span> <span class="title">work</span>
<span class="title">rd</span> /<span class="title">s</span>/<span class="title">q</span> <span class="title">ap</span>
<span class="title">rd</span> /<span class="title">s</span>/<span class="title">q</span> <span class="title">D</span>:\<span class="title">datas</span>\.<span class="title">m2</span>\<span class="title">repository</span>\<span class="title">com</span>\<span class="title">hd</span>
<span class="title">echo</span> 编译并发布代码
<span class="title">E</span>:
<span class="title">cd</span> %<span class="title">code_path</span>%
<span class="title">call</span> <span class="title">mvn</span> <span class="title">clean</span> <span class="title">package</span>
<span class="title">call</span> <span class="title">grunt</span>
<span class="title">echo</span> 启动<span class="title">tomcat</span>
<span class="title">D</span>:
<span class="title">cd</span> %<span class="title">tomcat_path</span>%
<span class="title">call</span> <span class="title">bin</span>\<span class="title">startup.bat</span>
<span class="title">echo</span> 监听并发布代码
<span class="title">E</span>:
<span class="title">cd</span> %<span class="title">code_path</span>%
<span class="title">grunt</span> <span class="title">watch</span></span>
</code></pre><p>gruntfile.js配置文件，如果大家知道<code>grunt-contrib-copy</code>中，文件名如何使用通配符，请发邮件告诉我，必谢~</p>
<pre><code><span class="comment">/*global module*/</span>
<span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>{
<span class="pi">  'use strict'</span>;
  grunt.initConfig({
    copy: {
      publish: {
        files: [
          { expand: <span class="literal">true</span>, cwd: <span class="string">'target/client-2.0.0.v20150630'</span>, src: [<span class="string">'**'</span>], dest: <span class="string">'D:/Program Files/apache-tomcat-7.0.56/webapps/ap'</span>}
        ]
      },
      main: {
        files: [
          { expand: <span class="literal">true</span>, cwd: <span class="string">'src/main/webapp'</span>, src: [<span class="string">'**'</span>], dest: <span class="string">'D:/Program Files/apache-tomcat-7.0.56/webapps/ap'</span>},
        ]
      }
    },
    watch: {
      view: {
          files: [<span class="string">'src/main/webapp/**'</span>],
          tasks:[<span class="string">'copy:main'</span>],
          options: {livereload:<span class="literal">false</span>}
      }
    }
  });

  grunt.loadNpmTasks(<span class="string">'grunt-contrib-copy'</span>);
  grunt.loadNpmTasks(<span class="string">'grunt-contrib-watch'</span>);

  grunt.registerTask(<span class="string">'default'</span>, [<span class="string">'copy'</span>]);
};
</code></pre><h2 id="总结">总结</h2><p>其实在开发中，最消耗时间的就是鼠标的点击和工具的切换。所以现在流行多显示器开发，让共工具在不同的屏幕上操作，减少了点击任务栏、最小化、最大化这种机械操作。另一方面IDE的出现、快捷键的使用减少鼠标的点击。<br>传统的IDE在开发中往往伴随这一些问题，所以了解各种工具并搭建属于自己的最适用于项目的开发环境，应当是每一位开发者追求高效开发的必经之路。这篇抛砖引玉的文章也正是出于此目的~</p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/07/28/makeIDE/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[nodejs官方权威教程learnyounode分享]]></title>
      <link>http://yalishizhude.github.io/2015/07/25/nodejs%E5%AE%98%E6%96%B9%E6%9D%83%E5%A8%81%E6%95%99%E7%A8%8Blearnyounode%E5%88%86%E4%BA%AB/</link>
      <guid>http://yalishizhude.github.io/2015/07/25/nodejs%E5%AE%98%E6%96%B9%E6%9D%83%E5%A8%81%E6%95%99%E7%A8%8Blearnyounode%E5%88%86%E4%BA%AB/</guid>
      <pubDate>Fri, 24 Jul 2015 17:49:04 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="起因">起因</h2><p>记得去年听朴灵来长沙介绍node.js和他的《深入浅出node.js》的时候（这本书据说销量不错，但是只能作为进阶，新手不太适合），当时只感觉一头雾水：什么是非阻塞事件驱动？node.js和jquery有什么区别？为什么他不用浏览器就可以执行node.js程序？…</p>
<p>怀着强烈的好奇心瞄了一眼，发现这玩意可不得了，可以用js写服务端，一种语言搞定整个前后端，那是多么牛逼的事情。</p>
<p>于是发现了两个比较好的学习网站：<br>]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="起因">起因</h2><p>记得去年听朴灵来长沙介绍node.js和他的《深入浅出node.js》的时候（这本书据说销量不错，但是只能作为进阶，新手不太适合），当时只感觉一头雾水：什么是非阻塞事件驱动？node.js和jquery有什么区别？为什么他不用浏览器就可以执行node.js程序？…</p>
<p>怀着强烈的好奇心瞄了一眼，发现这玩意可不得了，可以用js写服务端，一种语言搞定整个前后端，那是多么牛逼的事情。</p>
<p>于是发现了两个比较好的学习网站：<br><a id="more"></a></p>
<ul>
<li><p><a href="http://nodeschool.io/zh-cn/" target="_blank" rel="external">nodeschool</a><br>最官方最权威的学习教程都在这里，本文分享的教程都是出于此</p>
</li>
<li><p><a href="https://cnodejs.org/" target="_blank" rel="external">CNode</a><br>国内比较活跃的node.js社区，经常各种招聘以及技术分享</p>
</li>
</ul>
<p>nodeschool上的教程比较多，也不全是关于node.js的，我翻译的13篇教程属于learnyounode系列，偏基础和入门。原教程只有题目，不提供代码。校验通过时会给出参考答案，有些代码是我写的，可能未必最优，但确实能解决所提问题。有兴趣的朋友可以自己安装然后验证代码。</p>
<pre><code>npm <span class="keyword">install</span> learnyounode
</code></pre><p>安装完成后执行<code>learnyounode</code>就可以查看题目和验证了。</p>
<h2 id="目录">目录</h2><ol>
<li><a href="http://yalishizhude.github.io/2015/06/16/helloworld4node-js/">helloworld</a></li>
<li><a href="http://yalishizhude.github.io/2015/06/16/cmd-params/">命令行参数</a></li>
<li><a href="http://yalishizhude.github.io/2015/06/17/syncIO/">同步IO读写</a></li>
<li><a href="http://yalishizhude.github.io/2015/06/19/asyncIO/">异步IO读写</a></li>
<li><a href="http://yalishizhude.github.io/2015/06/25/filter/">过滤器</a></li>
<li><a href="http://yalishizhude.github.io/2015/06/25/module/">自定义模块</a></li>
<li><a href="http://yalishizhude.github.io/2015/06/26/http-client/">http客户端</a></li>
<li><a href="http://yalishizhude.github.io/2015/07/04/http-cellecor/">http收集器</a></li>
<li><a href="http://yalishizhude.github.io/2015/07/05/async/">玩转异步</a></li>
<li><a href="http://yalishizhude.github.io/2015/07/06/time-server/">授时服务器</a></li>
<li><a href="http://yalishizhude.github.io/2015/07/10/file-server/">文件服务器</a></li>
<li><a href="http://yalishizhude.github.io/2015/07/11/2uppercase/">大写转换器</a></li>
<li><a href="http://yalishizhude.github.io/2015/07/11/json-api/">JSON API服务器</a></li>
</ol>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/07/25/nodejs%E5%AE%98%E6%96%B9%E6%9D%83%E5%A8%81%E6%95%99%E7%A8%8Blearnyounode%E5%88%86%E4%BA%AB/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[细数在自助终端机上开发混合应用的那些坑（前端）]]></title>
      <link>http://yalishizhude.github.io/2015/07/16/terminal-machine/</link>
      <guid>http://yalishizhude.github.io/2015/07/16/terminal-machine/</guid>
      <pubDate>Thu, 16 Jul 2015 09:13:37 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="需求">需求</h2><h2 id="应客户要求开发部署在自助终端机（可理解为带触摸屏的电脑）上的程序，主要实现身份证识别、订单查询和打印功能。">应客户要求开发部署在自助终端机（可理解为带触摸屏的电脑）上的程序，主要实现身份证识别、订单查询和打印功能。</h2>]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="需求">需求</h2><h2 id="应客户要求开发部署在自助终端机（可理解为带触摸屏的电脑）上的程序，主要实现身份证识别、订单查询和打印功能。">应客户要求开发部署在自助终端机（可理解为带触摸屏的电脑）上的程序，主要实现身份证识别、订单查询和打印功能。</h2><a id="more"></a>
<h2 id="开发环境">开发环境</h2><ul>
<li>windows XP<br>xp没什么好吐槽的，老系统了，还比较稳定。</li>
<li>IE 8<br>不支持css3，不支持媒体查询，没有chrome的实时打印预览（虽然后面也没用到这个功能）。<br>好处就是支持actvieX插件，可以扩展浏览器功能，打破浏览器默认的一些限制。</li>
<li>visual studio<br>开发程序外壳，生成可执行的exe，内嵌浏览器加载html。</li>
</ul>
<hr>
<h2 id="前端技术选型">前端技术选型</h2><p>由于对jquery比较熟悉，ui考虑使用bootstrap一方面是因为其比较火，另外一方面是它跟jquery可以完美结合，觉得坑会少一些，事后证明其实作用并不大，自己写样式也差不多。尤其是bootstrap的栅格布局，在打印的时候就是一个大坑，而且在IE8下媒体查询也失效了，所以对本次开发的贡献度实在是低。。。</p>
<h2 id="问题和解决方案">问题和解决方案</h2><p>终端机开发其实和pc端的web开发大致相同，就界面展现而已，其实更加简单，因为浏览器是固定的，屏幕分辨率是固定的。这次的难点就在于<em>浏览器调用多台打印机同时直接打印</em>。</p>
<ul>
<li><p>启动同步问题<br><em>描述：</em><br>由于是bs架构同时部署在一台机器上，两端同时由应用程序启动，所以正常的程序是tomcat启动完成后，再访问服务器加载页面。<br><em>难度：</em>*<em>
</em>方案：*<br>首先加载一个loading页面，每秒js轮询调用C++提供的接口，如果tomcat已经启动则跳转到首页。</p>
</li>
<li><p>身份证识别功能<br><em>描述：</em><br>一般的查询系统是通过输入编号来进行查询，而更多的取票系统现在采用了更简单的身份证识别方式，如高铁取票机。这次终端机也通过轮询外部接口的方式实现了该功能。<br>同时应当考虑的时候身份证识别系统失效的提供手动输入的情况，由此开发了虚拟键盘，但是开发键盘输入的时候，有两个要点：一是身份证号码校验，另一个就是虚拟键盘的触控效果。<br><em>难度：</em>*<em>**
</em>方案：*<br>身份证校验这个功能很多帖子都讲了算法，不复杂，js代码如下：</p>
</li>
</ul>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 复杂验证！ */</span></span><br><span class="line">var province = '<span class="number">11</span>;<span class="number">12</span>;<span class="number">13</span>;<span class="number">14</span>;<span class="number">15</span>;<span class="number">21</span>;<span class="number">22</span>;<span class="number">23</span>;<span class="number">31</span>;<span class="number">32</span>;<span class="number">33</span>;<span class="number">34</span>;<span class="number">35</span>;<span class="number">36</span>;<span class="number">37</span>;<span class="number">41</span>;<span class="number">42</span>;<span class="number">43</span>;<span class="number">44</span>;<span class="number">45</span>;<span class="number">46</span>;<span class="number">50</span>;<span class="number">51</span>;<span class="number">52</span>;<span class="number">53</span>;<span class="number">54</span>;<span class="number">61</span>;<span class="number">62</span>;<span class="number">63</span>;<span class="number">64</span>;<span class="number">65</span>;<span class="number">71</span>;<span class="number">81</span>;<span class="number">82</span>;<span class="number">91</span>;';</span><br><span class="line">var iSum = <span class="number">0</span>;</span><br><span class="line">var info = '', sBirthday = '';</span><br><span class="line"><span class="keyword">if</span> <span class="params">(!/^\d&#123;<span class="number">17</span>&#125;<span class="params">(\d|x)</span>$/i.test<span class="params">(value)</span>)</span>return <span class="literal">false</span>;</span><br><span class="line">value = value.replace<span class="params">(/x$/i, <span class="string">"a"</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(province.indexOf<span class="params">(value.substr<span class="params">(<span class="number">0</span>, <span class="number">2</span>)</span> + ';')</span> === -<span class="number">1</span>)</span>return <span class="literal">false</span>;<span class="comment">//"Error:非法地区";</span></span><br><span class="line">sBirthday = value.substr<span class="params">(<span class="number">6</span>, <span class="number">4</span>)</span> + <span class="string">"/"</span> + Number<span class="params">(value.substr<span class="params">(<span class="number">10</span>, <span class="number">2</span>)</span>)</span> + <span class="string">"/"</span> + Number<span class="params">(value.substr<span class="params">(<span class="number">12</span>, <span class="number">2</span>)</span>)</span>;</span><br><span class="line">var d = new Date<span class="params">(sBirthday)</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(sBirthday !== <span class="params">(d.getFullYear<span class="params">()</span> + <span class="string">"/"</span> + <span class="params">(d.getMonth<span class="params">()</span> + <span class="number">1</span>)</span> + <span class="string">"/"</span> + d.getDate<span class="params">()</span>)</span>)</span>return <span class="literal">false</span>;<span class="comment">//"Error:非法生日";</span></span><br><span class="line"><span class="keyword">for</span> <span class="params">(var i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; i--)</span> iSum += <span class="params">(Math.pow<span class="params">(<span class="number">2</span>, i)</span> % <span class="number">11</span>)</span> <span class="built_in">*</span> parseInt<span class="params">(value.charAt<span class="params">(<span class="number">17</span> - i)</span>, <span class="number">11</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(iSum % <span class="number">11</span> !== <span class="number">1</span>)</span>return <span class="literal">false</span>;<span class="comment">//"Error:非法证号";</span></span><br><span class="line">return <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>触控效果比较难搞，之前考虑用a标签的active样式来做点击效果，但是由于IE8的双击判断间隔有问题，具体问题参见我的另一篇<a href="http://yalishizhude.github.io/2015/07/01/click-or-dbclick/">博客</a>。后来用dblclick双击事件来调用click事件，pc端上没有问题，部署到终端机的时候还是显示迟钝，效果不理想。改用mousedown和mouseup效果也不好。有更好的方法请告知我~</p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/07/16/terminal-machine/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[npm安装模块报错：msb4025的解决方法]]></title>
      <link>http://yalishizhude.github.io/2015/07/15/msb4025/</link>
      <guid>http://yalishizhude.github.io/2015/07/15/msb4025/</guid>
      <pubDate>Tue, 14 Jul 2015 16:13:34 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="问题">问题</h2><p>在win8.1下安装npm模块的时候控制台报错<strong>error MSB4025: 未能加载项目文件，给定编码中的字符无效</strong><br>网上查找的结果是说和中文用户名有关（以后文件夹、用户名请尽量不要用中文），造成编码转换失败。<br>]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="问题">问题</h2><p>在win8.1下安装npm模块的时候控制台报错<strong>error MSB4025: 未能加载项目文件，给定编码中的字符无效</strong><br>网上查找的结果是说和中文用户名有关（以后文件夹、用户名请尽量不要用中文），造成编码转换失败。<br><a id="more"></a></p>
<h2 id="原因">原因</h2><p>windows下的中文默认用的是GBK编码，而vcxproj文件默认的编码方式是utf-8。node的gyp工具，并没有很好的处理多语言编码的问题。这样导致生成的vcxproj文件是ANSI编码，内部的中文字符是GBK编码，等到调用VS2013编译模块时，就会导致VS2013无法正确使用vcxproj文件，导致编译安装失败。</p>
<h2 id="解决">解决</h2><p>在node.js的安装目录下，找到<strong>node_modules\npm\node_modules\node-gyp\gyp\pylib\gyp\easy_xml.py</strong>这个文件，找到<code># It has changed, write it</code>这一行。<br>修改前：</p>
<pre><code># It <span class="built_in">has</span> changed, <span class="keyword">write</span> it
  <span class="keyword">if</span> existing != xml_strin<span class="variable">g:</span>
    <span class="keyword">f</span> = <span class="keyword">open</span>(path, <span class="string">'w'</span> ,<span class="string">'utf_8_sig'</span>)
    <span class="keyword">f</span>.<span class="keyword">write</span>(xml_string)
    <span class="keyword">f</span>.<span class="keyword">close</span>()
</code></pre><p>修改一下，加个编码的判断：</p>
<pre><code># It has changed, write it
  if existing != xml_string:
    if path.endswith('vcxproj'):
      #<span class="operator"><span class="keyword">use</span> utf_8 <span class="keyword">encoding</span> <span class="keyword">to</span> generate vcxproj <span class="keyword">file</span>
      <span class="keyword">f</span> = codecs.<span class="keyword">open</span>(<span class="keyword">path</span>, <span class="string">'w'</span>, <span class="string">'utf_8_sig'</span>)
      #<span class="keyword">convert</span> GBK <span class="keyword">string</span> <span class="keyword">to</span> <span class="keyword">Unicode</span> <span class="keyword">string</span> <span class="keyword">to</span> ensure the later utf_8 <span class="keyword">encoding</span>
      <span class="keyword">f</span>.write(xml_string.<span class="keyword">decode</span>(<span class="string">'gbk'</span>))
    <span class="keyword">else</span>:
      <span class="keyword">f</span> = <span class="keyword">open</span>(<span class="keyword">path</span>, <span class="string">'w'</span>)
      <span class="keyword">f</span>.write(xml_string)
    <span class="keyword">f</span>.<span class="keyword">close</span>()</span>
</code></pre><p>然后在文件开头加上<br><code>import codecs</code><br><strong>注意一下，python文件的一个恶心之处就是必须遵守严格的缩进，这里的换行缩进都是2个空格</strong><br>修改完成后保存，再次执行安装命令应该就可以成功了~</p>
<p><a href="http://my.oschina.net/tearlight/blog/279797" target="_blank" rel="external">参考文章</a></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/07/15/msb4025/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[node.js基础教程(13)：JSON API服务器]]></title>
      <link>http://yalishizhude.github.io/2015/07/11/json-api/</link>
      <guid>http://yalishizhude.github.io/2015/07/11/json-api/</guid>
      <pubDate>Fri, 10 Jul 2015 16:06:49 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="要求">要求</h2><p>编写一个 HTTP 服务器，每当接收到一个路径为 ‘/api/parsetime’ 的 GET 请求的时候，响应一些 JSON 数据。我们期望请求会包含一个查询参数（query string），key 是 “iso ，值是 ISO 格式的时间。</p>
<p>如:</p>
<pre><code>/api/parsetime?iso=<span class="number">2013</span>-<span class="number">08</span>-<span class="number">10</span>T12:<span class="number">10</span>:<span class="number">15.474</span>Z
</code></pre><p>所响应的 JSON 应该只包含三个属性：’hour’，’minute’ 和 ‘second’。例如：</p>
<pre><code>{
  "<span class="attribute">hour</span>": <span class="value"><span class="number">14</span></span>,
  "<span class="attribute">minute</span>": <span class="value"><span class="number">23</span></span>,
  "<span class="attribute">second</span>": <span class="value"><span class="number">15</span>
</span>}
</code></pre><p>然后增再加一个接口，路径为 ‘/api/unixtime’，它可以接收相同的查询参数（query strng），但是它的返回会包含一个属性：’unixtime’，相应值是一个 UNIX 时间戳。例如:</p>
<pre><code>{ "<span class="attribute">unixtime</span>": <span class="value"><span class="number">1376136615474</span> </span>}
</code></pre><p>服务器需要监听第一个命令行参数所指定的端口。</p>
<hr>]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="要求">要求</h2><p>编写一个 HTTP 服务器，每当接收到一个路径为 ‘/api/parsetime’ 的 GET 请求的时候，响应一些 JSON 数据。我们期望请求会包含一个查询参数（query string），key 是 “iso ，值是 ISO 格式的时间。</p>
<p>如:</p>
<pre><code>/api/parsetime?iso=<span class="number">2013</span>-<span class="number">08</span>-<span class="number">10</span>T12:<span class="number">10</span>:<span class="number">15.474</span>Z
</code></pre><p>所响应的 JSON 应该只包含三个属性：’hour’，’minute’ 和 ‘second’。例如：</p>
<pre><code>{
  "<span class="attribute">hour</span>": <span class="value"><span class="number">14</span></span>,
  "<span class="attribute">minute</span>": <span class="value"><span class="number">23</span></span>,
  "<span class="attribute">second</span>": <span class="value"><span class="number">15</span>
</span>}
</code></pre><p>然后增再加一个接口，路径为 ‘/api/unixtime’，它可以接收相同的查询参数（query strng），但是它的返回会包含一个属性：’unixtime’，相应值是一个 UNIX 时间戳。例如:</p>
<pre><code>{ "<span class="attribute">unixtime</span>": <span class="value"><span class="number">1376136615474</span> </span>}
</code></pre><p>服务器需要监听第一个命令行参数所指定的端口。</p>
<hr>
<a id="more"></a>
<h2 id="提示">提示</h2><p>HTTP 服务器的 request 对象含有一个 url 属性，你可以通过它来决定具体需要走哪一条”路由”。</p>
<p>可以使用 Node 的核心模块 ‘url’ 来处理 URL 和 查询参数（query string）。<code>url.parse(request.url, true)</code> 方法会处理 request.url，它返回的对象中包含了一些很有帮助的属性，方便方便你处理 querystring。</p>
<p>举个例子，可以在命令行窗口输入以下命令试试：</p>
<pre><code><span class="variable">$ </span>node -pe <span class="string">"require('url').parse('/test?q=1', true)"</span>
</code></pre><p>服务器的响应应该是一个 JSON 字符串的形式。请查看 JSON.stringify() 来获取更多信息。</p>
<p>为了争做 Web 世界的好公民，正确地为响应设置 Content-Type 属性：</p>
<pre><code>res.<span class="function"><span class="title">writeHead</span><span class="params">(<span class="number">200</span>, { <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span> })</span></span>
</code></pre><p>JavaScript 的 Date 可以将日期以 ISO 的格式展现出来，如：<code>new Date().toISOString()</code>。并且，如果把一个字符串传给 Date的构造函数，它也可以帮你将字符串处理成日期类型。另外，Date#getTime() 放个应该也会很有用。</p>
<p><a href="https://nodejs.org/api/url.html" target="_blank" rel="external">url模块API文档</a></p>
<hr>
<h2 id="代码">代码</h2><pre><code><span class="built_in">var</span> http = <span class="keyword">require</span>(<span class="string">'http'</span>);
<span class="built_in">var</span> url = <span class="keyword">require</span>(<span class="string">'url'</span>);
<span class="built_in">var</span> querystring = <span class="keyword">require</span>(<span class="string">'querystring'</span>);
http<span class="built_in">.</span>createServer(function(req,res){
    <span class="built_in">var</span> obj = url<span class="built_in">.</span>parse(req<span class="built_in">.</span>url);
    <span class="built_in">var</span> param = querystring<span class="built_in">.</span>parse(obj<span class="built_in">.</span>query);
    res<span class="built_in">.</span>writeHead(<span class="number">200</span>, { <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span> });
    <span class="keyword">if</span>(<span class="string">"/api/parsetime"</span>===obj<span class="built_in">.</span>pathname){
        <span class="built_in">var</span> <span class="built_in">date</span> = <span class="literal">new</span> <span class="built_in">Date</span>(param<span class="built_in">.</span>iso);
        <span class="built_in">var</span> retObj = {
            hour: <span class="built_in">date</span><span class="built_in">.</span>getHours(),
            minute: <span class="built_in">date</span><span class="built_in">.</span>getMinutes(),
            second: <span class="built_in">date</span><span class="built_in">.</span>getSeconds()
        };
        res<span class="built_in">.</span>end(JSON<span class="built_in">.</span>stringify(retObj));
    }
    <span class="keyword">if</span>(<span class="string">'/api/unixtime'</span>===obj<span class="built_in">.</span>pathname){
        <span class="built_in">var</span> <span class="built_in">date</span> = <span class="literal">new</span> <span class="built_in">Date</span>(param<span class="built_in">.</span>iso);
        <span class="built_in">var</span> retObj = {unixtime: <span class="built_in">date</span><span class="built_in">.</span>getTime()};
        res<span class="built_in">.</span>end(JSON<span class="built_in">.</span>stringify(retObj));
    }
})<span class="built_in">.</span>listen(process<span class="built_in">.</span>argv<span class="preprocessor">[</span><span class="number">2</span><span class="preprocessor">]</span><span class="markup">);</span>
</code></pre>]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/07/11/json-api/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[node.js基础教程(12)：大写转换器]]></title>
      <link>http://yalishizhude.github.io/2015/07/11/2uppercase/</link>
      <guid>http://yalishizhude.github.io/2015/07/11/2uppercase/</guid>
      <pubDate>Fri, 10 Jul 2015 16:00:51 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="要求">要求</h2><p>编写一个 HTTP 服务器，它只接受 POST 形式的请求，并且将 POST 请求主体（body）所带的字符转换成大写形式，然后返回给客户端。</p>
<p>服务器需要监听由第一个命令行参数所指定的端口。</p>
<hr>]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="要求">要求</h2><p>编写一个 HTTP 服务器，它只接受 POST 形式的请求，并且将 POST 请求主体（body）所带的字符转换成大写形式，然后返回给客户端。</p>
<p>服务器需要监听由第一个命令行参数所指定的端口。</p>
<hr>
<a id="more"></a>
<h2 id="提示">提示</h2><p>这里将不限制你使用 stream 处理 request 和 response 对象，并且这将更为简单。</p>
<p>在 npm 中，有很多不同的模块可以用来在 stream 传输过程中 “转换” stream 中的数据。对于本次练习来说，through2-map 这个模块有一个比较简单的 API 可以使用。</p>
<p>through2-map 允许你创建一个 transform stream，它仅需要一个函数就能完成「接收一个数据块，处理完后返回这个数据块」的功能 ，它的工作模式类似于 Array#map()，但是是针对 stream 的：</p>
<pre><code>var <span class="keyword">map</span> = <span class="keyword">require</span>(<span class="string">'through2-map'</span>)
inStream.<span class="keyword">pipe</span>(<span class="keyword">map</span>(function (chunk) {
  <span class="keyword">return</span> chunk.toString().<span class="keyword">split</span>(<span class="string">''</span>).<span class="keyword">reverse</span>().<span class="keyword">join</span>(<span class="string">''</span>)
})).<span class="keyword">pipe</span>(outStream)
</code></pre><p>在上面的例子中，从 inStream 传进来的数据会被转换成字符串（如果它不是字符串的话），并且字符会反转处理，然后传入 outStream。所以，我们这里是做了一个字符串反转器！记住！尽管，数据块（chunk）的大小是由上游（up-stream）所决定的，但是还是可以在这之上对传进来的数据做一点小小的处理的。</p>
<p>要安装 through2-map，输入:</p>
<pre><code>$ npm <span class="operator"><span class="keyword">install</span> through2-<span class="keyword">map</span></span>
</code></pre><p><a href="https://github.com/brycebaril/through2-map" target="_blank" rel="external">through2-map模块API文档</a></p>
<hr>
<h2 id="代码">代码</h2><p>方法一：<br>`<br>var http = require(‘http’);</p>
<p>http.createServer(function(req,res){<br>    var postData = ‘’;<br>    req.addListener(“data”, function (postDataChunk) {<br>        if(req.method===’POST’){<br>            postData += postDataChunk;<br>        }<br>    });<br>    req.addListener(“end”, function(){<br>        if(req.method===’POST’){<br>            res.end(postData.toUpperCase(),’utf8’);<br>        }<br>    });<br>}).listen(process.argv[2]);<br>`</p>
<p>方法二：<br>`<br>var http = require(‘http’)<br>var map = require(‘through2-map’)</p>
<p>var server = http.createServer(function (req, res) {<br>  if (req.method != ‘POST’)<br>    return res.end(‘send me a POST\n’)</p>
<p>  req.pipe(map(function (chunk) {<br>    return chunk.toString().toUpperCase()<br>  })).pipe(res)<br>})</p>
<p>server.listen(Number(process.argv[2]))<br>`</p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/07/11/2uppercase/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[node.js基础教程(11)：文件服务器]]></title>
      <link>http://yalishizhude.github.io/2015/07/10/file-server/</link>
      <guid>http://yalishizhude.github.io/2015/07/10/file-server/</guid>
      <pubDate>Fri, 10 Jul 2015 15:44:39 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="要求">要求</h2><p>编写一个 HTTP 文件 服务器，它用于将每次所请求的文件返回给客户端。</p>
<p>服务器需要监听所提供的第一个命令行参数所制定的端口。</p>
<p>同时，第二个会提供给程序的参数则是所需要响应的文本文件的位置。在这一题中必须使用 <code>fs.createReadStream()</code> 方法以 stream 的形式作出请求相应。</p>
<hr>]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="要求">要求</h2><p>编写一个 HTTP 文件 服务器，它用于将每次所请求的文件返回给客户端。</p>
<p>服务器需要监听所提供的第一个命令行参数所制定的端口。</p>
<p>同时，第二个会提供给程序的参数则是所需要响应的文本文件的位置。在这一题中必须使用 <code>fs.createReadStream()</code> 方法以 stream 的形式作出请求相应。</p>
<hr>
<a id="more"></a>
<h2 id="提示">提示</h2><p>由于我们需要创建的是一个 HTTP 服务而不是普通的 TCP 服务，因此，应该使用 http 这个 Node 核心模块。它和 net 模块类似，http 模块拥有一个叫做 <code>http.createServer()</code> 的方法，所不同的是它所创建的服务器是用 HTTP 协议进行通信的。</p>
<p><code>http.createServer()</code>接收一个回调函数作为参数，回调函数会在你的服务器每一次进行连接的时候执行，这个回调函数有以下的特征：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">callback</span> <span class="params">(request, response)</span> </span>{ <span class="comment">/* ... */</span> }
</code></pre><p>在这里，这两个参数是代表一个 HTTP 请求以及相应的响应的两个对象。request 用来从请求中获取一些的属性，例如请求头和查询字符（query-string)，而 response 会发送数据给客户端，包括响应头部和响应主体。</p>
<p>request 和 response 也都是 Node stream！这意味着，如果需要的话，可以使用流式处理（streaming）所抽象的那些方法来实现发送和接收数据。</p>
<p><code>http.createServer()</code> 会返回一个 HTTP 服务器的实例。这里需要调用 server.listen(portNumber) 方法去监听一个特定的端口。</p>
<p>一个典型的 Node HTTP 服务器将会是这个样子：</p>
<pre><code><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)
<span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>{
  <span class="comment">// 处理请求的逻辑...</span>
})
server.listen(<span class="number">8000</span>)
</code></pre><p><a href="https://nodejs.org/api/http.html" target="_blank" rel="external">http模块API文档</a></p>
<p><a href="https://nodejs.org/api/fs.html" target="_blank" rel="external">fs模块API文档</a></p>
<p>fs 这个核心模块也含有一些用来处理文件的流式（stream） API。可以使用 fs.createReadStream() 方法来为命令行参数指定的文件创建一个 stream。这个方法会返回一个 stream 对象，该对象可以使用类似 src.pipe(dst) 的语法把数据从 src流传输(pipe) 到 dst 流中。通过这种形式，可以轻松地把一个文件系统的 stream 和一个 HTTP 响应的 stream 连接起来。</p>
<hr>
<h2 id="代码">代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123; <span class="string">'content-type'</span>: <span class="string">'text/plain'</span> &#125;)</span><br><span class="line"></span><br><span class="line">  fs.createReadStream(process.argv[<span class="number">3</span>]).pipe(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="built_in">Number</span>(process.argv[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/07/10/file-server/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[node.js基础教程(10)：授时服务器]]></title>
      <link>http://yalishizhude.github.io/2015/07/06/time-server/</link>
      <guid>http://yalishizhude.github.io/2015/07/06/time-server/</guid>
      <pubDate>Mon, 06 Jul 2015 15:11:30 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="要求">要求</h2><p>编写一个 TCP 时间服务器</p>
<p>服务器监听一个端口，以获取一些TCP连接，这个端口会经由第一个命令行参数传递给程序。针对每一个 TCP 连接，都必须写入当前的日期和24小时制的时间，如下格式：</p>
<pre><code><span class="string">"YYYY-MM-DD hh:mm"</span>
</code></pre><p>然后紧接着是一个换行符。</p>
<p>月份、日、小时和分钟必须用零填充成为固定的两位数：</p>
<pre><code><span class="string">"2013-07-06 17:42"</span>
</code></pre><hr>]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="要求">要求</h2><p>编写一个 TCP 时间服务器</p>
<p>服务器监听一个端口，以获取一些TCP连接，这个端口会经由第一个命令行参数传递给程序。针对每一个 TCP 连接，都必须写入当前的日期和24小时制的时间，如下格式：</p>
<pre><code><span class="string">"YYYY-MM-DD hh:mm"</span>
</code></pre><p>然后紧接着是一个换行符。</p>
<p>月份、日、小时和分钟必须用零填充成为固定的两位数：</p>
<pre><code><span class="string">"2013-07-06 17:42"</span>
</code></pre><hr>
<a id="more"></a>
<h2 id="提示">提示</h2><p>这次练习中，将会创建一个 TCP 服务器。这里将不会涉及到任何 HTTP 的事情，因此只需使用 net 这个 Node 核心模块就可以了。它包含了所有的基础网络功能。<br>net 模块拥有一个名叫 net.createServer() 的方法，它会接收一个回调函数。和 Node 中其他的回调函数不同，createServer() 所用的回调函数将会被调用多次。服务器每收到一个 TCP 连接，都会调用一次这个回调函数。这个回调函数有如下特征：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">callback</span> <span class="params">(socket)</span> </span>{ <span class="comment">/* ... */</span> }
</code></pre><p>net.createServer() 也会返回一个 TCP 服务器的实例，必须调用 server.listen(portNumber) 来让服务器开始监听一个特定的端口。</p>
<p>一个典型的 Node TCP 服务器将会如下所示：</p>
<pre><code><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>)
<span class="keyword">var</span> server = net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>{
  <span class="comment">// socket 处理逻辑</span>
})
server.listen(<span class="number">8000</span>)
</code></pre><p><a href="https://nodejs.org/api/net.html" target="_blank" rel="external">net模块API文档</a></p>
<p>记住，请一定监听由第一个命令行参数指定的端口。</p>
<p>socket 对象包含了很多关于各个连接的信息（meta-data），但是它也同时是一个 Node 双工流（duplex Stream），所以，它即可以读，也可以写。对这个练习来说，只需要对socket 写数据和关闭它就可以了。</p>
<p>使用  socket.write(data) 可以写数据到 socket 中，用  socket.end() 可以关闭一个 socket。另外， .end() 方法也可以接收一个数据对象作为参数，因此，可简单地使用 socket.end(data) 来完成写数据和关闭两个操作。</p>
<hr>
<h2 id="代码">代码</h2><p>方法一：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line">net.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> date= <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    socket.end(date.toLocaleDateString());</span><br><span class="line">&#125;).listen(process.argv[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure></p>
<p>方法二：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">zeroFill</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (i &lt; <span class="number">10</span> ? <span class="string">'0'</span> : <span class="string">''</span>) + i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">now</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  <span class="keyword">return</span> d.getFullYear() + <span class="string">'-'</span></span><br><span class="line">    + zeroFill(d.getMonth() + <span class="number">1</span>) + <span class="string">'-'</span></span><br><span class="line">    + zeroFill(d.getDate()) + <span class="string">' '</span></span><br><span class="line">    + zeroFill(d.getHours()) + <span class="string">':'</span></span><br><span class="line">    + zeroFill(d.getMinutes())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  socket.end(now() + <span class="string">'\n'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="built_in">Number</span>(process.argv[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/07/06/time-server/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[impressjs扩展：显示页数/进度条]]></title>
      <link>http://yalishizhude.github.io/2015/07/06/apis4impressjs/</link>
      <guid>http://yalishizhude.github.io/2015/07/06/apis4impressjs/</guid>
      <pubDate>Mon, 06 Jul 2015 13:45:41 GMT</pubDate>
      <description>
      <![CDATA[<img src="/2015/07/06/apis4impressjs/demo.jpg" alt="demo.jpg" title="">
<h2 id="什么是impressjs？">什么是impressjs？</h2><p>impressjs就是为html文件添加css3动画，变成类似ppt效果的工具，它支持图片和文字（flash动画可能支持），跨平台，用impressjs做ppt，你再也不用担心pc上有没有安装powerpoint了。重要的是它学习门槛也很低。大家只要下载项目，打开index.html修改内容即可（不过作者并不提倡这样做）。大家有兴趣可以查看项目主页和demo。</p>
<p><a href="https://github.com/impress/impress.js">github主页</a></p>
<p><a href="http://bartaz.github.io/impress.js/">demo页面</a><br>]]>
      
      </description>
      <content:encoded><![CDATA[<img src="/2015/07/06/apis4impressjs/demo.jpg" alt="demo.jpg" title="">
<h2 id="什么是impressjs？">什么是impressjs？</h2><p>impressjs就是为html文件添加css3动画，变成类似ppt效果的工具，它支持图片和文字（flash动画可能支持），跨平台，用impressjs做ppt，你再也不用担心pc上有没有安装powerpoint了。重要的是它学习门槛也很低。大家只要下载项目，打开index.html修改内容即可（不过作者并不提倡这样做）。大家有兴趣可以查看项目主页和demo。</p>
<p><a href="https://github.com/impress/impress.js" target="_blank" rel="external">github主页</a></p>
<p><a href="http://bartaz.github.io/impress.js/" target="_blank" rel="external">demo页面</a><br><a id="more"></a></p>
<h2 id="impressjs_API开发">impressjs API开发</h2><h3 id="起因">起因</h3><p>之前由于公司需要我做个ppt介绍一下CDN，但是身为一个前端工程师，尤其是反感word的工程师，于是找到了这款高逼格的做演示文件的利器——impressjs。加了css3特效的html当然是华丽丽的，但是用起来之后发现和通常用的ppt还是有些区别，那就是缺少了当前页数的显示，再加上灵光一闪，觉得加个进度条也不错，于是中午抽空就写了一下~</p>
<h3 id="js代码分析">js代码分析</h3><h4 id="添加当前页">添加当前页</h4><p>impressjs的每一页都有一个step样式，总览页也不列外。而且每页都有一个id，如果id不存在的话则默认为’step-x’，x为序号。利用这个特性就可以实现所要的功能。</p>
<p>新增一个header元素，通过修改元素宽度来显示当前进度。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> showProgress = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> head = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">document</span>.getElementsByTagName(<span class="string">'header'</span>)[<span class="number">0</span>])&#123;</span><br><span class="line">        head = <span class="built_in">document</span>.getElementByTagsName(<span class="string">'header'</span>)[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head = <span class="built_in">document</span>.createElement(<span class="string">'header'</span>);</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> percent = getCurrent()*<span class="number">100.00</span>/getTotal();</span><br><span class="line">    <span class="built_in">console</span>.log(percent);</span><br><span class="line">    head.style.width = percent + <span class="string">'%'</span>;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">"hashchange"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> percent = getCurrent()*<span class="number">100.00</span>/getTotal();</span><br><span class="line">        head.style.width = percent + <span class="string">'%'</span>;</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>新增一个footer元素来显示当前页和总页数，同时监听url地址来的hash值变化来修改当前页序号<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> showPage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foot = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">document</span>.getElementsByTagName(<span class="string">'footer'</span>)[<span class="number">0</span>])&#123;</span><br><span class="line">        foot = <span class="built_in">document</span>.getElementByTagsName(<span class="string">'foot'</span>)[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        foot = <span class="built_in">document</span>.createElement(<span class="string">'footer'</span>);</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(foot);</span><br><span class="line">    &#125;</span><br><span class="line">    foot.innerText = getCurrent()&gt;<span class="number">0</span>?(getCurrent()+<span class="string">'/'</span>+getTotal()):<span class="string">''</span>;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">"hashchange"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        foot.innerText = getCurrent()&gt;<span class="number">0</span>?(getCurrent()+<span class="string">'/'</span>+getTotal()):<span class="string">''</span>;</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="暴露接口">暴露接口</h4><p>impressjs默认开放了4个接口<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">```&#10;return (roots[ &#34;impress-root-&#34; + rootId ] = &#123;&#10;    init: init,&#10;    goto: goto,&#10;    next: next,&#10;    prev: prev,&#10;    showPage: showPage,&#10;    showProgress: showProgress&#10;&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="css样式分析">css样式分析</h3><p>底部显示页数，用固定定位<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">footer</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> fixed</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">bottom</span>:<span class="value"> <span class="number">150px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">30px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">25px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> <span class="number">900</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>顶部显示进度条，用固定定位，通过改变百分比宽度来表示进度<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">header</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> fixed</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">10px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#3879d9</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="html的调用示例">html的调用示例</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">impress<span class="comment">()</span>.showPage<span class="comment">()</span>;</span><br><span class="line">impress<span class="comment">()</span>.showProgress<span class="comment">()</span>;</span><br></pre></td></tr></table></figure>
<h3 id="大结局">大结局</h3><p>预知后事如何，可以<a href="https://github.com/impress/impress.js/pull/487" target="_blank" rel="external">点击</a>查看我提交的版本以及作者的回复</p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/07/06/apis4impressjs/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[node.js基础教程(9)：玩转异步]]></title>
      <link>http://yalishizhude.github.io/2015/07/05/async/</link>
      <guid>http://yalishizhude.github.io/2015/07/05/async/</guid>
      <pubDate>Sun, 05 Jul 2015 08:12:58 GMT</pubDate>
      <description>
      <![CDATA[<p>##要求</p>
<p>这次的问题和之前的问题（HTTP 收集器）很像，也是需要使用到 http.get() 方法。然而，这一次，将有三个 URL 作为前三个命令行参数提供。</p>
<p>需要收集每一个 URL 所返回的完整内容，然后将它们在终端（标准输出stdout）打印出来。这次不需要打印出这些内容的长度，仅仅是内容本身即可（字符串形式）；每个 URL对应的内容为一行。重点是必须按照这些 URL 在参数列表中的顺序将相应的内容排列打印出来才算完成。</p>
<hr>]]>
      
      </description>
      <content:encoded><![CDATA[<p>##要求</p>
<p>这次的问题和之前的问题（HTTP 收集器）很像，也是需要使用到 http.get() 方法。然而，这一次，将有三个 URL 作为前三个命令行参数提供。</p>
<p>需要收集每一个 URL 所返回的完整内容，然后将它们在终端（标准输出stdout）打印出来。这次不需要打印出这些内容的长度，仅仅是内容本身即可（字符串形式）；每个 URL对应的内容为一行。重点是必须按照这些 URL 在参数列表中的顺序将相应的内容排列打印出来才算完成。</p>
<hr>
<a id="more"></a>
<h2 id="提示">提示</h2><p>不要期待这三台服务器能好好的一起玩耍！他们可能不会把完整的响应的结果按照希望的顺序返回，所以不能天真地只是在收到响应后直接打印出来，因为这样做的话，他们的顺序可能会乱掉。</p>
<p>需要去跟踪到底有多少 URL 完整地返回了他们的内容，然后用一个队列存储起来。一旦拥有了所有的结果，才可以把它们打印到终端。</p>
<p>对回调进行计数是处理 Node 中的异步的基础。比起自己去做，去依赖一个第三方的模块或者库会更方便，比如 <a href="http://npm.im/async" target="_blank" rel="external">async</a> 或者 <a href="http://npm.im/after" target="_blank" rel="external">after</a>。不过，在本次练习中，应该首先尝试自己去解决，而不是依赖外部的模块。</p>
<p>##代码</p>
<ul>
<li><p>方法一</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = require('http');</span><br><span class="line"><span class="keyword">var</span> <span class="literal">result</span> = ['','',''];</span><br><span class="line"><span class="keyword">var</span> isEnd = [<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>];</span><br><span class="line"></span><br><span class="line">   http.get(process.argv[<span class="number">2</span>], function(res)&#123;</span><br><span class="line">       res.setEncoding('utf8');</span><br><span class="line">       res.on('data', function(data)&#123;</span><br><span class="line">           <span class="literal">result</span>[<span class="number">0</span>] += data;</span><br><span class="line">       &#125;);</span><br><span class="line">       res.on('<span class="keyword">end</span>', function(data)&#123;</span><br><span class="line">           isEnd[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">if</span>(isEnd[<span class="number">0</span>]&amp;&amp;isEnd[<span class="number">1</span>]&amp;&amp;isEnd[<span class="number">2</span>])&#123;</span><br><span class="line">               console.log(<span class="literal">result</span>[<span class="number">0</span>]);</span><br><span class="line">               console.log(<span class="literal">result</span>[<span class="number">1</span>]);</span><br><span class="line">               console.log(<span class="literal">result</span>[<span class="number">2</span>]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">   http.get(process.argv[<span class="number">3</span>], function(res)&#123;</span><br><span class="line">       res.setEncoding('utf8');</span><br><span class="line">       res.on('data', function(data)&#123;</span><br><span class="line">           <span class="literal">result</span>[<span class="number">1</span>] += data;</span><br><span class="line">       &#125;);</span><br><span class="line">       res.on('<span class="keyword">end</span>', function(data)&#123;</span><br><span class="line">           isEnd[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">if</span>(isEnd[<span class="number">0</span>]&amp;&amp;isEnd[<span class="number">1</span>]&amp;&amp;isEnd[<span class="number">2</span>])&#123;</span><br><span class="line">               console.log(<span class="literal">result</span>[<span class="number">0</span>]);</span><br><span class="line">               console.log(<span class="literal">result</span>[<span class="number">1</span>]);</span><br><span class="line">               console.log(<span class="literal">result</span>[<span class="number">2</span>]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">   http.get(process.argv[<span class="number">4</span>], function(res)&#123;</span><br><span class="line">       res.setEncoding('utf8');</span><br><span class="line">       res.on('data', function(data)&#123;</span><br><span class="line">           <span class="literal">result</span>[<span class="number">2</span>] += data;</span><br><span class="line">       &#125;);</span><br><span class="line">       res.on('<span class="keyword">end</span>', function(data)&#123;</span><br><span class="line">           isEnd[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">if</span>(isEnd[<span class="number">0</span>]&amp;&amp;isEnd[<span class="number">1</span>]&amp;&amp;isEnd[<span class="number">2</span>])&#123;</span><br><span class="line">               console.log(<span class="literal">result</span>[<span class="number">0</span>]);</span><br><span class="line">               console.log(<span class="literal">result</span>[<span class="number">1</span>]);</span><br><span class="line">               console.log(<span class="literal">result</span>[<span class="number">2</span>]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line">  <span class="keyword">var</span> bl = <span class="built_in">require</span>(<span class="string">'bl'</span>)</span><br><span class="line">  <span class="keyword">var</span> results = []</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">printResults</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">      <span class="built_in">console</span>.log(results[i])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">httpGet</span> (<span class="params">index</span>) </span>&#123;</span><br><span class="line">    http.get(process.argv[<span class="number">2</span> + index], <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">      response.pipe(bl(<span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">console</span>.error(err)</span><br><span class="line"></span><br><span class="line">        results[index] = data.toString()</span><br><span class="line">        count++</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">3</span>)</span><br><span class="line">	printResults()</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">httpGet(i)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/07/05/async/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[node.js基础教程(8)：http收集器]]></title>
      <link>http://yalishizhude.github.io/2015/07/04/http-cellecor/</link>
      <guid>http://yalishizhude.github.io/2015/07/04/http-cellecor/</guid>
      <pubDate>Sat, 04 Jul 2015 14:58:30 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="要求">要求</h2><p>编写一个程序，发起一个 HTTP GET 请求，请求的 URL 为所提供的命令行参数的第一个。收集所有服务器所返回的数据（不仅仅包括 “data” 事件）然后在终端（标准输出 std out）用两行打印出来。</p>
<p>所打印的内容，第一行应该是一个整数，用来表示收到的字符串内容长度，第二行则是服务器返回的完整的字符串结果。</p>
<hr>]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="要求">要求</h2><p>编写一个程序，发起一个 HTTP GET 请求，请求的 URL 为所提供的命令行参数的第一个。收集所有服务器所返回的数据（不仅仅包括 “data” 事件）然后在终端（标准输出 std out）用两行打印出来。</p>
<p>所打印的内容，第一行应该是一个整数，用来表示收到的字符串内容长度，第二行则是服务器返回的完整的字符串结果。</p>
<hr>
<a id="more"></a>
<h2 id="提示">提示</h2><p>有两种实现方法：</p>
<p>1) 可以把所有 “data” 事件所得的结果收集起来，暂存并追加在一起，而不是在收到后立刻打印出来。通过监听 “end” 事件，可以确定 stream 是否完成传输，如果传输结束了，就可以将收集到的结果打印出来了。</p>
<p>2) 使用一个第三方模块，来简化从 stream 中收集数据的繁琐步骤。这里有两个不同的模块都提供了一些有用的 API 来解决这个问题（似乎还有好多另外的模块可以选哦！）：bl (Buffer list) 或者 concat-stream，来选一个吧！</p>
<p>  <a href="http://npm.im/bl" target="_blank" rel="external">bl模块API文档</a><br>  <a href="http://npm.im/concat-stream" target="_blank" rel="external">concat-stream模块API文档</a></p>
<p>要安装一个 Node 模块，需用到 Node 的包管理工具 npm，输入：</p>
<pre><code>$ npm <span class="keyword">install</span> bl
</code></pre><p>这样，相应的模块的最新版本便会被下载到当前目录下一个名为 node_modules 的子目录中 。任何在这个子目录中的模块都可以简单地使用 require 语法来将模块载入到程序中 ，并且不需要加 ./ 这样的路径前缀，如下所示：</p>
<pre><code><span class="tag">var</span> bl = <span class="function"><span class="title">require</span><span class="params">(<span class="string">'bl'</span>)</span></span>
</code></pre><p>可以把一个 stream pipe 到 bl 或 concat-stream 中去，它们会收集数据。一旦 stream 传输结束，一个回调函数会被执行，并且，这个回调函数会带上所收集的数据：</p>
<pre><code>response.pipe(bl(<span class="function"><span class="keyword">function</span> <span class="params">(err, data)</span> </span>{ <span class="comment">/* ... */</span> }))
<span class="comment">// 或</span>
response.pipe(concatStream(<span class="function"><span class="keyword">function</span> <span class="params">(data)</span> </span>{ <span class="comment">/* ... */</span> }))
</code></pre><p>要注意的是可能需要使用 data.toString() 来把 Buffer 转换为字符串。</p>
<hr>
<h2 id="代码">代码</h2><ul>
<li><p>方法一</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">var</span> http = require('http');</span><br><span class="line"></span><br><span class="line">   http.get(process.argv[<span class="number">2</span>], function(res)&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="literal">result</span> = '';</span><br><span class="line">    res.setEncoding('utf8');</span><br><span class="line">    res.on('data', function(data)&#123;</span><br><span class="line">        <span class="literal">result</span> += data;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.on('<span class="keyword">end</span>', function(data)&#123;</span><br><span class="line">        console.log(<span class="literal">result</span>.length);</span><br><span class="line">        console.log(<span class="literal">result</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> bl = <span class="built_in">require</span>(<span class="string">'bl'</span>)</span><br><span class="line"></span><br><span class="line">http.get(process.argv[<span class="number">2</span>], <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  response.pipe(bl(<span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.error(err)</span><br><span class="line">    data = data.toString()</span><br><span class="line">    <span class="built_in">console</span>.log(data.length)</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/07/04/http-cellecor/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[cdn简介]]></title>
      <link>http://yalishizhude.github.io/2015/07/04/cdn/</link>
      <guid>http://yalishizhude.github.io/2015/07/04/cdn/</guid>
      <pubDate>Sat, 04 Jul 2015 12:13:41 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="什么是CDN">什么是CDN</h2><p>Content Delivery Network 内容分发网络<br>通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络”边缘”（节点服务器），使用户可以就近取得所需的内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度<br>]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="什么是CDN">什么是CDN</h2><p>Content Delivery Network 内容分发网络<br>通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络”边缘”（节点服务器），使用户可以就近取得所需的内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度<br><a id="more"></a></p>
<h2 id="CDN的架构">CDN的架构</h2><p>CDN网络分为中心和边缘（节点）</p>
<h3 id="中心">中心</h3><p>CDN网管中心和DNS重定向解析中心，负责全局负载均衡，设备系统安装在管理中心机房</p>
<h3 id="边缘">边缘</h3><p>主要指异地节点，CDN分发的载体，主要由Cache和负载均衡器等组成</p>
<h2 id="CDN工作原理">CDN工作原理</h2><p>用户访问了使用CDN服务的资源时,DNS域名服务器通过CNAME方式将最终域名请求重定向到CDN系统中的智能DNS负载均衡系统.智能DNS负载均衡系统通过一组预先定义好的策略(如内容类型、地理区域、网络负载状况等),将当时能够最快响应用户的节点地址提供给用户</p>
<h2 id="CDN工作流程">CDN工作流程</h2><img src="/2015/07/04/cdn/topo.png" alt="topo.png" title="">
<h2 id="适用场景">适用场景</h2><ul>
<li>访问量大的网站，被访问内容更新周期比较长的网站：在线视频、游戏、图片、音频、社交、电商、下载站、政府企业门户等</li>
<li>一定量级的静态资源访问，包括html,js,css,apk,mp3,flv等所有静态资源</li>
</ul>
<h2 id="计费方式">计费方式</h2><p>按流量计费和按日峰值计费<br><img src="/2015/07/04/cdn/peak.jpg" alt="peak.jpg" title=""><br><img src="/2015/07/04/cdn/flow.jpg" alt="flow.jpg" title=""></p>
<h2 id="CDN缓存">CDN缓存</h2><ol>
<li>CDN缓存时间<br>CDN的cache软件遵循http(https)协议，缓存时间由文件header头的Cache-Control或Expires来控制。</li>
<li>如何刷新缓存<br>阿里云：手动刷新目录和文件。腾讯：设置缓存时间自动刷新。</li>
</ol>
<p><a href="https://github.com/yalishizhude/CDN-representation" target="_blank" rel="external">ppt下载</a></p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/07/04/cdn/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[双击单击傻傻分不清——IE8下点击事件的小坑]]></title>
      <link>http://yalishizhude.github.io/2015/07/01/click-or-dbclick/</link>
      <guid>http://yalishizhude.github.io/2015/07/01/click-or-dbclick/</guid>
      <pubDate>Wed, 01 Jul 2015 04:06:21 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="场景">场景</h2><p>项目需求，做一个web页面上的虚拟小键盘来输入用户身份证号码。</p>
<h2 id="实现">实现</h2><p>jquery + bootstrap</p>
<p>通过table来布局，通过行列合并的形式做出“键盘”的风格，这里使用a标签的active伪类来制作点击效果。<br>绑定onclick事件，当按钮被点击时将值显示在input输入框中以及一些其他逻辑，如：删除、取消。<br>整个逻辑还是比较简单自然。<br><strong> 可这时问题就来了 </strong><br>]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="场景">场景</h2><p>项目需求，做一个web页面上的虚拟小键盘来输入用户身份证号码。</p>
<h2 id="实现">实现</h2><p>jquery + bootstrap</p>
<p>通过table来布局，通过行列合并的形式做出“键盘”的风格，这里使用a标签的active伪类来制作点击效果。<br>绑定onclick事件，当按钮被点击时将值显示在input输入框中以及一些其他逻辑，如：删除、取消。<br>整个逻辑还是比较简单自然。<br><strong> 可这时问题就来了 </strong><br><a id="more"></a></p>
<h2 id="问题">问题</h2><p>连续点击某一个小键盘按钮的时候，有些点击并没有生效。出现点击效果时有时无的情况。</p>
<h2 id="解决">解决</h2><ol>
<li>首先猜测可能是事件发生了阻塞。采用逐步注释代码的方法马上验证了这个猜想是错的。</li>
<li>可能是a标签或者伪类样式有问题。使用button等其他标签样式同样不行。</li>
<li>点击事件调用机制可能有问题。用了3种尝试方法：绑定document的click事件；html中写onclick事件；return false组织回调。统统失败。</li>
<li>最后猜测应该是浏览器问题，果不其然，换了IE10，chrome都是正常的。</li>
<li>仔细前后想了一下，点击事件浏览器间歇性捕获不到，这种情况很可能是被识别为其它事件捕获了，比如<strong> 双击 </strong>。绑定dblclick事件之后发现果然如此。</li>
</ol>
<h2 id="结论">结论</h2><p>IE8以下的浏览器判断双击事件的时间比其它浏览器要长，连续点击有可能会被当做双击捕获，所以会出现间歇性失灵的情况。</p>
<h2 id="代码">代码</h2><h3 id="html">html</h3><pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"keys"</span> <span class="attribute">hidden</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"alert alert-danger text-center"</span> <span class="attribute">role</span>=<span class="value">"alert"</span>&gt;</span>请输入正确的身份证号码<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;<span class="title">table</span> <span class="attribute">cellspacing</span>=<span class="value">"0"</span> <span class="attribute">cellpadding</span>=<span class="value">"0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">tbody</span>&gt;</span>
      <span class="tag">&lt;<span class="title">tr</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span> <span class="attribute">colspan</span>=<span class="value">"4"</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">class</span>=<span class="value">"show"</span> <span class="attribute">maxlength</span>=<span class="value">"18"</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">td</span>&gt;</span>
      <span class="tag">&lt;/<span class="title">tr</span>&gt;</span>
      <span class="tag">&lt;<span class="title">tr</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"num"</span>&gt;</span>7<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"num"</span>&gt;</span>8<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"num"</span>&gt;</span>9<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span> <span class="attribute">rowspan</span>=<span class="value">"2"</span>&gt;</span><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"btn-cancel"</span>&gt;</span>取<span class="tag">&lt;<span class="title">br</span>&gt;</span>消<span class="tag">&lt;/<span class="title">div</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span>
      <span class="tag">&lt;/<span class="title">tr</span>&gt;</span>
      <span class="tag">&lt;<span class="title">tr</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"num"</span>&gt;</span>4<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"num"</span>&gt;</span>5<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"num"</span>&gt;</span>6<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span>
      <span class="tag">&lt;/<span class="title">tr</span>&gt;</span>
      <span class="tag">&lt;<span class="title">tr</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"num"</span>&gt;</span>1<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"num"</span>&gt;</span>2<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"num"</span>&gt;</span>3<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span> <span class="attribute">rowspan</span>=<span class="value">"2"</span>&gt;</span><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"btn-ok"</span>&gt;</span>确<span class="tag">&lt;<span class="title">br</span>&gt;</span>认<span class="tag">&lt;/<span class="title">div</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span>
      <span class="tag">&lt;/<span class="title">tr</span>&gt;</span>
      <span class="tag">&lt;<span class="title">tr</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"num"</span>&gt;</span>X<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"num"</span>&gt;</span>0<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"backspace"</span>&gt;</span>&amp;larr;<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span>
      <span class="tag">&lt;/<span class="title">tr</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">tbody</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">table</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</code></pre><h3 id="js">js</h3><pre><code>$(<span class="string">"#keyboard"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
  <span class="keyword">if</span>($(<span class="string">'.keys'</span>).is(<span class="string">":hidden"</span>)){
    $(<span class="string">'.show'</span>).val(<span class="string">''</span>);
    $(<span class="string">'.keys'</span>).show();
  }
});
$(<span class="string">'.num'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
  $(<span class="keyword">this</span>).addClass(<span class="string">'active'</span>);
  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    $(<span class="string">'.active'</span>).removeClass(<span class="string">'active'</span>);
  }, <span class="number">100</span>);
  <span class="keyword">if</span>($(<span class="string">'.show'</span>).val().length&gt;=<span class="built_in">parseInt</span>($(<span class="string">'.show'</span>).attr(<span class="string">'maxlength'</span>))) <span class="keyword">return</span>;
  <span class="keyword">var</span> value = $(<span class="string">'.show'</span>).val();
  value += $(<span class="keyword">this</span>).text();
  $(<span class="string">'.show'</span>).focus().val(value);
  resetCount();
}).dblclick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
  $(<span class="keyword">this</span>).click();
});
$(<span class="string">".backspace"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
  <span class="keyword">var</span> value = $(<span class="string">'.show'</span>).val().substring(<span class="number">0</span>, $(<span class="string">'.show'</span>).val().length-<span class="number">1</span>);
  $(<span class="string">'.show'</span>).val(value);
  $(<span class="keyword">this</span>).addClass(<span class="string">'active'</span>);
  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    $(<span class="string">'.active'</span>).removeClass(<span class="string">'active'</span>);
  }, <span class="number">100</span>);
}).dblclick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
  $(<span class="keyword">this</span>).click();
});
$(<span class="string">".btn-cancel"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
  $(<span class="string">'.show'</span>).val(<span class="string">''</span>);
  $(<span class="string">'.keys'</span>).hide();
});
$(<span class="string">".btn-ok"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
  <span class="keyword">if</span>(validate($(<span class="string">'.show'</span>).val())) {
    location.href=<span class="string">"list.html?id="</span>+$(<span class="string">'.show'</span>).val();
  } <span class="keyword">else</span> {
    $(<span class="string">".keys&gt;.alert"</span>).show();
    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{$(<span class="string">".keys&gt;.alert"</span>).hide()},<span class="number">3000</span>);
  }
});
</code></pre><h3 id="css">css</h3><pre><code><span class="class">.keys</span><span class="rules">{
  <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
  <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;
  <span class="rule"><span class="attribute">margin</span>:<span class="value"> -<span class="number">520px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span></span>;
}</span>
<span class="class">.keys</span>&gt;<span class="tag">table</span><span class="rules">{
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">500px</span></span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">400px</span></span></span>;
  <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#dfdfdf</span></span></span>;
  <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>;
  <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#000</span></span></span>;
}</span>
<span class="class">.keys</span>&gt;<span class="tag">table</span> <span class="tag">td</span><span class="rules">{
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">25%</span></span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">20%</span></span></span>;
}</span>
<span class="class">.keys</span>&gt;<span class="tag">table</span> <span class="class">.num</span><span class="rules">{
  <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">125px</span></span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">80px</span></span></span>;
  <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">80px</span></span></span>;
  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#eee</span></span></span>;
  <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">30px</span></span></span>;
  <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> <span class="number">900</span></span></span>;
  <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#000</span></span></span>;
  <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;
  <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#ccc</span></span></span>;
  <span class="rule"><span class="attribute">text-decoration</span>:<span class="value"> none</span></span>;
}</span>
<span class="class">.keys</span>&gt;<span class="tag">table</span> <span class="tag">a</span><span class="class">.active</span><span class="rules">{
  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#666</span></span></span>;
}</span>
<span class="class">.keys</span>&gt;<span class="tag">table</span> <span class="class">.backspace</span><span class="rules">{
  <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;
  <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">125px</span></span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">80px</span></span></span>;
  <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">80px</span></span></span>;
  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#eee</span></span></span>;
  <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">30px</span></span></span>;
  <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> <span class="number">900</span></span></span>;
  <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#ccc</span></span></span>;
  <span class="rule"><span class="attribute">text-decoration</span>:<span class="value"> none</span></span>;
  <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#000</span></span></span>;
}</span>
<span class="class">.keys</span>&gt;<span class="tag">table</span> <span class="class">.btn-cancel</span><span class="rules">{
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">125px</span></span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">160px</span></span></span>;
  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#eee</span></span></span>;
  <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
  <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">35px</span></span></span>;
  <span class="rule"><span class="attribute">padding-top</span>:<span class="value"> <span class="number">25px</span></span></span>;
  <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#ccc</span></span></span>;
}</span>
<span class="class">.keys</span>&gt;<span class="tag">table</span> <span class="class">.btn-ok</span><span class="rules">{
  <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">125px</span></span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">160px</span></span></span>;
  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#ccc</span></span></span>;
  <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">35px</span></span></span>;
  <span class="rule"><span class="attribute">padding-top</span>:<span class="value"> <span class="number">25px</span></span></span>;
  <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#ccc</span></span></span>;
}</span>
<span class="class">.keys</span>&gt;<span class="tag">table</span> <span class="class">.show</span><span class="rules">{
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100%</span></span></span>;
  <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">40px</span></span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;
  <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span></span></span>;
  <span class="rule"><span class="attribute">border-width</span>:<span class="value"> <span class="number">0</span></span></span>;
  <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span></span></span>;
}</span>
<span class="class">.keys</span>&gt;<span class="class">.alert</span><span class="rules">{
  <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
  <span class="rule"><span class="attribute">margin</span>:<span class="value"> -<span class="number">60px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">312px</span></span></span>;
  <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">30px</span></span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">60px</span></span></span>;
  <span class="rule"><span class="attribute">display</span>:<span class="value"> none</span></span>;
}</span>
</code></pre><h2 id="效果">效果</h2><img src="/2015/07/01/click-or-dbclick/keyboard.jpg" alt="keyboard.jpg" title="">
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/07/01/click-or-dbclick/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[node.js基础教程(7)：http客户端]]></title>
      <link>http://yalishizhude.github.io/2015/06/26/http-client/</link>
      <guid>http://yalishizhude.github.io/2015/06/26/http-client/</guid>
      <pubDate>Fri, 26 Jun 2015 15:54:08 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="要求">要求</h2><p>编写一个程序来发起一个 HTTP GET 请求，所请求的 URL 为命令行参数的第一个。然后将每一个 “data” 事件所得的数据，以字符串形式在终端（标准输出 stdout）的新的一行打印出来。</p>
<hr>]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="要求">要求</h2><p>编写一个程序来发起一个 HTTP GET 请求，所请求的 URL 为命令行参数的第一个。然后将每一个 “data” 事件所得的数据，以字符串形式在终端（标准输出 stdout）的新的一行打印出来。</p>
<hr>
<a id="more"></a>
<h2 id="提示">提示</h2><p>完成这个练习，需要使用 Node.js 核心模块之一：http。</p>
<p><a href="file://D:\Work\Nodejs\node_modules\learnyounode\node_apido\http.html" target="_blank" rel="external">http模块API文档</a></p>
<p><code>http.get()</code> 方法是用来发起简单的 GET 请求的快捷方式，使用这个方法可以一定程度简化程序。<code>http.get()</code>的第一个参数是GET 的URL，第二个参数则是回调函数。</p>
<p>与其他的回调函数不同，这个回调函数有如下这些特征：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">callback</span> <span class="params">(response)</span> </span>{ <span class="comment">/* ... */</span> }
</code></pre><p>response 对象是一个 Node 的 Stream 类型的对象，可以将 Node Stream当做一个会触发一些事件的对象，其中我们通常所需要关心的事件有三个： “data”，”error” 以及 “en”。可以像这样来监听一个事件：</p>
<pre><code>response.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> </span>{ <span class="comment">/* ... */</span> })
</code></pre><p>‘data’ 事件会在每个数据块到达并已经可以对其进行一些处理的时候被触发。数据块的大小将取决于数据源。</p>
<p>从 <code>http.get()</code> 所获得的 response 对象/Stream 还有一个 setEncoding() 的方法。如果调用这个方法，并为其指定参数为 utf8，那么 data 事件中会传递字符串，而不是标准的 Node Buffer 对象，这样，也不用再手动将 Buffer 对象转换成字符串了。</p>
<hr>
<h2 id="代码">代码</h2><pre><code><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);

http.get(process.argv[<span class="number">2</span>], <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>{
  response.setEncoding(<span class="string">'utf8'</span>);
  response.on(<span class="string">'data'</span>, <span class="built_in">console</span>.log);
  response.on(<span class="string">'error'</span>, <span class="built_in">console</span>.error);
});
</code></pre>]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/06/26/http-client/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[node.js基础教程(6)：自定义模块]]></title>
      <link>http://yalishizhude.github.io/2015/06/25/module/</link>
      <guid>http://yalishizhude.github.io/2015/06/25/module/</guid>
      <pubDate>Thu, 25 Jun 2015 14:15:49 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="要求">要求</h2><p>这个问题和前面一个一样，但是这次需要使用模块。将需要创建两个文件来解决这个问题。</p>
<p>编写一个程序来打印出所给文件目录的所含文件的列表，并且以特定的文件名后缀来过滤这个列表。这次将会提供两个参数，第一个参数是要列举的目录，第二个参数是要过滤的文件扩展名。在终端中打印出过滤出来的文件列表（一个文件一行）。此外，必须使用异步 I/O。</p>
<p>需要编写一个模块文件去做大部分的事情。这个模块必须导出（export）一个函数，这个函数将接收三个参数：目录名、文件扩展名、回调函数，并按此顺序传递。文件扩展名必须和传递给程序的扩展名字符串一模一样。也就是说，请不要把它转成正则表达式或者加上”.”前缀或者做其他的处理，而是直接传到模块中去，在模块中，可以做一些处理来使过滤器能正常工作。</p>
<p>这个回调函数必须以 Node 编程中惯用的约定形式（err,data）去调用。这个约定指明了，除非发生了错误，否则所传进去给回调函数的第一个参数将会是 null，第二个参数才会是数据。在本题中，这个数据将会是过滤出来的文件列表，并且是以数组的形式。如果接收到了一个错误，如：来自<code>fs.readdir()</code> 的错误，则必须将这个错误作为第一个，也是唯一的参数传递给回调函数，并执行回调函数。</p>
<p>绝对不能直接在模块文件中把结果打印到终端中，只能在原始程序文件中编写打印结果的代码。</p>
<p>当程序接收到一些错误的时候，请简单的捕获它们，并且在终端中打印出相关的信息</p>
<p>这里有四则规定，模块必须遵守：</p>
<ul>
<li>导出一个函数，这个函数能准确接收上述的参数。</li>
<li>当有错误发生，或者有数据的时候，准确调用回调函数。</li>
<li>不要改变其他的任何东西，比如全局变量或者 stdout。</li>
<li>处理所有可能发生的错误，并把它们传递给回调函数。</li>
</ul>
<p>遵循一些约定的好处是，模块可以被任何其他也遵守这些约定的人所使用。</p>
<hr>]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="要求">要求</h2><p>这个问题和前面一个一样，但是这次需要使用模块。将需要创建两个文件来解决这个问题。</p>
<p>编写一个程序来打印出所给文件目录的所含文件的列表，并且以特定的文件名后缀来过滤这个列表。这次将会提供两个参数，第一个参数是要列举的目录，第二个参数是要过滤的文件扩展名。在终端中打印出过滤出来的文件列表（一个文件一行）。此外，必须使用异步 I/O。</p>
<p>需要编写一个模块文件去做大部分的事情。这个模块必须导出（export）一个函数，这个函数将接收三个参数：目录名、文件扩展名、回调函数，并按此顺序传递。文件扩展名必须和传递给程序的扩展名字符串一模一样。也就是说，请不要把它转成正则表达式或者加上”.”前缀或者做其他的处理，而是直接传到模块中去，在模块中，可以做一些处理来使过滤器能正常工作。</p>
<p>这个回调函数必须以 Node 编程中惯用的约定形式（err,data）去调用。这个约定指明了，除非发生了错误，否则所传进去给回调函数的第一个参数将会是 null，第二个参数才会是数据。在本题中，这个数据将会是过滤出来的文件列表，并且是以数组的形式。如果接收到了一个错误，如：来自<code>fs.readdir()</code> 的错误，则必须将这个错误作为第一个，也是唯一的参数传递给回调函数，并执行回调函数。</p>
<p>绝对不能直接在模块文件中把结果打印到终端中，只能在原始程序文件中编写打印结果的代码。</p>
<p>当程序接收到一些错误的时候，请简单的捕获它们，并且在终端中打印出相关的信息</p>
<p>这里有四则规定，模块必须遵守：</p>
<ul>
<li>导出一个函数，这个函数能准确接收上述的参数。</li>
<li>当有错误发生，或者有数据的时候，准确调用回调函数。</li>
<li>不要改变其他的任何东西，比如全局变量或者 stdout。</li>
<li>处理所有可能发生的错误，并把它们传递给回调函数。</li>
</ul>
<p>遵循一些约定的好处是，模块可以被任何其他也遵守这些约定的人所使用。</p>
<hr>
<a id="more"></a>
<h2 id="提示">提示</h2><p>通过创建一个仅包含目录读取和文件过滤相关的函数的文件来建立一个新的模块。要使模块导出（export）单一函数（single function），可以将函数赋值给<code>module.exports</code>对象：</p>
<pre><code><span class="function"><span class="keyword">module</span>.<span class="title">exports</span> =</span> <span class="function"><span class="keyword">function</span> <span class="params">(args)</span> {</span> <span class="comment">/* ... */</span> }
</code></pre><p>或者也可以使用命名函数，然后把函数名赋值给<code>module.exports</code>。</p>
<p>要在原来的程序中使用新的模块，请用 require() 载入模块，这和载入 fs 模块时候用 <code>require(&#39;fs&#39;)</code>一样，唯一的区别在于本地模块需要加上 ‘./‘ 这个相对路径前缀。所以，如果模块文件名字是 mymodule.js，那么需要像这样写：</p>
<pre><code><span class="tag">var</span> mymodule = <span class="function"><span class="title">require</span><span class="params">(<span class="string">'./mymodule.js'</span>)</span></span>
</code></pre><p>‘.js’ 这个文件扩展名通常是可以省略的。</p>
<p>现在，mymodule 这个变量就指向了模块中  module.exports了，因为刚导出了一个单一的函数，所以现在所声明的变量 mymodule 就是那个模块所导出的函数了，就可以直接调用它了！</p>
<p>同样，请记住，尽早捕获错误，并且在回调中返回：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">bar</span> <span class="params">(callback)</span> </span>{
  foo(<span class="function"><span class="keyword">function</span> <span class="params">(err, data)</span> </span>{
    <span class="keyword">if</span> (err)
      <span class="keyword">return</span> <span class="keyword">callback</span>(err) <span class="comment">// 尽早返回错误</span>
    <span class="comment">// ... 没有错误，处理 `data`</span>
    <span class="comment">// 一切顺利，传递 null 作为 callback 的第一个参数</span>
    <span class="keyword">callback</span>(<span class="literal">null</span>, data)
  })
}
</code></pre><hr>
<h2 id="代码">代码</h2><h3 id="solution-js:">solution.js:</h3><pre><code><span class="keyword">var</span> filterFn = require('./solution_filter.js')
<span class="keyword">var</span> <span class="keyword">dir</span> = process.argv[2]
<span class="keyword">var</span> filterStr = process.argv[3]
filterFn(<span class="keyword">dir</span>, filterStr, function (<span class="keyword">err</span>, <span class="keyword">list</span>) {
  <span class="keyword">if</span> (<span class="keyword">err</span>)
    <span class="keyword">return</span> console.<span class="keyword">error</span>('There was <span class="keyword">an</span> <span class="keyword">error</span>:', <span class="keyword">err</span>)
  <span class="keyword">list</span>.<span class="keyword">forEach</span>(function (<span class="keyword">file</span>) {
    console.<span class="literal">log</span>(<span class="keyword">file</span>)
  })
})
</code></pre><h3 id="solution_filter-js:">solution_filter.js:</h3><pre><code><span class="keyword">var</span> fs = <span class="keyword">require</span>(<span class="string">'fs'</span>)
<span class="keyword">var</span> path = <span class="keyword">require</span>(<span class="string">'path'</span>)
module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(dir, filterStr, callback)</span> </span>{
  fs.readdir(dir, <span class="function"><span class="keyword">function</span> <span class="params">(err, list)</span> </span>{
    <span class="keyword">if</span> (err)
      <span class="keyword">return</span> callback(err)
    <span class="keyword">list</span> = <span class="keyword">list</span>.filter(<span class="function"><span class="keyword">function</span> <span class="params">(file)</span> </span>{
      <span class="keyword">return</span> path.extname(file) === <span class="string">'.'</span> + filterStr
    })
    callback(<span class="keyword">null</span>, <span class="keyword">list</span>)
  })
}
</code></pre>]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/06/25/module/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[node.js基础教程(5)：过滤器]]></title>
      <link>http://yalishizhude.github.io/2015/06/25/filter/</link>
      <guid>http://yalishizhude.github.io/2015/06/25/filter/</guid>
      <pubDate>Wed, 24 Jun 2015 16:38:38 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="要求">要求</h2><p>编写一个程序来打印出指定目录下的文件列表，并且以特定的文件名扩展名来过滤这个列表。命令行提供两个参数提，第一个是所给的文件目录路径（如：path/to/dir），第二个参数则是需要过滤出来的文件的扩展名。</p>
<p>举个例子：如果第二个参数是 txt，那么需要过滤出那些扩展名为 .txt的文件。</p>
<p>注意，第二个参数将不会带有开头的”.”。</p>
<p>需要在终端中打印出这个被过滤出来的列表，每一行一个文件。另外，必须使用异步的I/O 操作。</p>
<hr>]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="要求">要求</h2><p>编写一个程序来打印出指定目录下的文件列表，并且以特定的文件名扩展名来过滤这个列表。命令行提供两个参数提，第一个是所给的文件目录路径（如：path/to/dir），第二个参数则是需要过滤出来的文件的扩展名。</p>
<p>举个例子：如果第二个参数是 txt，那么需要过滤出那些扩展名为 .txt的文件。</p>
<p>注意，第二个参数将不会带有开头的”.”。</p>
<p>需要在终端中打印出这个被过滤出来的列表，每一行一个文件。另外，必须使用异步的I/O 操作。</p>
<hr>
<a id="more"></a>
<h2 id="提示">提示</h2><p>fs.readdir() 方法接收两个参数：第一个是一个路径，第二个则是回调函数，这个回调函数会有如下特征：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">callback</span> <span class="params">(err, list)</span> </span>{ <span class="comment">/* ... */</span> }
</code></pre><p>这里的 list 是一个数组，它所包含的元素是每个文件的文件名（字符串形式）。</p>
<p><a href="https://nodejs.org/api/fs.html" target="_blank" rel="external">fs模块API文档</a></p>
<p>node 自带的 path 模块也很有用，特别是它那个 extname 方法。</p>
<p><a href="https://nodejs.org/api/path.html" target="_blank" rel="external">path模块API文档</a></p>
<hr>
<h2 id="代码">代码</h2><pre><code><span class="keyword">var</span> fs = <span class="keyword">require</span>(<span class="string">'fs'</span>)
<span class="keyword">var</span> path = <span class="keyword">require</span>(<span class="string">'path'</span>)

fs.readdir(process.argv[<span class="number">2</span>], <span class="function"><span class="keyword">function</span> <span class="params">(err, list)</span> </span>{
  <span class="keyword">list</span>.<span class="keyword">forEach</span>(<span class="function"><span class="keyword">function</span> <span class="params">(file)</span> </span>{
    <span class="keyword">if</span> (path.extname(file) === <span class="string">'.'</span> + process.argv[<span class="number">3</span>])
      console.log(file)
  })
})
</code></pre>]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/06/25/filter/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[node.js基础教程(4)：异步IO读写]]></title>
      <link>http://yalishizhude.github.io/2015/06/19/asyncIO/</link>
      <guid>http://yalishizhude.github.io/2015/06/19/asyncIO/</guid>
      <pubDate>Fri, 19 Jun 2015 11:40:27 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="要求">要求</h2><p>编写一个程序，执行一个异步的对文件系统的操作：读取一个文件，并且在终端（标准输出stdout）打印出这个文件中的内容的行数。类似于执行 cat file | wc -l 这个命令。 所要读取的文件的完整路径会在命令行第一个参数提供。</p>
<hr>]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="要求">要求</h2><p>编写一个程序，执行一个异步的对文件系统的操作：读取一个文件，并且在终端（标准输出stdout）打印出这个文件中的内容的行数。类似于执行 cat file | wc -l 这个命令。 所要读取的文件的完整路径会在命令行第一个参数提供。</p>
<hr>
<a id="more"></a>
<h2 id="提示">提示</h2><p>解决这个问题将需要用到Node.js最鲜明的风格的方式：异步。</p>
<p>‘’’fs.readFile()’’’方法可以满足这个需求，这需要从传入的<a href="https://github.com/maxogden/art-of-node#callbacks" target="_blank" rel="external">回调函数</a>中去收集数据（这些数据会作为第二参数传递给回调函数），而不是使用方法的返回值。</p>
<p>记住，Node.js 回调函数都有像如下所示的特征：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">callback</span> <span class="params">(err, data)</span> </span>{ <span class="comment">/* ... */</span> }
</code></pre><p>可以通过检查第一个参数的真假值来判断是否有错误发生。如果没有错误发生，第二个参数将获取到一个Buffer对象。和 readFileSync() 一样，可以传入 ‘utf8 ‘ 作为它的第二个参数，然后把回调函数作为第三个参数，这样，得到的将会是一个字符而不是 Buffer。</p>
<p><a href="https://nodejs.org/api/fs.html" target="_blank" rel="external">fs模块API文档</a></p>
<hr>
<h2 id="代码">代码</h2><pre><code><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);
fs.readFile(process.argv[<span class="number">2</span>], <span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>{
    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;
    <span class="built_in">console</span>.log(data.toString().split(<span class="string">'\n'</span>).length-<span class="number">1</span>);
});
</code></pre>]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/06/19/asyncIO/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[node.js基础教程(3)：同步IO读写]]></title>
      <link>http://yalishizhude.github.io/2015/06/17/syncIO/</link>
      <guid>http://yalishizhude.github.io/2015/06/17/syncIO/</guid>
      <pubDate>Wed, 17 Jun 2015 14:33:01 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="要求">要求</h2><p>编写一个程序，执行一个同步的文件系统操作，读取一个文件，并且在终端（标准输出stdout）打印出这个文件中的内容的行数。类似于执行 <code>cat file | wc -l</code> 这个命令。</p>
<p>所要读取的文件的完整路径会在命令行第一个参数提供。</p>
<hr>]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="要求">要求</h2><p>编写一个程序，执行一个同步的文件系统操作，读取一个文件，并且在终端（标准输出stdout）打印出这个文件中的内容的行数。类似于执行 <code>cat file | wc -l</code> 这个命令。</p>
<p>所要读取的文件的完整路径会在命令行第一个参数提供。</p>
<hr>
<a id="more"></a>
<h2 id="提示">提示</h2><p>要执行一个对文件系统的操作，将会用到 fs 这个 Node 核心模块。要加载这类核心模块或者其他的”全局”模块，可以用下面的方式引入：</p>
<pre><code><span class="tag">var</span> fs = <span class="function"><span class="title">require</span><span class="params">(<span class="string">'fs'</span>)</span></span>
</code></pre><p>这样就可以通过 fs 这个变量来访问整个 fs 模块了。</p>
<p>在 fs 中，所有的同步（或者阻塞）的操作文件系统的方法名都会以 ‘Sync’ 结尾。要读取一个文件，将需要使用  <code>fs.readFileSync(&#39;/path/to/file&#39;)</code> 方法。这个方法会返回一个包含文件完整内容的 Buffer 对象。</p>
<p>(fs模块API文档)[<a href="https://nodejs.org/api/fs.html" target="_blank" rel="external">https://nodejs.org/api/fs.html</a>]</p>
<p>Buffer 对象是 Node 用来高效处理数据的方式，无论该数据是 ascii 还是二进制文件，或者其他的格式。Buffer 可以很容易地通过调用 <code>toString()</code> 方法转换为字符串。如：</p>
<pre><code><span class="tag">var</span> s <span class="tag">tr</span> = buf.<span class="function"><span class="title">toString</span><span class="params">()</span></span>。
</code></pre><p>(Buffer模块API文档)[<a href="https://nodejs.org/api/buffer.html" target="_blank" rel="external">https://nodejs.org/api/buffer.html</a>]</p>
<p>简单地计算行数方法，可以使用.split() 分割成子字符串数组，’\n’可以作为分隔符。</p>
<hr>
<h2 id="代码">代码</h2><pre><code>var fs = require(<span class="string">'fs'</span>);
var <span class="keyword">res</span> = fs.readFileSync(process.<span class="built_in">argv</span>[<span class="number">2</span>], <span class="string">'utf-8'</span>);
console.<span class="built_in">log</span>(<span class="keyword">res</span>.<span class="built_in">split</span>(<span class="string">'\n'</span>).length-<span class="number">1</span>);
</code></pre>]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/06/17/syncIO/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[node.js基础教程(2)：命令行参数]]></title>
      <link>http://yalishizhude.github.io/2015/06/16/cmd-params/</link>
      <guid>http://yalishizhude.github.io/2015/06/16/cmd-params/</guid>
      <pubDate>Tue, 16 Jun 2015 15:58:29 GMT</pubDate>
      <description>
      <![CDATA[<p>##要求<br>编写一个简单的程序，使其能接收一个或者多个命令行参数，并且在终端（标准输出 stdout）中打印出这些参数的总和。</p>
<hr>]]>
      
      </description>
      <content:encoded><![CDATA[<p>##要求<br>编写一个简单的程序，使其能接收一个或者多个命令行参数，并且在终端（标准输出 stdout）中打印出这些参数的总和。</p>
<hr>
<a id="more"></a>
<h2 id="提示">提示</h2><p>可以通过 process 这个全局对象来获取命令行中的参数。process 对象 拥有一个名为 argv 的属性，该属性是一个数组，数组中包含了整条命令的所有部分。首先，请先编写一个包含如下带简易代码的程序来熟悉一下：</p>
<pre><code>console.<span class="function"><span class="title">log</span><span class="params">(process.argv)</span></span>
</code></pre><p>通过执行命令 node program.js 并在后面多加几个参数，来运行我们的程序，比如：</p>
<pre><code>$ node program.js <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>
</code></pre><p>这样，就会得到这样一个数组：</p>
<pre><code>[ 'node', '/path/to/your/program.js', '<span class="number">1</span>', '<span class="number">2</span>', '<span class="number">3</span>' ]
</code></pre><p>需要考虑的问题是，如何去循环遍历这些代表数字的参数，从而得到他们的总和。process.argv数组的第一个元素永远都会是node，并且第二个参数总是指向程序的路径，所以，应该从第三个元素（index 是 2）开始，依次累加，直到数组末尾。</p>
<p>需要注意的是，所有 process.argv 中的数组的元素都是字符串类型的，因此，需要将它们强制转换成数字。可以通过加上 + 前缀，或者将其传给 Number() 来解决。例如： +process.argv[2] 或者 Number(process.argv[2])。</p>
<p>##代码</p>
<pre><code><span class="keyword">var</span> <span class="literal">result</span> = <span class="number">0</span>

<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">2</span>; i &lt; process.argv.length; i++)
    <span class="literal">result</span> += <span class="type">Number</span>(process.argv[i])

console.log(<span class="literal">result</span>)
</code></pre>]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/06/16/cmd-params/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[node.js基础教程(1)：helloworld]]></title>
      <link>http://yalishizhude.github.io/2015/06/16/helloworld4node-js/</link>
      <guid>http://yalishizhude.github.io/2015/06/16/helloworld4node-js/</guid>
      <pubDate>Mon, 15 Jun 2015 16:35:26 GMT</pubDate>
      <description>
      <![CDATA[<p>##要求</p>
<p>编写一个程序，在终端（标准输出 stdout）打印出 “HELLO WORLD”。</p>
<hr>]]>
      
      </description>
      <content:encoded><![CDATA[<p>##要求</p>
<p>编写一个程序，在终端（标准输出 stdout）打印出 “HELLO WORLD”。</p>
<hr>
<a id="more"></a>
<h2 id="提示">提示</h2><p>要编写一个 Node.js 程序，只需要创建一个后缀名为 .js 的文件，然后用 JavaScript去编写即可。完成后，可以通过命令行 node 命令来运行它，例如：</p>
<pre><code>$ node <span class="function"><span class="keyword">program</span>.<span class="title">js</span></span>
</code></pre><p>和浏览器一样，可以在 Node.js 程序中书写 console：</p>
<pre><code>console.<span class="function"><span class="title">log</span><span class="params">(<span class="string">"HELLO WORLD"</span>)</span></span>
</code></pre><p>此时在控制台上看到</p>
<pre><code><span class="title">HELLO</span> WORLD
</code></pre><p>恭喜正式进入node.js世界~</p>
<p>node.js不仅仅为前端工程师转为全栈插上了翅膀，同时它还可以写桌面app，cs程序…总之它很强大，你值得学习~</p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/06/16/helloworld4node-js/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[《程序员跳槽全攻略》读书摘要]]></title>
      <link>http://yalishizhude.github.io/2015/06/15/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%B7%B3%E6%A7%BD%E5%85%A8%E6%94%BB%E7%95%A5/</link>
      <guid>http://yalishizhude.github.io/2015/06/15/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%B7%B3%E6%A7%BD%E5%85%A8%E6%94%BB%E7%95%A5/</guid>
      <pubDate>Mon, 15 Jun 2015 15:43:23 GMT</pubDate>
      <description>
      <![CDATA[<p>偶然间看到了这本书，看着页数不多，就索性一口气看完了<br>这本书分三部分：原理、准备、操作</p>
<h1 id="原理篇">原理篇</h1><h2 id="使用价值">使用价值</h2><p>根本原则是你的价值（薪水）和你牛不牛无关，只和你能为雇主提供多少价值有关（大多数情况下，你能力越强提供价值越多）。</p>
<h2 id="供需">供需</h2><p>如果你能在一个大的需求中切中一个需大大大于求的细分市场，那么你就能得到远高于其他人的回报。这就好比炒股一样，有的企业可能并不为人知，但是属于细分产业的龙头企业，具有一定的垄断地位，前景自然不会差。</p>
<h2 id="信息透明度">信息透明度</h2><p>求职者和招聘者是信息不对称的，要想拿到足够好的薪资和获得足够多的机会，一定要在短时间内获得大量的机会，这样才能做<strong>选择题</strong>而不是<strong>判断题</strong>。</p>
<h2 id="跳槽不是什么">跳槽不是什么</h2><h3 id="跳槽不是为了追求价值最大化，原因有两个：">跳槽不是为了追求价值最大化，原因有两个：</h3><p>工作是生活的一部分，上班占生活时间的三分之一，如果只是因为高薪选择了一家上班不开心的公司，那么就下来的三分之一日子你都会在痛苦中渡过，而人的一生是有限的。<br>职业上的选择，每一步都是好几年的时光。一旦走下去，就很难回头。所以眼光放长远点，不要只看眼前的高薪，更要看好未来的发展，方向错了，跑得越猛输得越狠。</p>
<h3 id="跳槽不是找工作">跳槽不是找工作</h3><p>跳槽是换工作，它和刚毕业不一样，它是有成本的。权衡得失，不裸辞。</p>
<h3 id="跳槽不是加薪砝码">跳槽不是加薪砝码</h3><p>不要以跳槽为砝码去谈加薪，这种胁迫性的谈薪资方式会使主管对你丧失信任。同样当你跳槽时，如果你的主管通过加薪来挽留你，最好也不要同意。</p>
<h3 id="程序员如何谈薪资">程序员如何谈薪资</h3><ul>
<li>讲一讲自己在工作上的成长，看主管是否认同</li>
<li>从能力提升角度，向主管要一个更大的发展空间和更大的业务挑战</li>
<li>问问当你能力达到这个水平时，薪资是否可以同步提升起来<br>这样有几个好处</li>
<li>它建立了一个谈话基础：薪资和能力匹配</li>
<li>它不谈现在薪资，而是谈未来，不会给主管立刻带来涨薪的压力</li>
<li>体现了自己对能力提升的渴望，而如果在谈话中出现任何不顺利，你可以中途把对话结束，根本不提加薪的事情]]>
      
      </description>
      <content:encoded><![CDATA[<p>偶然间看到了这本书，看着页数不多，就索性一口气看完了<br>这本书分三部分：原理、准备、操作</p>
<h1 id="原理篇">原理篇</h1><h2 id="使用价值">使用价值</h2><p>根本原则是你的价值（薪水）和你牛不牛无关，只和你能为雇主提供多少价值有关（大多数情况下，你能力越强提供价值越多）。</p>
<h2 id="供需">供需</h2><p>如果你能在一个大的需求中切中一个需大大大于求的细分市场，那么你就能得到远高于其他人的回报。这就好比炒股一样，有的企业可能并不为人知，但是属于细分产业的龙头企业，具有一定的垄断地位，前景自然不会差。</p>
<h2 id="信息透明度">信息透明度</h2><p>求职者和招聘者是信息不对称的，要想拿到足够好的薪资和获得足够多的机会，一定要在短时间内获得大量的机会，这样才能做<strong>选择题</strong>而不是<strong>判断题</strong>。</p>
<h2 id="跳槽不是什么">跳槽不是什么</h2><h3 id="跳槽不是为了追求价值最大化，原因有两个：">跳槽不是为了追求价值最大化，原因有两个：</h3><p>工作是生活的一部分，上班占生活时间的三分之一，如果只是因为高薪选择了一家上班不开心的公司，那么就下来的三分之一日子你都会在痛苦中渡过，而人的一生是有限的。<br>职业上的选择，每一步都是好几年的时光。一旦走下去，就很难回头。所以眼光放长远点，不要只看眼前的高薪，更要看好未来的发展，方向错了，跑得越猛输得越狠。</p>
<h3 id="跳槽不是找工作">跳槽不是找工作</h3><p>跳槽是换工作，它和刚毕业不一样，它是有成本的。权衡得失，不裸辞。</p>
<h3 id="跳槽不是加薪砝码">跳槽不是加薪砝码</h3><p>不要以跳槽为砝码去谈加薪，这种胁迫性的谈薪资方式会使主管对你丧失信任。同样当你跳槽时，如果你的主管通过加薪来挽留你，最好也不要同意。</p>
<h3 id="程序员如何谈薪资">程序员如何谈薪资</h3><ul>
<li>讲一讲自己在工作上的成长，看主管是否认同</li>
<li>从能力提升角度，向主管要一个更大的发展空间和更大的业务挑战</li>
<li>问问当你能力达到这个水平时，薪资是否可以同步提升起来<br>这样有几个好处</li>
<li>它建立了一个谈话基础：薪资和能力匹配</li>
<li>它不谈现在薪资，而是谈未来，不会给主管立刻带来涨薪的压力</li>
<li>体现了自己对能力提升的渴望，而如果在谈话中出现任何不顺利，你可以中途把对话结束，根本不提加薪的事情<a id="more"></a>
</li>
</ul>
<hr>
<h2 id="跳槽到底为了什么">跳槽到底为了什么</h2><h3 id="求职的本质">求职的本质</h3><p>金钱积累<br>帮别人挣钱；为自己挣钱；雇别人挣钱；让钱挣钱；</p>
<h3 id="跳槽的意义">跳槽的意义</h3><p>在打工挣钱形态下，我们进行自我调节的方式，通过合理得跳槽，找到市场需求和自我实现的最佳匹配。但随着我们不断成长，职位和能力可能出现不匹配，这时候我们又需要通过跳槽来再次调节。</p>
<h3 id="跳槽的原则">跳槽的原则</h3><p>永远不要因为<strong>现在很差</strong>而跳槽，要因为<strong>未来更好</strong>。只有这样才能保证你一直往上走。</p>
<h3 id="跳槽的节奏路线">跳槽的节奏路线</h3><p>根据职业规划进行调整岗位。最好在本公司内进行调整。</p>
<h1 id="准备篇">准备篇</h1><h2 id="JbDeer职业画布">JbDeer职业画布</h2><p>以价值论为基础，包括价值主张、构造价值、传递价值</p>
<h3 id="构造价值">构造价值</h3><ul>
<li>我是谁，我有什么资源</li>
<li>我的竞争优势<br>包括已有的优势和将有的优势</li>
<li>谁可以帮助我<br>指可以帮你构建价值的人，包括内推的人</li>
</ul>
<h3 id="传递价值">传递价值</h3><ul>
<li>雇主需要什么样的人</li>
<li>怎样让雇主知道你</li>
<li>怎样宣传和证明自己</li>
<li>预估收益</li>
</ul>
<h2 id="自我认识和自我实现">自我认识和自我实现</h2><p>工作只是人生的一部分，是用来支撑你人生价值的核心框架之一。在你自己没有想明白想成为一个什么样的人的时候，没有人能帮你。</p>
<h2 id="职业象限">职业象限</h2><p>这里建议大家看看《穷爸爸富爸爸》</p>
<h2 id="市场需求分析">市场需求分析</h2><h3 id="定量分析">定量分析</h3><p>把符合你标准的公司一个个列出来，没在你所在的城市也没有关系，去他们官网，把招聘启事复制下来，放到数据库里。然后分词，按频率降序列出来。这样可以了解到这些公司对这个职位的要求是什么。</p>
<h3 id="定性分析">定性分析</h3><p>找一下你想要去的公司的工程师，吃个饭聊聊天。只需要着重了解你关心的情况就可以了。</p>
<h2 id="根据需求调整自己的定位">根据需求调整自己的定位</h2><ul>
<li>学会观察技术趋势</li>
<li>投资新兴市场和细分市场</li>
</ul>
<h2 id="构建个人品牌">构建个人品牌</h2><ul>
<li>github账号</li>
<li>技术博客</li>
<li>微博，最好能加V，用于业内交流</li>
<li>技术社区账号，比如stackoverflow<br>平相对大块的东西，可以写成文章放到博客；成系统的东西，可以在文章基础上整理成迷你书。</li>
</ul>
<h2 id="学会沟通和写作">学会沟通和写作</h2><h3 id="条理性">条理性</h3><p>列提纲</p>
<h3 id="逻辑性">逻辑性</h3><h2 id="开始你的开源项目">开始你的开源项目</h2><p>开源项目在求职中是大规模杀伤性武器</p>
<h3 id="通过开源项目转型">通过开源项目转型</h3><p>开源项目让你在新领域的经历不是一片空白，也向招聘方证明了你对这个领域的真实兴趣。</p>
<h3 id="开源项目不似乎遥不可及">开源项目不似乎遥不可及</h3><p>很多有名的项目不过是一些细节上的改进，找一些自己在做项目时遇到的费时费事的小细节做好，然后开源就可以了。<br>举个例子，比如我我们在做图片列表的时候，如果图片高度不同，我们就要截图，很容易把脸给截没了。但其实js版的人脸识别库已经在github上开源了，那我们可以做一个可以识别人脸的只能截取一定高度的图片的jQuery插件，先给自己用，再开源给其他人。<br>比起技术能力，更多的是<strong>来自真实的需求</strong>以及<strong>持续更新的毅力</strong>，这是做好开源项目的秘诀。</p>
<h2 id="提升架构能力">提升架构能力</h2><h3 id="DRY">DRY</h3><p>don’t repeat youself，抽象，自动化</p>
<h3 id="正交性">正交性</h3><p>低耦合</p>
<h1 id="操作篇">操作篇</h1><h2 id="简历的本质">简历的本质</h2><p>简历只有一个目的：帮你约到面试。</p>
<h2 id="简历要说什么">简历要说什么</h2><h3 id="FAB法则">FAB法则</h3><ul>
<li>Feature：是什么</li>
<li>Advantage：你比别人好在哪些地方</li>
<li>Benefit：如果雇佣你，招聘方会得到什么好处</li>
</ul>
<h3 id="给论据别给论题">给论据别给论题</h3><p>论据要具体，最基本的是要数字化，再好点的论据要让人印象深刻。</p>
<h3 id="对比量化成长">对比量化成长</h3><p>可以写你在这个项目里遇到一个什么问题，之前怎么解决的，之后怎么解决的，新方案好在什么地方，你是如何寻找到这个新方案的，最终效果如何。</p>
<h3 id="工具和模板">工具和模板</h3><p>markdown和github</p>
<h2 id="求职渠道">求职渠道</h2><h3 id="人脉：最优途径">人脉：最优途径</h3><h3 id="竞拍：遍历潜在机会">竞拍：遍历潜在机会</h3><p>上竞拍网站</p>
<h3 id="猎头">猎头</h3><p>注意保护隐私，使用小号和来电拦截工具</p>
<h3 id="常规渠道">常规渠道</h3><p>招聘网站和企业官网</p>
<h3 id="直投">直投</h3><p>找技术人员帮忙推荐简历，直投网站</p>
<h2 id="面试准备">面试准备</h2><ul>
<li>遍历简历知识点</li>
<li>构建技能树<img src="http://deerout.sinastorage.cn/sk.jpg" title="[技能树]">
</li>
</ul>
<h2 id="面试常见问题">面试常见问题</h2><h3 id="为什么要离职">为什么要离职</h3><p>不说上家公司坏话，要说这家公司好话</p>
<h3 id="遇到过最大挑战以及解决办法">遇到过最大挑战以及解决办法</h3><p>不一定非要说难度最大的，可以说<strong>以前的挑战太多，记不太清了，讲一个最近发生的事情吧</strong>，从而降低问题难度</p>
<h3 id="你希望三年后成为一个什么样的人">你希望三年后成为一个什么样的人</h3><p>在回答中强调成长性和稳定性</p>
<h3 id="你还有什么要问我们的">你还有什么要问我们的</h3><p>问公司产品、技术</p>
<h2 id="知己知彼">知己知彼</h2><p>如果知道面试者身份，可以先读对方博客和微博，了解风格</p>
<h2 id="准时和礼节">准时和礼节</h2><p>迟到短信通知，如果确定offer也应告知</p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/06/15/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%B7%B3%E6%A7%BD%E5%85%A8%E6%94%BB%E7%95%A5/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Grunt入门]]></title>
      <link>http://yalishizhude.github.io/2015/06/07/grunt/</link>
      <guid>http://yalishizhude.github.io/2015/06/07/grunt/</guid>
      <pubDate>Sun, 07 Jun 2015 13:13:16 GMT</pubDate>
      <description>
      <![CDATA[<p>#1. 安装grunt<br>    npm i -g grunt<br>    npm i -g grunt-cli<br>]]>
      
      </description>
      <content:encoded><![CDATA[<p>#1. 安装grunt<br>    npm i -g grunt<br>    npm i -g grunt-cli<br><a id="more"></a></p>
<p>#2. 编写插件配置文件package.json<br>    {<br>      “name”: “my-project-name”,<br>      “version”: “0.1.0”,<br>      “devDependencies”: {<br>        “grunt”: “”,<br>        “grunt-contrib-jshint”: “”,<br>        “grunt-contrib-uglify”: “”,<br>        “grunt-contrib-concat”: “”,<br>        “grunt-contrib-watch”: “”,<br>        “grunt-contrib-cssmin”: “”,<br>        “grunt-contrib-htmlmin”: “”<br>      }<br>    }</p>
<p>#3. 安装配置的插件<br>    npm i</p>
<p>#4. 编写Gruntfile.js<br>    module.exports = function(grunt) {<br>      // Project configuration.<br>      grunt.initConfig({<br>        pkg: grunt.file.readJSON(‘package.json’),<br>        //合并js文件<br>        concat: {<br>          options: {<br>            // 定义一个用于插入合并输出文件之间的字符<br>            separator: ‘;’<br>          },<br>          js: {<br>            // 将要被合并的js文件<br>            src: [‘WebContent/frame/js/<em>.js’],<br>            // 合并后的JS文件的存放位置<br>            dest: ‘dist/frame/js/public.js’<br>          },<br>          css: {<br>            src: [‘WebContent/frame/css/</em>.css’],<br>            dest: ‘dist/frame/css/public.css’<br>          }<br>        },<br>        //检查js语法<br>        jshint: {<br>          // define the files to lint<br>          files: [‘gruntfile.js’, ‘WebContent/<em>*/</em>.js’],<br>          // configure JSHint (documented at <a href="http://www.jshint.com/docs/" target="_blank" rel="external">http://www.jshint.com/docs/</a>)<br>          options: {<br>            // more options here if you want to override JSHint defaults<br>            globals: {<br>              jQuery: true,<br>              console: true,<br>              module: true<br>            }<br>          }<br>        },<br>        //压缩js文件<br>        uglify: {<br>          options: {<br>            banner: ‘photter’<br>          },<br>          minify:{<br>            files: {<br>              ‘dist/frame/js/public.min.js’: ‘dist/frame/js/public.js’<br>            }<br>          }<br>        },<br>        //压缩css文件<br>        cssmin: {<br>          dist: {<br>            options: {<br>              banner: ‘photter 1.0’<br>            },<br>            files: {<br>              ‘dist/frame/css/public.min.css’: [‘dist/frame/css/<em>.css’]<br>            }<br>          }<br>        },<br>        //压缩html<br>        htmlmin:{<br>          dist: {<br>            options: {<br>              removeComments: true, //删除注释<br>              collapseWhitespace: true //删除标签间的空格<br>            },<br>            files: [<br>              {<br>                expand: true,<br>                cwd: ‘WebContent’,<br>                src: [‘</em>.html’],<br>                dest: ‘dist’<br>              }<br>            ]<br>          }<br>        }<br>      });</p>
<pre><code>  grunt.loadNpmTasks(<span class="string">'grunt-contrib-uglify'</span>);
  <span class="regexp">//grunt</span>.loadNpmTasks(<span class="string">'grunt-contrib-jshint'</span>);
  <span class="regexp">//</span> grunt.loadNpmTasks(<span class="string">'grunt-contrib-watch'</span>);
  grunt.loadNpmTasks(<span class="string">'grunt-contrib-concat'</span>);
  <span class="regexp">//grunt</span>.loadNpmTasks(<span class="string">'grunt-contrib-imagemin'</span>);
  grunt.loadNpmTasks(<span class="string">'grunt-contrib-cssmin'</span>);
  <span class="regexp">//grunt</span>.loadNpmTasks(<span class="string">'grunt-contrib-uncss'</span>);
  <span class="regexp">//</span> 只需在命令行上输入<span class="string">"grunt"</span>，就会执行default task
  grunt.registerTask(<span class="string">'default'</span>, [<span class="string">'concat'</span>, <span class="string">'uglify'</span>, <span class="string">'cssmin'</span>]);
};
</code></pre><p>#5.自动化构建<br>    grunt</p>
]]></content:encoded>
      <comments>http://yalishizhude.github.io/2015/06/07/grunt/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
